import { __assign, __spreadArrays } from "tslib";
// (C) 2019-2022 GoodData Corporation
import compact from "lodash/compact";
import flow from "lodash/flow";
import isNil from "lodash/isNil";
import isString from "lodash/isString";
import stringifyObject from "stringify-object";
import { isUriRef, isIdentifierRef } from "../../objRef";
import { isMeasureLocator, isAttributeSort, isMeasureSort, isAttributeAreaSort, } from "../base/sort";
import { isAbsoluteDateFilter, isRelativeDateFilter, isPositiveAttributeFilter, isNegativeAttributeFilter, isMeasureValueFilter, isComparisonCondition, isRangeCondition, isRankingFilter, } from "../filter";
import { isMeasureDefinition, isArithmeticMeasureDefinition, isPoPMeasureDefinition, isPreviousPeriodMeasureDefinition, isMeasure, } from "../measure";
import { isAttribute } from "../attribute";
import { isTotal } from "../base/totals";
var commonStringifySettings = {
    singleQuotes: false,
    inlineCharacterLimit: 50,
    indent: "    ",
};
var stringify = function (input) { return stringifyObject(input, commonStringifySettings); };
var ARRAY_JOINER = ", ";
var stringifyObjRef = function (ref) {
    if (isUriRef(ref)) {
        return "uriRef(\"" + ref.uri + "\")";
    }
    else if (isIdentifierRef(ref)) {
        return ref.type ? "idRef(\"" + ref.identifier + "\", \"" + ref.type + "\")" : "idRef(\"" + ref.identifier + "\")";
    }
    else {
        return "localIdRef(\"" + ref.localIdentifier + "\")";
    }
};
// dot suffix handling e. g. ".localIdentifier(...)"
// is curried explicitly to allow easier composition in cases where more than one dot suffix is supported
var addStringBuilderSegment = function (identifier, helperName) {
    if (helperName === void 0) { helperName = identifier; }
    return function (objToConvert) {
        return function (value) {
            return objToConvert[identifier]
                ? value + "." + helperName + "(\"" + objToConvert[identifier].split("\n").join("\\n") + "\")"
                : value;
        };
    };
};
var addAggregation = addStringBuilderSegment("aggregation");
var addAlias = addStringBuilderSegment("alias");
var addFormat = addStringBuilderSegment("format");
var addLocalId = addStringBuilderSegment("localIdentifier", "localId");
var addTitle = addStringBuilderSegment("title");
var addFilters = function (_a) {
    var filters = _a.filters;
    return function (value) {
        return (filters === null || filters === void 0 ? void 0 : filters.length) ? value + ".filters(" + filters.map(function (f) { return factoryNotationFor(f); }).join(ARRAY_JOINER) + ")"
            : value;
    };
};
var addRatio = function (_a) {
    var computeRatio = _a.computeRatio;
    return function (value) {
        return computeRatio ? value + ".ratio()" : value;
    };
};
var getBuilder = function (defaultBuilder, builderSegmentHandlers) {
    var builder = flow(builderSegmentHandlers)(defaultBuilder);
    return builder === defaultBuilder ? "undefined" : builder;
};
// converters for each supported object to Model notation string
var convertAttribute = function (_a) {
    var attribute = _a.attribute;
    var builder = getBuilder("a => a", [addAlias(attribute), addLocalId(attribute)]);
    return "newAttribute(" + stringifyObjRef(attribute.displayForm) + ", " + builder + ")";
};
var baseMeasureDotAdders = function (measure) { return [
    addAlias(measure),
    addFormat(measure),
    addLocalId(measure),
    addTitle(measure),
]; };
var convertSimpleMeasure = function (measure, definition) {
    var builder = getBuilder("m => m", __spreadArrays(baseMeasureDotAdders(measure), [
        addAggregation(definition.measureDefinition),
        addFilters(definition.measureDefinition),
        addRatio(definition.measureDefinition),
    ]));
    return "newMeasure(" + stringifyObjRef(definition.measureDefinition.item) + ", " + builder + ")";
};
var convertArithmeticMeasure = function (measure, definition) {
    var builder = getBuilder("m => m", baseMeasureDotAdders(measure));
    return "newArithmeticMeasure(" + stringify(definition.arithmeticMeasure.measureIdentifiers) + ", \"" + definition.arithmeticMeasure.operator + "\", " + builder + ")";
};
var convertPopMeasure = function (measure, definition) {
    var builder = getBuilder("m => m", baseMeasureDotAdders(measure));
    return "newPopMeasure(\"" + definition.popMeasureDefinition.measureIdentifier + "\", " + stringifyObjRef(definition.popMeasureDefinition.popAttribute) + ", " + builder + ")";
};
var convertPreviousPeriodMeasure = function (measure, definition) {
    var _a;
    var builder = getBuilder("m => m", baseMeasureDotAdders(measure));
    var stringifiedDateDatasets = (_a = definition.previousPeriodMeasure.dateDataSets) === null || _a === void 0 ? void 0 : _a.map(function (s) { return "{\n    dataSet: " + stringifyObjRef(s.dataSet) + ",\n    periodsAgo: " + s.periodsAgo + "\n}"; }).join(ARRAY_JOINER);
    return "newPreviousPeriodMeasure(\"" + definition.previousPeriodMeasure.measureIdentifier + "\", [" + stringifiedDateDatasets + "], " + builder + ")";
};
var convertMeasure = function (_a) {
    var measure = _a.measure;
    var definition = measure.definition;
    if (isMeasureDefinition(definition)) {
        return convertSimpleMeasure(measure, definition);
    }
    else if (isArithmeticMeasureDefinition(definition)) {
        return convertArithmeticMeasure(measure, definition);
    }
    else if (isPoPMeasureDefinition(definition)) {
        return convertPopMeasure(measure, definition);
    }
    else if (isPreviousPeriodMeasureDefinition(definition)) {
        return convertPreviousPeriodMeasure(measure, definition);
    }
    throw new Error("Unknown measure type");
};
var convertAttributeAreaSortItem = function (_a) {
    var attributeSortItem = _a.attributeSortItem;
    return "newAttributeAreaSort(\"" + attributeSortItem.attributeIdentifier + "\", \"" + attributeSortItem.direction + "\", \"" + attributeSortItem.aggregation + "\")";
};
var convertAttributeSortItem = function (_a) {
    var attributeSortItem = _a.attributeSortItem;
    return "newAttributeSort(\"" + attributeSortItem.attributeIdentifier + "\", \"" + attributeSortItem.direction + "\")";
};
var convertMeasureSortItem = function (_a) {
    var measureSortItem = _a.measureSortItem;
    var locators = measureSortItem.locators || [];
    var measureLocator = locators.find(function (l) { return isMeasureLocator(l); });
    var attributeLocators = locators.filter(function (l) { return !isMeasureLocator(l); });
    var params = compact([
        "\"" + measureLocator.measureLocatorItem.measureIdentifier + "\"",
        "\"" + measureSortItem.direction + "\"",
        (attributeLocators === null || attributeLocators === void 0 ? void 0 : attributeLocators.length) > 0 && stringify(attributeLocators),
    ]);
    return "newMeasureSort(" + params.join(ARRAY_JOINER) + ")";
};
var convertAbsoluteDateFilter = function (_a) {
    var _b = _a.absoluteDateFilter, dataSet = _b.dataSet, from = _b.from, to = _b.to;
    var restArgs = compact([from, to]).map(stringify);
    return "newAbsoluteDateFilter(" + __spreadArrays([stringifyObjRef(dataSet)], restArgs).join(ARRAY_JOINER) + ")";
};
var convertRelativeDateFilter = function (_a) {
    var _b = _a.relativeDateFilter, dataSet = _b.dataSet, granularity = _b.granularity, from = _b.from, to = _b.to;
    // cannot use lodash compact, that would remove 0 values which we want to keep here
    var restArgs = [granularity, from, to].filter(function (item) { return !isNil(item); }).map(stringify);
    return "newRelativeDateFilter(" + __spreadArrays([stringifyObjRef(dataSet)], restArgs).join(ARRAY_JOINER) + ")";
};
var convertPositiveAttributeFilter = function (_a) {
    var _b = _a.positiveAttributeFilter, displayForm = _b.displayForm, inValues = _b.in;
    var restArgs = compact([inValues]).map(stringify);
    return "newPositiveAttributeFilter(" + __spreadArrays([stringifyObjRef(displayForm)], restArgs).join(ARRAY_JOINER) + ")";
};
var convertNegativeAttributeFilter = function (_a) {
    var _b = _a.negativeAttributeFilter, displayForm = _b.displayForm, notIn = _b.notIn;
    var restArgs = compact([notIn]).map(stringify);
    return "newNegativeAttributeFilter(" + __spreadArrays([stringifyObjRef(displayForm)], restArgs).join(ARRAY_JOINER) + ")";
};
var convertMeasureValueFilter = function (_a) {
    var _b = _a.measureValueFilter, measure = _b.measure, condition = _b.condition;
    var ref = stringifyObjRef(measure);
    if (isComparisonCondition(condition)) {
        var args = compact([
            ref,
            "\"" + condition.comparison.operator + "\"",
            "" + condition.comparison.value,
            !isNil(condition.comparison.treatNullValuesAs) && "" + condition.comparison.treatNullValuesAs,
        ]);
        return "newMeasureValueFilter(" + args.join(ARRAY_JOINER) + ")";
    }
    else if (isRangeCondition(condition)) {
        var args = compact([
            ref,
            "\"" + condition.range.operator + "\"",
            "" + condition.range.from,
            "" + condition.range.to,
            !isNil(condition.range.treatNullValuesAs) && "" + condition.range.treatNullValuesAs,
        ]);
        return "newMeasureValueFilter(" + args.join(ARRAY_JOINER) + ")";
    }
    return "{ measureValueFilter: { measure: " + ref + " }";
};
var convertRankingFilter = function (_a) {
    var _b = _a.rankingFilter, measure = _b.measure, attributes = _b.attributes, value = _b.value, operator = _b.operator;
    var attributesString = attributes === null || attributes === void 0 ? void 0 : attributes.map(stringifyObjRef).join(ARRAY_JOINER);
    var args = [
        stringifyObjRef(measure),
        attributesString && "[" + attributesString + "]",
        "\"" + operator + "\"",
        "" + value,
    ].filter(isString);
    return "newRankingFilter(" + args.join(ARRAY_JOINER) + ")";
};
var convertTotal = function (_a) {
    var attributeIdentifier = _a.attributeIdentifier, measureIdentifier = _a.measureIdentifier, type = _a.type, alias = _a.alias;
    var args = compact([type, measureIdentifier, attributeIdentifier, alias]).map(stringify);
    return "newTotal(" + args.join(ARRAY_JOINER) + ")";
};
var factoryNotationForCore = function (obj, additionalConversion) {
    if (isAttribute(obj)) {
        return convertAttribute(obj);
    }
    else if (isMeasure(obj)) {
        return convertMeasure(obj);
    }
    else if (isAttributeAreaSort(obj)) {
        return convertAttributeAreaSortItem(obj);
    }
    else if (isAttributeSort(obj)) {
        return convertAttributeSortItem(obj);
    }
    else if (isMeasureSort(obj)) {
        return convertMeasureSortItem(obj);
    }
    else if (isAbsoluteDateFilter(obj)) {
        return convertAbsoluteDateFilter(obj);
    }
    else if (isRelativeDateFilter(obj)) {
        return convertRelativeDateFilter(obj);
    }
    else if (isPositiveAttributeFilter(obj)) {
        return convertPositiveAttributeFilter(obj);
    }
    else if (isNegativeAttributeFilter(obj)) {
        return convertNegativeAttributeFilter(obj);
    }
    else if (isMeasureValueFilter(obj)) {
        return convertMeasureValueFilter(obj);
    }
    else if (isRankingFilter(obj)) {
        return convertRankingFilter(obj);
    }
    else if (isTotal(obj)) {
        return convertTotal(obj);
    }
    return additionalConversion === null || additionalConversion === void 0 ? void 0 : additionalConversion(obj);
};
/**
 * Returns a code for generating the provided input using convenience factory methods where possible.
 * @param data - data to return the generating code for
 * @param additionalConversion - specify other conversion that will be tried before falling back to standard stringify. return undefined when you want to fall back to standard stringify.
 * @public
 */
// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
export var factoryNotationFor = function (data, additionalConversion) {
    var _a;
    return ((_a = 
    // try the custom conversion first, stringify-object does not call the transform on the whole input, only on sub-objects
    factoryNotationForCore(data, additionalConversion)) !== null && _a !== void 0 ? _a : stringifyObject(data, __assign(__assign({}, commonStringifySettings), { transform: function (obj, key, originalResult) {
            var _a;
            return (_a = factoryNotationForCore(obj[key], additionalConversion)) !== null && _a !== void 0 ? _a : originalResult;
        } })));
};
//# sourceMappingURL=index.js.map