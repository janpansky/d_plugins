import { __assign, __spreadArrays } from "tslib";
// (C) 2019-2023 GoodData Corporation
import React from "react";
import compact from "lodash/compact";
import omit from "lodash/omit";
import { CoreGeoChart } from "./core/CoreGeoChart";
import { BucketNames, IntlTranslationsProvider, IntlWrapper, withContexts, useResolveValuesWithPlaceholders, } from "@gooddata/sdk-ui";
import { isGeoPushpinChartProps, } from "./GeoChart";
import { bucketsAttributes, bucketsMeasures, disableComputeRatio, MeasureGroupIdentifier, newBucket, newDimension, } from "@gooddata/sdk-model";
import { withTheme } from "@gooddata/sdk-ui-theme-provider";
var getBuckets = function (props) {
    var color = props.color, segmentBy = props.segmentBy, size = props.size, config = props.config;
    var buckets = [
        newBucket.apply(void 0, __spreadArrays([BucketNames.SIZE], (size ? [disableComputeRatio(size)] : []))),
        newBucket.apply(void 0, __spreadArrays([BucketNames.COLOR], (color ? [disableComputeRatio(color)] : []))),
    ];
    if (isGeoPushpinChartProps(props)) {
        var location_1 = props.location;
        buckets.push(newBucket.apply(void 0, __spreadArrays([BucketNames.LOCATION], (location_1 ? [location_1] : []))));
    }
    else {
        var latitude = props.latitude, longitude = props.longitude;
        buckets.push(newBucket.apply(void 0, __spreadArrays([BucketNames.LATITUDE], (latitude ? [latitude] : []))));
        buckets.push(newBucket.apply(void 0, __spreadArrays([BucketNames.LONGITUDE], (longitude ? [longitude] : []))));
    }
    buckets.push(newBucket.apply(void 0, __spreadArrays([BucketNames.SEGMENT], (segmentBy ? [segmentBy] : []))));
    var tooltipText = config === null || config === void 0 ? void 0 : config[BucketNames.TOOLTIP_TEXT];
    if (tooltipText) {
        buckets.push(newBucket(BucketNames.TOOLTIP_TEXT, tooltipText));
    }
    return buckets;
};
/**
 * @internal
 */
export function getGeoChartDimensions(def) {
    var buckets = def.buckets;
    var measures = bucketsMeasures(buckets);
    var attributes = bucketsAttributes(buckets);
    return compact([measures.length > 0 && newDimension([MeasureGroupIdentifier]), newDimension(attributes)]);
}
/**
 * Specifies props that are on geo chart props but not on core chart props - these must not be passed
 * down to core chart.
 */
var getNonCoreProps = function (props) {
    var base = [
        "backend",
        "workspace",
        "segmentBy",
        "filters",
        "sortBy",
        "color",
        "size",
    ];
    if (isGeoPushpinChartProps(props)) {
        return __spreadArrays(base, ["location"]);
    }
    return __spreadArrays(base, ["longitude", "latitude"]);
};
function GeoPushpinChartInner(props) {
    var _a;
    var backend = props.backend, workspace = props.workspace, sortBy = props.sortBy, filters = props.filters, exportTitle = props.exportTitle, _b = props.execConfig, execConfig = _b === void 0 ? {} : _b;
    var buckets = getBuckets(props);
    var newProps = omit(props, getNonCoreProps(props));
    var execution = (_a = backend
        .withTelemetry("GeoPushpinChart", props)
        .workspace(workspace)
        .execution()
        .forBuckets(buckets, filters))
        .withSorting.apply(_a, (sortBy || [])).withDimensions(getGeoChartDimensions)
        .withExecConfig(execConfig);
    return (React.createElement(IntlWrapper, { locale: props.locale },
        React.createElement(IntlTranslationsProvider, null, function (translationProps) {
            return (React.createElement(CoreGeoChart, __assign({ intl: translationProps.intl, execution: execution, exportTitle: exportTitle || "GeoPushpinChart" }, newProps)));
        })));
}
var WrappedGeoPushpinChart = withTheme(withContexts(GeoPushpinChartInner));
var GeoPushpinChartLocation = function (props) {
    var _a = useResolveValuesWithPlaceholders([props.location, props.size, props.color, props.segmentBy, props.filters, props.sortBy], props.placeholdersResolutionContext), location = _a[0], size = _a[1], color = _a[2], segmentBy = _a[3], filters = _a[4], sortBy = _a[5];
    return React.createElement(WrappedGeoPushpinChart, __assign({}, props, { location: location, size: size, color: color, segmentBy: segmentBy, filters: filters, sortBy: sortBy }));
};
var GeoPushpinChartLatitudeLongitude = function (props) {
    var _a = useResolveValuesWithPlaceholders([
        props.longitude,
        props.latitude,
        props.size,
        props.color,
        props.segmentBy,
        props.filters,
        props.sortBy,
    ], props.placeholdersResolutionContext), longitude = _a[0], latitude = _a[1], size = _a[2], color = _a[3], segmentBy = _a[4], filters = _a[5], sortBy = _a[6];
    return (React.createElement(WrappedGeoPushpinChart, __assign({}, props, { longitude: longitude, latitude: latitude, size: size, color: color, segmentBy: segmentBy, filters: filters, sortBy: sortBy })));
};
/**
 * @public
 */
export var GeoPushpinChart = function (props) {
    if (isGeoPushpinChartProps(props)) {
        return React.createElement(GeoPushpinChartLocation, __assign({}, props));
    }
    return React.createElement(GeoPushpinChartLatitudeLongitude, __assign({}, props));
};
//# sourceMappingURL=GeoPushpinChart.js.map