import { __awaiter, __extends, __generator, __spreadArrays } from "tslib";
import { decoratedBackend, } from "../decoratedBackend";
import { LRUCache } from "@gooddata/util";
import { DecoratedSecuritySettingsService } from "../decoratedBackend/securitySettings";
import { DecoratedDataView, DecoratedExecutionFactory, DecoratedExecutionResult, DecoratedPreparedExecution, } from "../decoratedBackend/execution";
import { DecoratedWorkspaceCatalogFactory } from "../decoratedBackend/catalog";
import { DecoratedElementsQuery, DecoratedElementsQueryFactory } from "../decoratedBackend/elements";
import stringify from "json-stable-stringify";
import compact from "lodash/compact";
import first from "lodash/first";
import flow from "lodash/flow";
import identity from "lodash/identity";
import invariant from "ts-invariant";
import partition from "lodash/partition";
import SparkMD5 from "spark-md5";
import { areObjRefsEqual, idRef, isIdentifierRef, isUriRef, uriRef, objRefToString, } from "@gooddata/sdk-model";
import { DecoratedWorkspaceAttributesService } from "../decoratedBackend/attributes";
import { DecoratedWorkspaceSettingsService } from "../decoratedBackend/workspaceSettings";
//
// Execution caching
//
var WithExecutionCaching = /** @class */ (function (_super) {
    __extends(WithExecutionCaching, _super);
    function WithExecutionCaching(decorated, ctx) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.execute = function () { return __awaiter(_this, void 0, void 0, function () {
            var cacheKey, cache, cacheEntry, result, _a;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        cacheKey = this.fingerprint();
                        cache = this.ctx.caches.execution;
                        cacheEntry = cache.get(cacheKey);
                        if (!cacheEntry) {
                            result = _super.prototype.execute.call(this)
                                .then(function (res) {
                                return new WithExecutionResultCaching(res, _this.createNew, _this.ctx);
                            })
                                .catch(function (e) {
                                cache.delete(cacheKey);
                                throw e;
                            });
                            cacheEntry = { result: result };
                            cache.set(cacheKey, cacheEntry);
                        }
                        _a = DefinitionSanitizingExecutionResult.bind;
                        return [4 /*yield*/, cacheEntry.result];
                    case 1: return [2 /*return*/, new (_a.apply(DefinitionSanitizingExecutionResult, [void 0, _b.sent(), this.createNew,
                            this.definition]))()];
                }
            });
        }); };
        _this.createNew = function (decorated) {
            return new WithExecutionCaching(decorated, _this.ctx);
        };
        return _this;
    }
    return WithExecutionCaching;
}(DecoratedPreparedExecution));
/**
 * This DataView decorator makes sure that definition used in it is the same as the definition in the result.
 *
 * See the usage of this class in {@link DefinitionSanitizingExecutionResult} for more.
 */
var DefinitionSanitizingDataView = /** @class */ (function (_super) {
    __extends(DefinitionSanitizingDataView, _super);
    function DefinitionSanitizingDataView(decorated, result) {
        var _this = _super.call(this, decorated, result) || this;
        _this.definition = result.definition;
        return _this;
    }
    return DefinitionSanitizingDataView;
}(DecoratedDataView));
/**
 * This ExecutionResult decorator makes sure that definitions used throughout the result are set
 * to the definitionOverride provided. This is useful with caching because different definitions may yield
 * the same cache key, but having the proper definition in the returned execution result is critical:
 * the definitions in the result must match the one which was used to request it.
 * This however is not always the case when using cached results, so we need to ensure it explicitly.
 *
 * See the usage of this class in {@link WithExecutionCaching} for more.
 */
var DefinitionSanitizingExecutionResult = /** @class */ (function (_super) {
    __extends(DefinitionSanitizingExecutionResult, _super);
    function DefinitionSanitizingExecutionResult(decorated, wrapper, definitionOverride) {
        var _this = _super.call(this, decorated, wrapper) || this;
        _this.readAll = function () { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.withSanitizedDefinition;
                        return [4 /*yield*/, _super.prototype.readAll.call(this)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        }); };
        _this.readWindow = function (offset, size) { return __awaiter(_this, void 0, void 0, function () {
            var _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _a = this.withSanitizedDefinition;
                        return [4 /*yield*/, _super.prototype.readWindow.call(this, offset, size)];
                    case 1: return [2 /*return*/, _a.apply(this, [_b.sent()])];
                }
            });
        }); };
        _this.withSanitizedDefinition = function (original) {
            return new DefinitionSanitizingDataView(original, _this);
        };
        _this.definition = definitionOverride;
        return _this;
    }
    return DefinitionSanitizingExecutionResult;
}(DecoratedExecutionResult));
function windowKey(offset, size) {
    return "o(" + offset.join(",") + ")_s(" + size.join(",") + ")";
}
var WithExecutionResultCaching = /** @class */ (function (_super) {
    __extends(WithExecutionResultCaching, _super);
    function WithExecutionResultCaching(decorated, wrapper, ctx) {
        var _this = _super.call(this, decorated, wrapper) || this;
        _this.ctx = ctx;
        _this.readAll = function () {
            if (!_this.allData) {
                _this.allData = _super.prototype.readAll.call(_this).catch(function (e) {
                    _this.allData = undefined;
                    throw e;
                });
            }
            return _this.allData;
        };
        _this.readWindow = function (offset, size) {
            if (!_this.windows) {
                return _super.prototype.readWindow.call(_this, offset, size);
            }
            var cacheKey = windowKey(offset, size);
            var window = _this.windows.get(cacheKey);
            if (!window) {
                window = _super.prototype.readWindow.call(_this, offset, size).catch(function (e) {
                    if (_this.windows) {
                        _this.windows.delete(cacheKey);
                    }
                    throw e;
                });
                _this.windows.set(cacheKey, window);
            }
            return window;
        };
        if (cachingEnabled(_this.ctx.config.maxResultWindows)) {
            _this.windows = new LRUCache({ maxSize: _this.ctx.config.maxResultWindows });
        }
        return _this;
    }
    return WithExecutionResultCaching;
}(DecoratedExecutionResult));
//
// Catalog caching
//
function optionsKey(options) {
    return stringify(options);
}
var WithCatalogCaching = /** @class */ (function (_super) {
    __extends(WithCatalogCaching, _super);
    function WithCatalogCaching(decorated, ctx) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.load = function () {
            var cache = _this.getOrCreateWorkspaceEntry(_this.workspace).catalogForOptions;
            var cacheKey = optionsKey(_this.options);
            var catalog = cache.get(cacheKey);
            if (!catalog) {
                catalog = _super.prototype.load.call(_this).catch(function (e) {
                    cache.delete(cacheKey);
                    throw e;
                });
                cache.set(cacheKey, catalog);
            }
            return catalog;
        };
        _this.createNew = function (decorated) {
            return new WithCatalogCaching(decorated, _this.ctx);
        };
        _this.getOrCreateWorkspaceEntry = function (workspace) {
            var cache = _this.ctx.caches.workspaceCatalogs;
            var cacheEntry = cache.get(workspace);
            if (!cacheEntry) {
                cacheEntry = {
                    catalogForOptions: new LRUCache({
                        maxSize: _this.ctx.config.maxCatalogOptions,
                    }),
                };
                cache.set(workspace, cacheEntry);
            }
            return cacheEntry;
        };
        return _this;
    }
    return WithCatalogCaching;
}(DecoratedWorkspaceCatalogFactory));
//
// Organization security settings caching
//
function validUrlInContextKey(url, context) {
    return context + "_" + stringify(url);
}
var WithSecuritySettingsCaching = /** @class */ (function (_super) {
    __extends(WithSecuritySettingsCaching, _super);
    function WithSecuritySettingsCaching(decorated, ctx) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.isUrlValid = function (url, context) {
            var cache = _this.getOrCreateSecuritySettingsEntry(_this.scope).valid;
            var cacheKey = validUrlInContextKey(url, context);
            var result = cache.get(cacheKey);
            if (!result) {
                result = _super.prototype.isUrlValid.call(_this, url, context).catch(function (e) {
                    cache.delete(cacheKey);
                    throw e;
                });
                cache.set(cacheKey, result);
            }
            return result;
        };
        _this.isDashboardPluginUrlValid = function (url, workspace) {
            var scope = "plugins_" + workspace;
            var cache = _this.getOrCreateSecuritySettingsEntry(scope).valid;
            var result = cache.get(url);
            if (!result) {
                result = _super.prototype.isDashboardPluginUrlValid.call(_this, url, workspace).catch(function (e) {
                    cache.delete(url);
                    throw e;
                });
                cache.set(url, result);
            }
            return result;
        };
        _this.getOrCreateSecuritySettingsEntry = function (scope) {
            var cache = _this.ctx.caches.securitySettings;
            var cacheEntry = cache.get(scope);
            if (!cacheEntry) {
                cacheEntry = {
                    valid: new LRUCache({
                        maxSize: _this.ctx.config.maxSecuritySettingsOrgUrls,
                        maxAge: _this.ctx.config.maxSecuritySettingsOrgUrlsAge,
                    }),
                };
                cache.set(scope, cacheEntry);
            }
            return cacheEntry;
        };
        return _this;
    }
    return WithSecuritySettingsCaching;
}(DecoratedSecuritySettingsService));
var WithWorkspaceSettingsCaching = /** @class */ (function (_super) {
    __extends(WithWorkspaceSettingsCaching, _super);
    function WithWorkspaceSettingsCaching(decorated, ctx, workspace) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.workspace = workspace;
        _this.getSettings = function () {
            var cache = _this.getOrCreateWorkspaceEntry(_this.workspace).workspaceSettings;
            var cacheKey = _this.workspace;
            var workspaceSettings = cache.get(cacheKey);
            if (!workspaceSettings) {
                workspaceSettings = _super.prototype.getSettings.call(_this).catch(function (e) {
                    cache.delete(cacheKey);
                    throw e;
                });
                cache.set(cacheKey, workspaceSettings);
            }
            return workspaceSettings;
        };
        _this.getOrCreateWorkspaceEntry = function (workspace) {
            var cache = _this.ctx.caches.workspaceSettings;
            var cacheEntry = cache.get(workspace);
            if (!cacheEntry) {
                cacheEntry = {
                    userWorkspaceSettings: new LRUCache({
                        maxSize: _this.ctx.config.maxWorkspaceSettings,
                    }),
                    workspaceSettings: new LRUCache({
                        maxSize: _this.ctx.config.maxWorkspaceSettings,
                    }),
                };
                cache.set(workspace, cacheEntry);
            }
            return cacheEntry;
        };
        return _this;
    }
    WithWorkspaceSettingsCaching.prototype.getSettingsForCurrentUser = function () {
        var cache = this.getOrCreateWorkspaceEntry(this.workspace).userWorkspaceSettings;
        var cacheKey = this.workspace; // we assume that the current user does not change over the life span of the backend instance
        var userWorkspaceSettings = cache.get(cacheKey);
        if (!userWorkspaceSettings) {
            userWorkspaceSettings = _super.prototype.getSettingsForCurrentUser.call(this).catch(function (e) {
                cache.delete(cacheKey);
                throw e;
            });
            cache.set(cacheKey, userWorkspaceSettings);
        }
        return userWorkspaceSettings;
    };
    WithWorkspaceSettingsCaching.prototype.setLocale = function (locale) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, _super.prototype.setLocale.call(this, locale)];
            });
        });
    };
    return WithWorkspaceSettingsCaching;
}(DecoratedWorkspaceSettingsService));
//
// Attributes caching
//
function refMatchesMdObject(ref, mdObject, type) {
    return (areObjRefsEqual(ref, mdObject.ref) ||
        areObjRefsEqual(ref, idRef(mdObject.id, type)) ||
        areObjRefsEqual(ref, uriRef(mdObject.uri)));
}
var firstDefined = flow(compact, first);
function elementsCacheKey(ref, settings) {
    return new SparkMD5().append(objRefToString(ref)).append(stringify(settings)).end();
}
function getOrCreateAttributeCache(ctx, workspace) {
    var cache = ctx.caches.workspaceAttributes;
    var cacheEntry = cache.get(workspace);
    if (!cacheEntry) {
        cacheEntry = {
            displayForms: new LRUCache({
                maxSize: ctx.config.maxAttributeDisplayFormsPerWorkspace,
            }),
            attributesByDisplayForms: new LRUCache({
                maxSize: ctx.config.maxAttributesPerWorkspace,
            }),
            attributeElementResults: cachingEnabled(ctx.config.maxAttributeElementResultsPerWorkspace)
                ? new LRUCache({
                    maxSize: ctx.config.maxAttributeElementResultsPerWorkspace,
                })
                : undefined,
        };
        cache.set(workspace, cacheEntry);
    }
    return cacheEntry;
}
var CachedElementsQuery = /** @class */ (function (_super) {
    __extends(CachedElementsQuery, _super);
    function CachedElementsQuery(decorated, ctx, workspace, ref, settings) {
        if (settings === void 0) { settings = {}; }
        var _this = _super.call(this, decorated, settings) || this;
        _this.ctx = ctx;
        _this.workspace = workspace;
        _this.ref = ref;
        _this.query = function () { return __awaiter(_this, void 0, void 0, function () {
            var canCache, cache, cacheKey, result;
            var _a;
            return __generator(this, function (_b) {
                canCache = !((_a = this.settings.options) === null || _a === void 0 ? void 0 : _a.filter);
                if (!canCache) {
                    return [2 /*return*/, _super.prototype.query.call(this)];
                }
                cache = getOrCreateAttributeCache(this.ctx, this.workspace).attributeElementResults;
                invariant(cache, "inconsistent attribute element cache config");
                cacheKey = elementsCacheKey(this.ref, this.settings);
                result = cache.get(cacheKey);
                if (!result) {
                    result = _super.prototype.query.call(this).catch(function (e) {
                        cache.delete(cacheKey);
                        throw e;
                    });
                    cache.set(cacheKey, result);
                }
                return [2 /*return*/, result];
            });
        }); };
        return _this;
    }
    CachedElementsQuery.prototype.createNew = function (decorated, settings) {
        return new CachedElementsQuery(decorated, this.ctx, this.workspace, this.ref, settings);
    };
    return CachedElementsQuery;
}(DecoratedElementsQuery));
var CachedElementsQueryFactory = /** @class */ (function (_super) {
    __extends(CachedElementsQueryFactory, _super);
    function CachedElementsQueryFactory(decorated, ctx, workspace) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.workspace = workspace;
        return _this;
    }
    CachedElementsQueryFactory.prototype.forDisplayForm = function (ref) {
        var decorated = this.decorated.forDisplayForm(ref);
        return new CachedElementsQuery(decorated, this.ctx, this.workspace, ref);
    };
    return CachedElementsQueryFactory;
}(DecoratedElementsQueryFactory));
var WithAttributesCaching = /** @class */ (function (_super) {
    __extends(WithAttributesCaching, _super);
    function WithAttributesCaching(decorated, ctx, workspace) {
        var _this = _super.call(this, decorated) || this;
        _this.ctx = ctx;
        _this.workspace = workspace;
        _this.getAttributeDisplayForm = function (ref) {
            var cache = getOrCreateAttributeCache(_this.ctx, _this.workspace).displayForms;
            var idCacheKey = isIdentifierRef(ref) ? ref.identifier : undefined;
            var uriCacheKey = isUriRef(ref) ? ref.uri : undefined;
            var cacheItem = firstDefined([idCacheKey, uriCacheKey].map(function (key) { return key && cache.get(key); }));
            if (!cacheItem) {
                cacheItem = _super.prototype.getAttributeDisplayForm.call(_this, ref).catch(function (e) {
                    if (idCacheKey) {
                        cache.delete(idCacheKey);
                    }
                    if (uriCacheKey) {
                        cache.delete(uriCacheKey);
                    }
                    throw e;
                });
                if (idCacheKey) {
                    cache.set(idCacheKey, cacheItem);
                }
                if (uriCacheKey) {
                    cache.set(uriCacheKey, cacheItem);
                }
            }
            return cacheItem;
        };
        _this.getAttributeDisplayForms = function (refs) { return __awaiter(_this, void 0, void 0, function () {
            var cache, refsWithCacheResults, _a, withCacheHits, withoutCacheHits, refsToLoad, _b, alreadyInCache, loadedFromServer, loadedRefs, outputRefs, candidates;
            return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0:
                        cache = getOrCreateAttributeCache(this.ctx, this.workspace).displayForms;
                        refsWithCacheResults = refs.map(function (ref) {
                            var idCacheKey = isIdentifierRef(ref) ? ref.identifier : undefined;
                            var uriCacheKey = isUriRef(ref) ? ref.uri : undefined;
                            var cacheHit = firstDefined([idCacheKey, uriCacheKey].map(function (key) { return key && cache.get(key); }));
                            return { ref: ref, cacheHit: cacheHit };
                        });
                        _a = partition(refsWithCacheResults, function (_a) {
                            var cacheHit = _a.cacheHit;
                            return !!cacheHit;
                        }), withCacheHits = _a[0], withoutCacheHits = _a[1];
                        refsToLoad = withoutCacheHits.map(function (item) { return item.ref; });
                        return [4 /*yield*/, Promise.all([
                                // await the stuff from cache, we need the data available (we cannot just return the promises)
                                Promise.all(withCacheHits.map(function (item) { return item.cacheHit; })),
                                // load items not in cache using the bulk operation
                                this.decorated.getAttributeDisplayForms(refsToLoad),
                            ])];
                    case 1:
                        _b = _c.sent(), alreadyInCache = _b[0], loadedFromServer = _b[1];
                        // save newly loaded to cache for future reference
                        loadedFromServer.forEach(function (loaded) {
                            var promisifiedResult = Promise.resolve(loaded);
                            // save the cache item for both types of refs
                            cache.set(loaded.id, promisifiedResult);
                            cache.set(loaded.uri, promisifiedResult);
                        });
                        loadedRefs = loadedFromServer.map(function (item) { return item.ref; });
                        outputRefs = this.ctx.capabilities.allowsInconsistentRelations
                            ? skipMissingReferences(refs, refsToLoad, loadedRefs)
                            : refs;
                        candidates = __spreadArrays(loadedFromServer, alreadyInCache);
                        return [2 /*return*/, outputRefs.map(function (ref) {
                                var match = candidates.find(function (item) { return refMatchesMdObject(ref, item, "displayForm"); });
                                // if this bombs, some data got lost in the process
                                invariant(match);
                                return match;
                            })];
                }
            });
        }); };
        _this.getAttributeByDisplayForm = function (ref) { return __awaiter(_this, void 0, void 0, function () {
            var cache, idCacheKey, uriCacheKey, cacheItem;
            return __generator(this, function (_a) {
                cache = getOrCreateAttributeCache(this.ctx, this.workspace).attributesByDisplayForms;
                idCacheKey = isIdentifierRef(ref) ? ref.identifier : undefined;
                uriCacheKey = isUriRef(ref) ? ref.uri : undefined;
                cacheItem = firstDefined([idCacheKey, uriCacheKey].map(function (key) { return key && cache.get(key); }));
                if (!cacheItem) {
                    // eslint-disable-next-line sonarjs/no-identical-functions
                    cacheItem = _super.prototype.getAttributeByDisplayForm.call(this, ref).catch(function (e) {
                        if (idCacheKey) {
                            cache.delete(idCacheKey);
                        }
                        if (uriCacheKey) {
                            cache.delete(uriCacheKey);
                        }
                        throw e;
                    });
                    if (idCacheKey) {
                        cache.set(idCacheKey, cacheItem);
                    }
                    if (uriCacheKey) {
                        cache.set(uriCacheKey, cacheItem);
                    }
                }
                return [2 /*return*/, cacheItem];
            });
        }); };
        return _this;
    }
    WithAttributesCaching.prototype.elements = function () {
        var decorated = this.decorated.elements();
        return cachingEnabled(this.ctx.config.maxAttributeElementResultsPerWorkspace)
            ? new CachedElementsQueryFactory(decorated, this.ctx, this.workspace)
            : decorated;
    };
    return WithAttributesCaching;
}(DecoratedWorkspaceAttributesService));
//
//
//
function cachedExecutions(ctx) {
    return function (original) {
        return new DecoratedExecutionFactory(original, function (execution) { return new WithExecutionCaching(execution, ctx); });
    };
}
function cachedCatalog(ctx) {
    return function (original) { return new WithCatalogCaching(original, ctx); };
}
function cachedSecuritySettings(ctx) {
    return function (original) { return new WithSecuritySettingsCaching(original, ctx); };
}
function cachedWorkspaceSettings(ctx) {
    return function (original, workspace) { return new WithWorkspaceSettingsCaching(original, ctx, workspace); };
}
function cachedAttributes(ctx) {
    return function (original, workspace) { return new WithAttributesCaching(original, ctx, workspace); };
}
function cachingEnabled(desiredSize) {
    return desiredSize !== undefined && desiredSize > 0;
}
function cacheControl(ctx) {
    var control = {
        resetExecutions: function () {
            var _a;
            (_a = ctx.caches.execution) === null || _a === void 0 ? void 0 : _a.clear();
        },
        resetCatalogs: function () {
            var _a;
            (_a = ctx.caches.workspaceCatalogs) === null || _a === void 0 ? void 0 : _a.clear();
        },
        resetSecuritySettings: function () {
            var _a;
            (_a = ctx.caches.securitySettings) === null || _a === void 0 ? void 0 : _a.clear();
        },
        resetAttributes: function () {
            var _a;
            (_a = ctx.caches.workspaceAttributes) === null || _a === void 0 ? void 0 : _a.clear();
        },
        resetWorkspaceSettings: function () {
            var _a;
            (_a = ctx.caches.workspaceSettings) === null || _a === void 0 ? void 0 : _a.clear();
        },
        resetAll: function () {
            control.resetExecutions();
            control.resetCatalogs();
            control.resetSecuritySettings();
            control.resetAttributes();
            control.resetWorkspaceSettings();
        },
    };
    return control;
}
function assertPositiveOrUndefined(value, valueName) {
    invariant(value === undefined || value > 0, valueName + " to cache must be positive or undefined, got: " + value);
}
/**
 * These are the recommended settings for the backend caching.
 *
 * @remarks
 * For more information on what the options mean see {@link CachingConfiguration}.
 *
 * @public
 */
export var RecommendedCachingConfiguration = {
    maxExecutions: 10,
    maxResultWindows: 5,
    maxCatalogs: 1,
    maxCatalogOptions: 50,
    maxSecuritySettingsOrgs: 3,
    maxSecuritySettingsOrgUrls: 100,
    maxSecuritySettingsOrgUrlsAge: 300000,
    maxAttributeWorkspaces: 1,
    maxAttributeDisplayFormsPerWorkspace: 100,
    maxAttributesPerWorkspace: 100,
    maxAttributeElementResultsPerWorkspace: 100,
    maxWorkspaceSettings: 1,
};
/**
 * Adds caching layer on top of an existing analytical backend instance. It is currently possible to cache
 * results of executions and the workspace LDM catalog.
 *
 * @remarks see {@link CachingConfiguration} properties for more information.
 * @param realBackend - real backend to decorate with caching
 * @param config - caching configuration. {@link RecommendedCachingConfiguration} can be used
 * @public
 */
export function withCaching(realBackend, config) {
    assertPositiveOrUndefined(config.maxCatalogOptions, "maxCatalogOptions");
    assertPositiveOrUndefined(config.maxSecuritySettingsOrgUrls, "maxSecuritySettingsOrgUrls");
    assertPositiveOrUndefined(config.maxSecuritySettingsOrgUrlsAge, "maxSecuritySettingsOrgUrlsAge");
    var execCaching = cachingEnabled(config.maxExecutions);
    var catalogCaching = cachingEnabled(config.maxCatalogs);
    var securitySettingsCaching = cachingEnabled(config.maxSecuritySettingsOrgs);
    var attributeCaching = cachingEnabled(config.maxAttributeWorkspaces);
    var workspaceSettingsCaching = cachingEnabled(config.maxWorkspaceSettings);
    var ctx = {
        caches: {
            execution: execCaching ? new LRUCache({ maxSize: config.maxExecutions }) : undefined,
            workspaceCatalogs: catalogCaching ? new LRUCache({ maxSize: config.maxCatalogs }) : undefined,
            securitySettings: securitySettingsCaching
                ? new LRUCache({ maxSize: config.maxSecuritySettingsOrgs })
                : undefined,
            workspaceAttributes: attributeCaching
                ? new LRUCache({ maxSize: config.maxAttributeWorkspaces })
                : undefined,
            workspaceSettings: workspaceSettingsCaching
                ? new LRUCache({ maxSize: config.maxWorkspaceSettings })
                : undefined,
        },
        config: config,
        capabilities: realBackend.capabilities,
    };
    var execution = execCaching ? cachedExecutions(ctx) : identity;
    var catalog = catalogCaching ? cachedCatalog(ctx) : identity;
    var securitySettings = securitySettingsCaching ? cachedSecuritySettings(ctx) : identity;
    var attributes = attributeCaching ? cachedAttributes(ctx) : identity;
    var workspaceSettings = workspaceSettingsCaching ? cachedWorkspaceSettings(ctx) : identity;
    if (config.onCacheReady) {
        config.onCacheReady(cacheControl(ctx));
    }
    return decoratedBackend(realBackend, {
        execution: execution,
        catalog: catalog,
        securitySettings: securitySettings,
        attributes: attributes,
        workspaceSettings: workspaceSettings,
    });
}
function skipMissingReferences(requestedRefs, refsToLoad, refsLoadedFromServer) {
    var missingRefs = refsToLoad.filter(function (ref) { return !refsLoadedFromServer.some(function (loadedRef) { return areObjRefsEqual(loadedRef, ref); }); });
    return requestedRefs.filter(function (inputRef) { return !missingRefs.some(function (missingRef) { return areObjRefsEqual(missingRef, inputRef); }); });
}
//# sourceMappingURL=index.js.map