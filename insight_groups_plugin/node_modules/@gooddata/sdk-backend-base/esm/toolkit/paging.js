import { __awaiter, __generator, __spreadArrays } from "tslib";
import invariant from "ts-invariant";
import range from "lodash/range";
import flatMap from "lodash/flatMap";
import isNil from "lodash/isNil";
/**
 * This implementation of {@link @gooddata/sdk-backend-spi#IPagedResource} pages over a list of items
 * provided at construction time. The paging is done using pre-configured page limit and starts at particular offset.
 *
 * @internal
 */
var InMemoryPaging = /** @class */ (function () {
    function InMemoryPaging(allItems, limit, offset) {
        if (limit === void 0) { limit = 50; }
        if (offset === void 0) { offset = 0; }
        this.allItems = allItems;
        invariant(offset >= 0, "paging offset must be non-negative, got: " + offset);
        invariant(limit > 0, "limit must be a positive number, got: " + limit);
        // this will naturally return empty items if at the end of data; limit will always be positive
        this.items = allItems.slice(offset, offset + limit);
        // offset is at most at the end of all available elements
        this.offset = Math.min(offset, allItems.length);
        // limit is always kept as-requested
        this.limit = limit;
        this.totalCount = allItems.length;
    }
    InMemoryPaging.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.items.length === 0) {
                    return [2 /*return*/, this];
                }
                return [2 /*return*/, new InMemoryPaging(this.allItems, this.limit, this.offset + this.items.length)];
            });
        });
    };
    InMemoryPaging.prototype.goTo = function (pageIndex) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.items.length === 0) {
                    return [2 /*return*/, this];
                }
                return [2 /*return*/, new InMemoryPaging(this.allItems, this.limit, pageIndex * this.items.length)];
            });
        });
    };
    InMemoryPaging.prototype.all = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, __spreadArrays(this.allItems)];
            });
        });
    };
    InMemoryPaging.prototype.allSorted = function (compareFn) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, __spreadArrays(this.allItems).sort(compareFn)];
            });
        });
    };
    return InMemoryPaging;
}());
export { InMemoryPaging };
/**
 * Common implementation of the {@link @gooddata/sdk-backend-spi#IPagedResource} for the server-side paging.
 *
 * @internal
 */
var ServerPaging = /** @class */ (function () {
    function ServerPaging(getData, limit, offset, totalCount, items) {
        var _this = this;
        if (limit === void 0) { limit = 50; }
        if (offset === void 0) { offset = 0; }
        this.getData = getData;
        this.limit = limit;
        this.offset = offset;
        this.totalCount = totalCount;
        this.items = items;
        this.next = function () { return __awaiter(_this, void 0, void 0, function () {
            var pageData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        // No items = we are on the last page.
                        if (this.items.length === 0) {
                            return [2 /*return*/, this];
                        }
                        // We are on the last page with the items - return empty result for the next page immediately
                        if (this.items.length < this.limit || this.offset + this.items.length === this.totalCount) {
                            return [2 /*return*/, new ServerPaging(this.getData, this.limit, this.offset + this.limit, this.totalCount, [])];
                        }
                        return [4 /*yield*/, this.getData({ limit: this.limit, offset: this.offset + this.limit })];
                    case 1:
                        pageData = _a.sent();
                        return [2 /*return*/, new ServerPaging(this.getData, this.limit, this.offset + this.limit, pageData.totalCount, pageData.items)];
                }
            });
        }); };
        this.goTo = function (pageIndex) { return __awaiter(_this, void 0, void 0, function () {
            var offset, pageData;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        offset = pageIndex * this.limit;
                        return [4 /*yield*/, this.getData({ limit: this.limit, offset: offset })];
                    case 1:
                        pageData = _a.sent();
                        return [2 /*return*/, new ServerPaging(this.getData, this.limit, offset, pageData.totalCount, pageData.items)];
                }
            });
        }); };
        this.all = function () { return __awaiter(_this, void 0, void 0, function () {
            var results, maxRequests, allPagesToLoad, pagesToLoad, loadedPages;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        results = [];
                        maxRequests = 6;
                        allPagesToLoad = range(0, this.totalCount / this.limit);
                        // if the paged resource is already at the 0 offset, use it directly to save a duplicate request
                        if (this.offset === 0) {
                            results.push.apply(results, this.items);
                            allPagesToLoad.shift();
                        }
                        _a.label = 1;
                    case 1:
                        if (!(allPagesToLoad.length > 0)) return [3 /*break*/, 3];
                        pagesToLoad = allPagesToLoad.slice(0, maxRequests);
                        allPagesToLoad.splice(0, maxRequests);
                        return [4 /*yield*/, Promise.all(pagesToLoad.map(function (page) { return _this.goTo(page); }))];
                    case 2:
                        loadedPages = _a.sent();
                        results.push.apply(results, flatMap(loadedPages, function (page) { return page.items; }));
                        return [3 /*break*/, 1];
                    case 3: return [2 /*return*/, results];
                }
            });
        }); };
        this.allSorted = function (compareFn) { return __awaiter(_this, void 0, void 0, function () {
            var all;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.all()];
                    case 1:
                        all = _a.sent();
                        return [2 /*return*/, all.sort(compareFn)];
                }
            });
        }); };
    }
    ServerPaging.for = function (getData, limit, offset) {
        if (limit === void 0) { limit = 50; }
        if (offset === void 0) { offset = 0; }
        return __awaiter(this, void 0, void 0, function () {
            var _a, totalCount, items;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        invariant(offset >= 0, "paging offset must be non-negative, got: " + offset);
                        invariant(limit > 0, "limit must be a positive number, got: " + limit);
                        return [4 /*yield*/, getData({ limit: limit, offset: offset })];
                    case 1:
                        _a = _b.sent(), totalCount = _a.totalCount, items = _a.items;
                        // must use isNil, totalCount: 0 is a valid case (e.g. when searching for a nonsensical string)
                        invariant(!isNil(totalCount), "total count must be specified, got: " + totalCount);
                        return [2 /*return*/, new ServerPaging(getData, limit, offset, totalCount, items)];
                }
            });
        });
    };
    return ServerPaging;
}());
export { ServerPaging };
//# sourceMappingURL=paging.js.map