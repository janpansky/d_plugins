import { __awaiter, __generator, __spreadArrays } from "tslib";
import invariant from "ts-invariant";
// inspired by the same thing in sdk-backend-base, copied here to avoid the dependency
var InMemoryPaging = /** @class */ (function () {
    function InMemoryPaging(allItems, limit, offset) {
        if (limit === void 0) { limit = 50; }
        if (offset === void 0) { offset = 0; }
        this.allItems = allItems;
        invariant(offset >= 0, "paging offset must be non-negative, got: " + offset);
        invariant(limit > 0, "limit must be a positive number, got: " + limit);
        // this will naturally return empty items if at the end of data; limit will always be positive
        this.items = allItems.slice(offset, offset + limit);
        // offset is at most at the end of all available elements
        this.offset = Math.min(offset, allItems.length);
        // limit is always kept as-requested
        this.limit = limit;
        this.totalCount = allItems.length;
    }
    InMemoryPaging.prototype.next = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.items.length === 0) {
                    return [2 /*return*/, this];
                }
                return [2 /*return*/, new InMemoryPaging(this.allItems, this.limit, this.offset + this.items.length)];
            });
        });
    };
    InMemoryPaging.prototype.goTo = function (pageIndex) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (this.items.length === 0) {
                    return [2 /*return*/, this];
                }
                return [2 /*return*/, new InMemoryPaging(this.allItems, this.limit, pageIndex * this.items.length)];
            });
        });
    };
    InMemoryPaging.prototype.all = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, __spreadArrays(this.allItems)];
            });
        });
    };
    InMemoryPaging.prototype.allSorted = function (compareFn) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, __spreadArrays(this.allItems).sort(compareFn)];
            });
        });
    };
    return InMemoryPaging;
}());
export { InMemoryPaging };
//# sourceMappingURL=InMemoryPaging.js.map