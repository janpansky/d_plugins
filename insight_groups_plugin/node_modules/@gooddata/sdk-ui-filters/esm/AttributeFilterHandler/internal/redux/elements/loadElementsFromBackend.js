import { __awaiter, __generator, __spreadArrays } from "tslib";
// (C) 2022-2023 GoodData Corporation
import isEmpty from "lodash/isEmpty";
import { isElementsQueryOptionsElementsByValue, isValueBasedElementsQueryOptionsElements, } from "@gooddata/sdk-backend-spi";
import { attributeElementsIsEmpty, newNegativeAttributeFilter, newAttribute, newPositiveAttributeFilter, } from "@gooddata/sdk-model";
import { convertError, DataViewFacade } from "@gooddata/sdk-ui";
import { InMemoryPaging } from "./InMemoryPaging";
function loadElementsAsExecution(backend, workspace, displayFormRef, elements, hiddenElementsInfo) {
    return __awaiter(this, void 0, void 0, function () {
        var elementValues, filters, executionResult, executionDataView, dataViewFacade, headers;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    elementValues = elements.values;
                    filters = [newPositiveAttributeFilter(displayFormRef, elementValues)];
                    if (!attributeElementsIsEmpty(hiddenElementsInfo.hiddenElements)) {
                        filters.push(newNegativeAttributeFilter(displayFormRef, hiddenElementsInfo.hiddenElements));
                    }
                    return [4 /*yield*/, backend
                            .workspace(workspace)
                            .execution()
                            .forItems([newAttribute(displayFormRef)], filters)
                            .execute()
                            .catch(function (err) {
                            throw convertError(err);
                        })];
                case 1:
                    executionResult = _a.sent();
                    return [4 /*yield*/, executionResult.readAll().catch(function (err) {
                            throw convertError(err);
                        })];
                case 2:
                    executionDataView = _a.sent();
                    dataViewFacade = DataViewFacade.for(executionDataView);
                    headers = dataViewFacade.meta().attributeHeaders()[0];
                    return [2 /*return*/, headers.map(function (_a) {
                            var header = _a[0];
                            return {
                                title: header.attributeHeaderItem.name,
                                uri: header.attributeHeaderItem.uri,
                            };
                        })];
            }
        });
    });
}
/**
 * @internal
 */
export function loadElementsFromBackend(context, options, hiddenElementsInfo) {
    return __awaiter(this, void 0, void 0, function () {
        var backend, workspace, displayFormRef, elements, limit, limitingAttributeFilters, limitingDateFilters, limitingMeasures, offset, search, order, includeTotalCountWithoutFilters, _a, excludePrimaryLabel, signal, isInitialSelectionRequest, resolvedElements, loader, loaderOptions, effectiveLimitingAttributeFilters;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    backend = context.backend, workspace = context.workspace;
                    displayFormRef = options.displayFormRef, elements = options.elements, limit = options.limit, limitingAttributeFilters = options.limitingAttributeFilters, limitingDateFilters = options.limitingDateFilters, limitingMeasures = options.limitingMeasures, offset = options.offset, search = options.search, order = options.order, includeTotalCountWithoutFilters = options.includeTotalCountWithoutFilters, _a = options.excludePrimaryLabel, excludePrimaryLabel = _a === void 0 ? true : _a, signal = options.signal;
                    isInitialSelectionRequest = isEmpty(limitingAttributeFilters) &&
                        isEmpty(limitingDateFilters) &&
                        isEmpty(limitingMeasures) &&
                        !search &&
                        !excludePrimaryLabel &&
                        !order &&
                        offset === 0;
                    if (!(isElementUrisSupported(backend) &&
                        isElementsQueryOptionsElementsByValue(elements) &&
                        isInitialSelectionRequest)) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadElementsAsExecution(backend, workspace, displayFormRef, elements, hiddenElementsInfo)];
                case 1:
                    resolvedElements = _b.sent();
                    return [2 /*return*/, new InMemoryPaging(resolvedElements, limit, offset)];
                case 2:
                    loader = backend.workspace(workspace).attributes().elements().forDisplayForm(displayFormRef);
                    loaderOptions = {};
                    if (limit) {
                        loader = loader.withLimit(limit);
                    }
                    if (offset) {
                        loader = loader.withOffset(offset);
                    }
                    if (search) {
                        loaderOptions.filter = search;
                    }
                    if (excludePrimaryLabel && !isElementUrisSupported(backend)) {
                        loaderOptions.excludePrimaryLabel = true;
                    }
                    if (elements) {
                        loaderOptions.elements =
                            !isElementUrisSupported(backend) && !isValueBasedElementsQueryOptionsElements(elements)
                                ? { primaryValues: elements.uris }
                                : elements;
                    }
                    if (order) {
                        loaderOptions.order = order;
                    }
                    if (includeTotalCountWithoutFilters) {
                        loaderOptions.includeTotalCountWithoutFilters = includeTotalCountWithoutFilters;
                    }
                    if (!isEmpty(loaderOptions)) {
                        loader = loader.withOptions(loaderOptions);
                    }
                    if (limitingDateFilters === null || limitingDateFilters === void 0 ? void 0 : limitingDateFilters.length) {
                        loader = loader.withDateFilters(limitingDateFilters);
                    }
                    effectiveLimitingAttributeFilters = getLimitingAttributeFilters(displayFormRef, limitingAttributeFilters, hiddenElementsInfo.hiddenElements, hiddenElementsInfo.attribute);
                    if (effectiveLimitingAttributeFilters.length) {
                        loader = loader.withAttributeFilters(effectiveLimitingAttributeFilters);
                    }
                    if (limitingMeasures === null || limitingMeasures === void 0 ? void 0 : limitingMeasures.length) {
                        loader = loader.withMeasures(limitingMeasures);
                    }
                    if (signal) {
                        loader.withSignal(signal);
                    }
                    return [2 /*return*/, loader.query().catch(function (error) {
                            throw convertError(error);
                        })];
            }
        });
    });
}
export var isElementUrisSupported = function (backend) {
    return !!backend.capabilities.supportsElementUris;
};
function getLimitingAttributeFilters(displayFormRef, limitingAttributeFilters, hiddenElements, attribute) {
    if (attributeElementsIsEmpty(hiddenElements)) {
        return limitingAttributeFilters !== null && limitingAttributeFilters !== void 0 ? limitingAttributeFilters : [];
    }
    // add a virtual parent filter to get rid of the hidden elements
    // this is the only way that does not mess up offsets since it is handled by the server "natively"
    var hiddenElementsVirtualFilter = {
        attributeFilter: newNegativeAttributeFilter(displayFormRef, hiddenElements),
        overAttribute: attribute.ref,
    };
    return __spreadArrays([hiddenElementsVirtualFilter], (limitingAttributeFilters !== null && limitingAttributeFilters !== void 0 ? limitingAttributeFilters : []));
}
//# sourceMappingURL=loadElementsFromBackend.js.map