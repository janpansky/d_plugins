import { __assign } from "tslib";
// (C) 2022-2023 GoodData Corporation
import { configureStore } from "@reduxjs/toolkit";
import createSagaMiddleware from "redux-saga";
import { actions, sliceReducer } from "./slice";
import { rootSaga } from "./rootSaga";
import { initialState } from "./state";
import { filterAttributeElements, filterObjRef, isAttributeElementsByValue, isNegativeAttributeFilter, } from "@gooddata/sdk-model";
var nonSerializableActions = [
    actions.loadAttributeError.type,
    actions.loadInitialElementsPageError.type,
    actions.loadNextElementsPageError.type,
    actions.loadCustomElementsError.type,
    actions.initError.type,
];
// We cannot handle event listeners inside saga, as once the root saga is canceled,
// take effects are not working anymore, but we may want to listen for actions,
// that can be fired even during the "cleanup" phase, after the cancelation.
var eventListeningMiddleware = function (eventListener) {
    return function (store) {
        return function (next) {
            return function (action) {
                // First dispatch the action, so we have already updated store in the event listeners.
                var result = next(action);
                eventListener(result, function (selector) { return selector(store.getState()); });
                return result;
            };
        };
    };
};
/**
 * @internal
 */
export function createAttributeFilterHandlerStore(context) {
    var sagaMiddleware = createSagaMiddleware({
        context: {
            attributeFilterContext: context,
        },
    });
    var displayFormRef = filterObjRef(context.attributeFilter);
    var elements = filterAttributeElements(context.attributeFilter);
    var elementsForm = isAttributeElementsByValue(elements) ? "values" : "uris";
    var elementKeys = isAttributeElementsByValue(elements) ? elements.values : elements.uris;
    var isInverted = isNegativeAttributeFilter(context.attributeFilter);
    var store = configureStore({
        preloadedState: __assign(__assign({}, initialState), { displayFormRef: displayFormRef,
            elementsForm: elementsForm, selection: {
                commited: {
                    keys: elementKeys,
                    isInverted: isInverted,
                },
                working: {
                    keys: elementKeys,
                    isInverted: isInverted,
                },
            }, config: {
                hiddenElements: context.hiddenElements,
                staticElements: context.staticElements,
            } }),
        reducer: sliceReducer,
        middleware: function (getDefaultMiddleware) {
            return getDefaultMiddleware({
                thunk: false,
                serializableCheck: {
                    ignoredActions: nonSerializableActions,
                    ignoredPaths: [
                        "initialization.error",
                        "attribute.error",
                        "elements.initialPageLoad.error",
                        "elements.nextPageLoad.error",
                    ],
                },
            }).concat([sagaMiddleware, eventListeningMiddleware(context.eventListener)]);
        },
    });
    var rootSagaTask = sagaMiddleware.run(rootSaga);
    return {
        context: context,
        cancelRootSaga: function () {
            rootSagaTask.cancel();
        },
        dispatch: function (action) {
            store.dispatch(action);
        },
        select: function (selector) {
            return selector(store.getState());
        },
    };
}
//# sourceMappingURL=createStore.js.map