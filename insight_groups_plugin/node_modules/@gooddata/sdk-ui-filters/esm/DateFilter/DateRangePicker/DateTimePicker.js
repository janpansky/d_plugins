// (C) 2022 GoodData Corporation
import React, { useState, useEffect } from "react";
import cx from "classnames";
import { injectIntl } from "react-intl";
import moment from "moment";
import isValid from "date-fns/isValid";
import parse from "date-fns/parse";
import format from "date-fns/format";
import { DateRangePickerInputFieldBody } from "./DateRangePickerInputFieldBody";
import { convertPlatformDateStringToDate } from "../utils/DateConversions";
import { TIME_FORMAT } from "../constants/Platform";
import { getPlatformStringFromDate, getTimeStringFromDate } from "./utils";
function formatDate(date, dateFormat) {
    return format(date, dateFormat);
}
function parseDate(str, dateFormat) {
    try {
        var parsedDate = parse(str, dateFormat, new Date());
        // parse only dates with 4-digit years. this mimics moment.js behavior - it parses only dates above 1900
        // this is to make sure that the picker input is not overwritten in the middle of writing the year with year "0002" when writing 2020.
        //
        // it's also necessary to parse only when the input string fully matches with the desired format
        // to make sure that the picker input is not overwritten in the middle of writing.
        // e.g, let's consider a case where dateFormat is "dd/MM/yyyy" and the DayPickerInput has already been filled with a valid string "13/09/2020",
        // then an user wants to change only the month "13/09/2020" -> "13/11/2020" by removing "09" and typing "11".
        // in such case the parsing should wait until the user completes typing "11" (otherwise if parsing is done right after the first "1" is typed,
        // the cursor automatically moves to the end of the string in the middle of writing, causing a bad experience for the user).
        if (isValid(parsedDate) &&
            parsedDate.getFullYear() >= 1000 &&
            str === formatDate(parsedDate, dateFormat)) {
            return parsedDate;
        }
        return;
    }
    catch (_a) {
        return;
    }
}
var DateTimePickerComponent = React.forwardRef(function (props, ref) {
    var placeholderDate = props.placeholderDate, value = props.value, onChange = props.onChange, dateFormat = props.dateFormat, handleDayClick = props.handleDayClick, isMobile = props.isMobile, isTimeEnabled = props.isTimeEnabled, onKeyDown = props.onKeyDown, className = props.className, _a = props.error, error = _a === void 0 ? false : _a;
    // keeping local copy to enable time update onBlur
    var _b = useState(getTimeStringFromDate(value)), pickerTime = _b[0], setPickerTime = _b[1];
    var _c = useState(formatDate(value, dateFormat)), inputValue = _c[0], setInputValue = _c[1];
    useEffect(function () {
        setInputValue(formatDate(value, dateFormat));
    }, [value]);
    // make sure it contains appropriate time if enabled
    var adjustDate = function (selectedDate) {
        if (isTimeEnabled && selectedDate) {
            var previousDate = value !== null && value !== void 0 ? value : moment(pickerTime, TIME_FORMAT).toDate();
            selectedDate.setHours(previousDate.getHours());
            selectedDate.setMinutes(previousDate.getMinutes());
        }
        return selectedDate;
    };
    var onDateChange = function (selectedDate) {
        onChange(adjustDate(selectedDate));
    };
    var handleInputChange = function (value) {
        setInputValue(value);
        var parsedDate = parseDate(value, dateFormat);
        onDateChange(parsedDate);
    };
    var onTimeChange = function (input) {
        var date = value !== null && value !== void 0 ? value : new Date(); // set today in case of invalid date
        var time = moment(input, TIME_FORMAT);
        if (time.isValid()) {
            date.setHours(time.hours());
            date.setMinutes(time.minutes());
            setPickerTime(input);
        }
        onChange(date);
    };
    return (React.createElement("div", { className: cx(className, isTimeEnabled && "gd-flex-row") },
        isMobile ? (React.createElement(DateRangePickerInputFieldBody, { type: "date", className: cx("s-date-range-picker-date", "gd-date-range-picker-input", "gd-date-range-picker-input-native", error && "gd-date-range-picker-input-error"), placeholder: placeholderDate, onChange: function (event) {
                return onDateChange(convertPlatformDateStringToDate(event.target.value));
            }, value: getPlatformStringFromDate(value) })) : (React.createElement("div", { className: cx("gd-date-range-picker-input", error && "gd-date-range-picker-input-error") },
            React.createElement("span", null,
                React.createElement("span", { className: "gd-icon-calendar" }),
                React.createElement("input", { onKeyDown: onKeyDown, ref: ref, placeholder: placeholderDate, onChange: function (event) { return handleInputChange(event.target.value); }, onClick: handleDayClick, onFocus: handleDayClick, value: inputValue, className: "input-text s-date-range-picker-input-field" })))),
        isTimeEnabled ? (React.createElement("span", { className: cx("gd-date-range-picker-input", "gd-date-range-picker-input-time", "s-date-range-picker-input-time", error && "gd-date-range-picker-input-error") },
            React.createElement("span", { className: "gd-icon-clock" }),
            React.createElement("input", { type: "time", className: "input-text", onChange: function (event) { return onTimeChange(event.target.value); }, value: pickerTime }))) : null));
});
DateTimePickerComponent.displayName = "DateTimePickerComponent";
var DateTimePickerWithInt = injectIntl(DateTimePickerComponent, { forwardRef: true });
DateTimePickerWithInt.displayName = "DateTimePicker";
export { DateTimePickerWithInt };
//# sourceMappingURL=DateTimePicker.js.map