// (C) 2019-2022 GoodData Corporation
import format from "date-fns/format";
import isString from "lodash/isString";
import capitalize from "lodash/capitalize";
import { getIntl } from "@gooddata/sdk-ui";
import { granularityIntlCodes } from "../../constants/i18n";
import { convertPlatformDateStringToDate } from "../DateConversions";
import { isAllTimeDateFilterOption, isAbsoluteDateFilterForm, isAbsoluteDateFilterPreset, isRelativeDateFilterForm, isRelativeDateFilterPreset, } from "@gooddata/sdk-model";
import { DAY_END_TIME, DAY_START_TIME, DEFAULT_DATE_FORMAT, TIME_FORMAT, TIME_FORMAT_WITH_SEPARATOR, } from "../../constants/Platform";
import { messages } from "../../../locales";
import moment from "moment";
export var getTimeRange = function (dateFrom, dateTo) {
    var fromTime = format(dateFrom, TIME_FORMAT);
    var toTime = format(dateTo, TIME_FORMAT);
    return fromTime === toTime ? fromTime : fromTime + " \u2013 " + toTime;
};
var isTimeForWholeDay = function (dateFrom, dateTo) {
    return dateFrom.getHours() === 0 &&
        dateFrom.getMinutes() === 0 &&
        dateTo.getHours() === 23 &&
        dateTo.getMinutes() === 59;
};
var adjustDatetime = function (date, isTimeEnabled, defaultTime) {
    if (defaultTime === void 0) { defaultTime = DAY_START_TIME; }
    if (!isString(date)) {
        return date;
    }
    if (isTimeEnabled && date.split(" ").length === 1) {
        return date + " " + defaultTime;
    }
    return date;
};
export var formatAbsoluteDateRange = function (from, to, dateFormat) {
    var isTimeEnabled = dateFormat.includes(TIME_FORMAT);
    var dateFormatWithoutTime = dateFormat.replace(TIME_FORMAT_WITH_SEPARATOR, "");
    // append start and end times if necessary
    var adjustedFrom = adjustDatetime(from, isTimeEnabled, DAY_START_TIME);
    var adjustedTo = adjustDatetime(to, isTimeEnabled, DAY_END_TIME);
    var fromDate = convertPlatformDateStringToDate(adjustedFrom);
    var toDate = convertPlatformDateStringToDate(adjustedTo);
    var coversWholeDay = isTimeForWholeDay(fromDate, toDate);
    if (moment(fromDate).isSame(toDate, "day")) {
        if (isTimeEnabled && !coversWholeDay) {
            return format(fromDate, dateFormatWithoutTime) + ", " + getTimeRange(fromDate, toDate);
        }
        else {
            return format(fromDate, dateFormatWithoutTime);
        }
    }
    // do not show time in case of whole day coverage
    var displayDateFormat = coversWholeDay ? dateFormatWithoutTime : dateFormat;
    var fromTitle = format(fromDate, displayDateFormat);
    var toTitle = format(toDate, displayDateFormat);
    return fromTitle + " \u2013 " + toTitle;
};
var relativeDateRangeFormatters = [
    {
        // Today, This month
        predicate: function (from, to) { return from === 0 && to === 0; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage(messages["this" + capitalize(intlGranularity)]);
        },
    },
    {
        // Tomorrow, Next month
        predicate: function (from, to) { return from === 1 && to === 1; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage(messages["next" + capitalize(intlGranularity)]);
        },
    },
    {
        // Yesterday, Last month
        predicate: function (from, to) { return from === -1 && to === -1; },
        formatter: function (_from, _to, intlGranularity, translator) {
            return translator.formatMessage(messages["last" + capitalize(intlGranularity)]);
        },
    },
    {
        // Next N days (months)
        predicate: function (from) { return from === 0; },
        formatter: function (_from, to, intlGranularity, translator) {
            return translator.formatMessage(messages["nextN" + capitalize(intlGranularity) + "s"], {
                n: Math.abs(to) + 1,
            });
        },
    },
    {
        // Last N days (months)
        predicate: function (_from, to) { return to === 0; },
        formatter: function (from, _to, intlGranularity, translator) {
            return translator.formatMessage(messages["lastN" + capitalize(intlGranularity) + "s"], {
                n: Math.abs(from) + 1,
            });
        },
    },
    {
        // From N days ago to N days ago
        predicate: function (from, to) { return from < 0 && from === to; },
        formatter: function (from, _to, intlGranularity, translator) {
            return translator.formatMessage(messages[intlGranularity + "s.past.sameValue"], {
                value: Math.abs(from),
            });
        },
    },
    {
        // From N days ago to N days ahead
        predicate: function (from, to) { return from > 0 && from === to; },
        formatter: function (from, _to, intlGranularity, translator) {
            return translator.formatMessage(messages[intlGranularity + "s.future.sameValue"], {
                value: Math.abs(from),
            });
        },
    },
    {
        // From N days ago to M days ago
        predicate: function (from, to) { return from < 0 && to < 0; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage(messages[intlGranularity + "s.past"], {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
    {
        // From N days ahead to M days ahead
        predicate: function (from, to) { return from > 0 && to > 0; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage(messages[intlGranularity + "s.future"], {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
    {
        // From N days ago to M days ahead
        predicate: function () { return true; },
        formatter: function (from, to, intlGranularity, translator) {
            return translator.formatMessage(messages[intlGranularity + "s.mixed"], {
                from: Math.abs(from),
                to: Math.abs(to),
            });
        },
    },
];
export var formatRelativeDateRange = function (from, to, granularity, translator) {
    var intlGranularity = granularityIntlCodes[granularity];
    var formatter = relativeDateRangeFormatters.find(function (f) { return f.predicate(from, to); }).formatter;
    return formatter(from, to, intlGranularity, translator);
};
var getAllTimeFilterRepresentation = function (translator) {
    return translator.formatMessage({ id: "filters.allTime.title" });
};
var getAbsoluteFormFilterRepresentation = function (filter, dateFormat) {
    return filter.from && filter.to ? formatAbsoluteDateRange(filter.from, filter.to, dateFormat) : "";
};
var getAbsolutePresetFilterRepresentation = function (filter, dateFormat) { return formatAbsoluteDateRange(filter.from, filter.to, dateFormat); };
var getRelativeFormFilterRepresentation = function (filter, translator) {
    return typeof filter.from === "number" && typeof filter.to === "number"
        ? formatRelativeDateRange(filter.from, filter.to, filter.granularity, translator)
        : "";
};
var getRelativePresetFilterRepresentation = function (filter, translator) { return formatRelativeDateRange(filter.from, filter.to, filter.granularity, translator); };
var getDateFilterRepresentationByFilterType = function (filter, translator, dateFormat) {
    if (isAbsoluteDateFilterForm(filter) || isRelativeDateFilterForm(filter)) {
        return getDateFilterRepresentationUsingTranslator(filter, translator, dateFormat);
    }
    else if (isAllTimeDateFilterOption(filter) ||
        isAbsoluteDateFilterPreset(filter) ||
        isRelativeDateFilterPreset(filter)) {
        return filter.name || getDateFilterRepresentationUsingTranslator(filter, translator, dateFormat);
    }
    else {
        throw new Error("Unknown DateFilterOption type");
    }
};
// excludeCurrentPeriod is extra metadata that is needed by translation, but it is only used by relative filters
// so the data structure is little inconsistent - for example when we translate absoluteForm we need to pass
// excludeCurrentPeriod that is completely unrelated to absolute filter and is not used in absolute translations.
// So in the future, if there will be need for more metadata, consider adding wrapper union type that would wrap
// DateFilterOption along with additional metadata related to given filter. eg.:
// | { filter: IRelativeDateFilterPreset, excludeCurrentPeriod: boolean } |
// | { filter: IAbsoluteFilterForm } |
// ...
/**
 * Gets the filter title favoring custom name if specified.
 * @returns Representation of the filter (e.g. "My preset", "From 2 weeks ago to 1 week ahead")
 */
export var getDateFilterTitle = function (filter, locale, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DEFAULT_DATE_FORMAT; }
    var translator = getIntl(locale);
    return getDateFilterRepresentationByFilterType(filter, translator, dateFormat);
};
/**
 * Gets the filter title favoring custom name if specified. This function is only for mock purpose.
 * @returns Representation of the filter (e.g. "My preset", "From 2 weeks ago to 1 week ahead")
 */
export var getDateFilterTitleUsingTranslator = function (filter, translator, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DEFAULT_DATE_FORMAT; }
    return getDateFilterRepresentationByFilterType(filter, translator, dateFormat);
};
/**
 * Gets the filter representation regardless of custom name.
 * @returns Representation of the filter (e.g. "From 2 weeks ago to 1 week ahead")
 */
var getDateFilterRepresentationUsingTranslator = function (filter, translator, dateFormat) {
    if (isAbsoluteDateFilterForm(filter)) {
        return getAbsoluteFormFilterRepresentation(filter, dateFormat);
    }
    else if (isAbsoluteDateFilterPreset(filter)) {
        return getAbsolutePresetFilterRepresentation(filter, dateFormat);
    }
    else if (isAllTimeDateFilterOption(filter)) {
        return getAllTimeFilterRepresentation(translator);
    }
    else if (isRelativeDateFilterForm(filter)) {
        return getRelativeFormFilterRepresentation(filter, translator);
    }
    else if (isRelativeDateFilterPreset(filter)) {
        return getRelativePresetFilterRepresentation(filter, translator);
    }
    else {
        throw new Error("Unknown DateFilterOption type");
    }
};
export var getDateFilterRepresentation = function (filter, locale, dateFormat) {
    if (dateFormat === void 0) { dateFormat = DEFAULT_DATE_FORMAT; }
    var translator = getIntl(locale);
    return getDateFilterRepresentationUsingTranslator(filter, translator, dateFormat);
};
//# sourceMappingURL=DateFilterTitle.js.map