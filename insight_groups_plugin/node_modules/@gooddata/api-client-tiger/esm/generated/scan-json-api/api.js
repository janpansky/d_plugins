// (C) 2023 GoodData Corporation
import { __assign, __awaiter, __extends, __generator } from "tslib";
import globalAxios from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, toPathString, createRequestFunction } from './common';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base';
export var DeclarativeColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export var SqlColumnDataTypeEnum = {
    INT: "INT",
    STRING: "STRING",
    DATE: "DATE",
    NUMERIC: "NUMERIC",
    TIMESTAMP: "TIMESTAMP",
    TIMESTAMP_TZ: "TIMESTAMP_TZ",
    BOOLEAN: "BOOLEAN",
};
export var TestDefinitionRequestTypeEnum = {
    POSTGRESQL: "POSTGRESQL",
    REDSHIFT: "REDSHIFT",
    VERTICA: "VERTICA",
    SNOWFLAKE: "SNOWFLAKE",
    ADS: "ADS",
    BIGQUERY: "BIGQUERY",
    MSSQL: "MSSQL",
    PRESTO: "PRESTO",
    DREMIO: "DREMIO",
    DRILL: "DRILL",
    GREENPLUM: "GREENPLUM",
    AZURESQL: "AZURESQL",
    SYNAPSESQL: "SYNAPSESQL",
    DATABRICKS: "DATABRICKS",
};
/**
 * ActionsApi - axios parameter creator
 * @export
 */
export var ActionsApiAxiosParamCreator = function (configuration) {
    var _this = this;
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata: function (dataSourceId, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions;
                return __generator(this, function (_a) {
                    // verify required parameter 'dataSourceId' is not null or undefined
                    assertParamExists("getDataSourceSchemata", "dataSourceId", dataSourceId);
                    localVarPath = "/api/v1/actions/dataSources/{dataSourceId}/scanSchemata".replace("{" + "dataSourceId" + "}", encodeURIComponent(String(dataSourceId)));
                    localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: "GET" }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    setSearchParams(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    return [2 /*return*/, {
                            url: toPathString(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource: function (dataSourceId, scanRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'dataSourceId' is not null or undefined
                    assertParamExists("scanDataSource", "dataSourceId", dataSourceId);
                    // verify required parameter 'scanRequest' is not null or undefined
                    assertParamExists("scanDataSource", "scanRequest", scanRequest);
                    localVarPath = "/api/v1/actions/dataSources/{dataSourceId}/scan".replace("{" + "dataSourceId" + "}", encodeURIComponent(String(dataSourceId)));
                    localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter["Content-Type"] = "application/json";
                    setSearchParams(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    needsSerialization = typeof scanRequest !== "string" ||
                        localVarRequestOptions.headers["Content-Type"] === "application/json";
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(scanRequest !== undefined ? scanRequest : {})
                        : scanRequest || "";
                    return [2 /*return*/, {
                            url: toPathString(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql: function (dataSourceId, scanSqlRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'dataSourceId' is not null or undefined
                    assertParamExists("scanSql", "dataSourceId", dataSourceId);
                    // verify required parameter 'scanSqlRequest' is not null or undefined
                    assertParamExists("scanSql", "scanSqlRequest", scanSqlRequest);
                    localVarPath = "/api/v1/actions/dataSources/{dataSourceId}/scanSql".replace("{" + "dataSourceId" + "}", encodeURIComponent(String(dataSourceId)));
                    localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter["Content-Type"] = "application/json";
                    setSearchParams(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    needsSerialization = typeof scanSqlRequest !== "string" ||
                        localVarRequestOptions.headers["Content-Type"] === "application/json";
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(scanSqlRequest !== undefined ? scanSqlRequest : {})
                        : scanSqlRequest || "";
                    return [2 /*return*/, {
                            url: toPathString(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource: function (dataSourceId, testRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'dataSourceId' is not null or undefined
                    assertParamExists("testDataSource", "dataSourceId", dataSourceId);
                    // verify required parameter 'testRequest' is not null or undefined
                    assertParamExists("testDataSource", "testRequest", testRequest);
                    localVarPath = "/api/v1/actions/dataSources/{dataSourceId}/test".replace("{" + "dataSourceId" + "}", encodeURIComponent(String(dataSourceId)));
                    localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter["Content-Type"] = "application/json";
                    setSearchParams(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    needsSerialization = typeof testRequest !== "string" ||
                        localVarRequestOptions.headers["Content-Type"] === "application/json";
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(testRequest !== undefined ? testRequest : {})
                        : testRequest || "";
                    return [2 /*return*/, {
                            url: toPathString(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition: function (testDefinitionRequest, options) {
            if (options === void 0) { options = {}; }
            return __awaiter(_this, void 0, void 0, function () {
                var localVarPath, localVarUrlObj, baseOptions, localVarRequestOptions, localVarHeaderParameter, localVarQueryParameter, headersFromBaseOptions, needsSerialization;
                return __generator(this, function (_a) {
                    // verify required parameter 'testDefinitionRequest' is not null or undefined
                    assertParamExists("testDataSourceDefinition", "testDefinitionRequest", testDefinitionRequest);
                    localVarPath = "/api/v1/actions/dataSource/test";
                    localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
                    if (configuration) {
                        baseOptions = configuration.baseOptions;
                    }
                    localVarRequestOptions = __assign(__assign({ method: "POST" }, baseOptions), options);
                    localVarHeaderParameter = {};
                    localVarQueryParameter = {};
                    localVarHeaderParameter["Content-Type"] = "application/json";
                    setSearchParams(localVarUrlObj, localVarQueryParameter);
                    headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
                    localVarRequestOptions.headers = __assign(__assign(__assign({}, localVarHeaderParameter), headersFromBaseOptions), options.headers);
                    needsSerialization = typeof testDefinitionRequest !== "string" ||
                        localVarRequestOptions.headers["Content-Type"] === "application/json";
                    localVarRequestOptions.data = needsSerialization
                        ? JSON.stringify(testDefinitionRequest !== undefined ? testDefinitionRequest : {})
                        : testDefinitionRequest || "";
                    return [2 /*return*/, {
                            url: toPathString(localVarUrlObj),
                            options: localVarRequestOptions,
                        }];
                });
            });
        },
    };
};
/**
 * ActionsApi - functional programming interface
 * @export
 */
export var ActionsApiFp = function (configuration) {
    var localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {string} dataSourceId Data source id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata: function (dataSourceId, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.getDataSourceSchemata(dataSourceId, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {string} dataSourceId Data source id
         * @param {ScanRequest} scanRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource: function (dataSourceId, scanRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.scanDataSource(dataSourceId, scanRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {string} dataSourceId Data source id
         * @param {ScanSqlRequest} scanSqlRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql: function (dataSourceId, scanSqlRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.scanSql(dataSourceId, scanSqlRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {string} dataSourceId Data source id
         * @param {TestRequest} testRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource: function (dataSourceId, testRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.testDataSource(dataSourceId, testRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)];
                    }
                });
            });
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {TestDefinitionRequest} testDefinitionRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition: function (testDefinitionRequest, options) {
            return __awaiter(this, void 0, void 0, function () {
                var localVarAxiosArgs;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, localVarAxiosParamCreator.testDataSourceDefinition(testDefinitionRequest, options)];
                        case 1:
                            localVarAxiosArgs = _a.sent();
                            return [2 /*return*/, createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)];
                    }
                });
            });
        },
    };
};
/**
 * ActionsApi - factory interface
 * @export
 */
export var ActionsApiFactory = function (configuration, basePath, axios) {
    var localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
         * @summary Get a list of schema names of a database
         * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDataSourceSchemata: function (requestParameters, options) {
            return localVarFp
                .getDataSourceSchemata(requestParameters.dataSourceId, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
         * @summary Scan a database to get a physical data model (PDM)
         * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanDataSource: function (requestParameters, options) {
            return localVarFp
                .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
         * @summary Collect metadata about SQL query
         * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scanSql: function (requestParameters, options) {
            return localVarFp
                .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * Test if it is possible to connect to a database using an existing data source definition.
         * @summary Test data source connection by data source id
         * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSource: function (requestParameters, options) {
            return localVarFp
                .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
                .then(function (request) { return request(axios, basePath); });
        },
        /**
         * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
         * @summary Test connection by data source definition
         * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testDataSourceDefinition: function (requestParameters, options) {
            return localVarFp
                .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
                .then(function (request) { return request(axios, basePath); });
        },
    };
};
/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
var ActionsApi = /** @class */ (function (_super) {
    __extends(ActionsApi, _super);
    function ActionsApi() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * It scans a database and reads metadata. The result of the request contains a list of schema names of a database.
     * @summary Get a list of schema names of a database
     * @param {ActionsApiGetDataSourceSchemataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.getDataSourceSchemata = function (requestParameters, options) {
        var _this = this;
        return ActionsApiFp(this.configuration)
            .getDataSourceSchemata(requestParameters.dataSourceId, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * It scans a database and transforms its metadata to a declarative definition of the physical data model (PDM). The result of the request contains the mentioned physical data model (PDM) of a database within warning, for example, about unsupported columns.
     * @summary Scan a database to get a physical data model (PDM)
     * @param {ActionsApiScanDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.scanDataSource = function (requestParameters, options) {
        var _this = this;
        return ActionsApiFp(this.configuration)
            .scanDataSource(requestParameters.dataSourceId, requestParameters.scanRequest, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * It executes SQL query against specified data source and extracts metadata. Metadata consist of column names and column data types. It can optionally provide also preview of data returned by SQL query
     * @summary Collect metadata about SQL query
     * @param {ActionsApiScanSqlRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.scanSql = function (requestParameters, options) {
        var _this = this;
        return ActionsApiFp(this.configuration)
            .scanSql(requestParameters.dataSourceId, requestParameters.scanSqlRequest, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Test if it is possible to connect to a database using an existing data source definition.
     * @summary Test data source connection by data source id
     * @param {ActionsApiTestDataSourceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.testDataSource = function (requestParameters, options) {
        var _this = this;
        return ActionsApiFp(this.configuration)
            .testDataSource(requestParameters.dataSourceId, requestParameters.testRequest, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    /**
     * Test if it is possible to connect to a database using a connection provided by the data source definition in the request body.
     * @summary Test connection by data source definition
     * @param {ActionsApiTestDataSourceDefinitionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    ActionsApi.prototype.testDataSourceDefinition = function (requestParameters, options) {
        var _this = this;
        return ActionsApiFp(this.configuration)
            .testDataSourceDefinition(requestParameters.testDefinitionRequest, options)
            .then(function (request) { return request(_this.axios, _this.basePath); });
    };
    return ActionsApi;
}(BaseAPI));
export { ActionsApi };
//# sourceMappingURL=api.js.map