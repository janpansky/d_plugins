import { __read } from "tslib";
// (C) 2007-2022 GoodData Corporation
import React, { useEffect, useCallback, useMemo } from "react";
import { Table, Column, Cell } from "fixed-data-table-2";
import cx from "classnames";
// it configures max number of records due to
// inefficiency with virtual memory allocation
// that causes application crash (TNT-787)
var MAX_NUMBER_OF_ROWS = 1000000;
var BORDER_HEIGHT = 1;
var HALF_ROW = 0.5;
export var MAX_VISIBLE_ITEMS_COUNT = 10;
export var DEFAULT_ITEM_HEIGHT = 28;
/**
 * @internal
 */
export function List(props) {
    var _a = props.className, className = _a === void 0 ? "" : _a, _b = props.compensateBorder, compensateBorder = _b === void 0 ? true : _b, _c = props.width, width = _c === void 0 ? 200 : _c, height = props.height, _d = props.items, items = _d === void 0 ? [] : _d, _e = props.itemsCount, itemsCount = _e === void 0 ? items.length : _e, _f = props.itemHeight, itemHeight = _f === void 0 ? DEFAULT_ITEM_HEIGHT : _f, _g = props.itemHeightGetter, itemHeightGetter = _g === void 0 ? null : _g, _h = props.maxVisibleItemsCount, maxVisibleItemsCount = _h === void 0 ? MAX_VISIBLE_ITEMS_COUNT : _h, renderItem = props.renderItem, onScrollStart = props.onScrollStart, onScrollEnd = props.onScrollEnd, scrollToItem = props.scrollToItem;
    var currentItemsCount = itemsCount > maxVisibleItemsCount ? maxVisibleItemsCount + HALF_ROW : itemsCount;
    var listHeight = height || currentItemsCount * itemHeight;
    var scrollToItemRowIndex = useMemo(function () {
        if (!scrollToItem) {
            return undefined;
        }
        return items.indexOf(scrollToItem) + 1;
    }, [items, scrollToItem]);
    var getVisibleScrollRange = useCallback(function (scrollY) {
        var rowIndex = Math.floor(scrollY / itemHeight);
        var visibleRange = Math.ceil(listHeight / itemHeight);
        return [rowIndex, rowIndex + visibleRange];
    }, [itemHeight, listHeight]);
    var handleScrollStart = useCallback(function (_, y) {
        if (onScrollStart) {
            var _a = __read(getVisibleScrollRange(y), 2), startIndex = _a[0], endIndex = _a[1];
            onScrollStart(startIndex, endIndex);
        }
    }, [onScrollStart, getVisibleScrollRange]);
    var handleScrollEnd = useCallback(function (_, y) {
        if (onScrollEnd) {
            var _a = __read(getVisibleScrollRange(y), 2), startIndex = _a[0], endIndex = _a[1];
            onScrollEnd(startIndex, endIndex);
        }
    }, [onScrollEnd, getVisibleScrollRange]);
    useEffect(function () {
        return function () {
            enablePageScrolling();
        };
    }, []);
    var styles = useMemo(function () {
        return {
            width: width,
        };
    }, [width]);
    return (React.createElement("div", { role: "list", className: cx("gd-list gd-infinite-list", className), style: styles, onMouseOver: disablePageScrolling, onMouseOut: enablePageScrolling },
        React.createElement(Table, { width: width, 
            // compensates for https://github.com/facebook/fixed-data-table/blob/5373535d98b08b270edd84d7ce12833a4478c6b6/src/FixedDataTableNew.react.js#L872
            height: compensateBorder ? listHeight + BORDER_HEIGHT * 2 : listHeight, headerHeight: 0, rowHeight: itemHeight, rowHeightGetter: itemHeightGetter, rowsCount: Math.min(itemsCount, MAX_NUMBER_OF_ROWS), onScrollStart: handleScrollStart, onScrollEnd: handleScrollEnd, scrollToRow: scrollToItemRowIndex, touchScrollEnabled: isTouchDevice() },
            React.createElement(Column, { flexGrow: 1, width: 1, cell: function (_a) {
                    var columnKey = _a.columnKey, height = _a.height, width = _a.width, rowIndex = _a.rowIndex;
                    var item = items[rowIndex];
                    return (React.createElement(Cell, { width: width, height: height, rowIndex: rowIndex, columnKey: columnKey }, renderItem({
                        rowIndex: rowIndex,
                        item: item,
                        width: width,
                        height: height,
                        isFirst: rowIndex === 0,
                        isLast: rowIndex === itemsCount - 1,
                    })));
                } }))));
}
function preventDefault(e) {
    e.preventDefault();
}
function isTouchDevice() {
    return "ontouchstart" in document.documentElement;
}
function disablePageScrolling() {
    document.body.addEventListener("wheel", preventDefault, { passive: false });
}
function enablePageScrolling() {
    document.body.removeEventListener("wheel", preventDefault);
}
//# sourceMappingURL=List.js.map