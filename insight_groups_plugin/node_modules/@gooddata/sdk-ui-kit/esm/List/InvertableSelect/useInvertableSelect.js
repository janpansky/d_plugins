// (C) 2007-2022 GoodData Corporation
import { useMemo, useCallback } from "react";
import differenceBy from "lodash/differenceBy";
import intersectionBy from "lodash/intersectionBy";
import keyBy from "lodash/keyBy";
import noop from "lodash/noop";
/**
 * @internal
 */
export function useInvertableSelect(props) {
    var items = props.items, totalItemsCount = props.totalItemsCount, getItemKey = props.getItemKey, searchString = props.searchString, _a = props.isInverted, isInverted = _a === void 0 ? true : _a, selectedItems = props.selectedItems, _b = props.onSelect, onSelect = _b === void 0 ? noop : _b;
    var isSearch = searchString.length > 0;
    var isSelectionEmpty = selectedItems.length === 0;
    var selectionMap = useMemo(function () {
        return keyBy(selectedItems, getItemKey);
    }, [selectedItems, getItemKey]);
    var itemsNotInSelection = useMemo(function () { return differenceBy(items, selectedItems, getItemKey); }, [items, selectedItems, getItemKey]);
    var itemsInSelection = useMemo(function () { return intersectionBy(items, selectedItems, getItemKey); }, [items, selectedItems, getItemKey]);
    var loadedSelectedItems = useMemo(
    // For inverted list, items are selected when they are not in the selection
    function () { return (isInverted ? itemsNotInSelection : itemsInSelection); }, [isInverted, itemsNotInSelection, itemsInSelection]);
    var loadedUnselectedItems = useMemo(
    // For inverted list, items are unselected when they are in the selection
    function () { return (isInverted ? itemsInSelection : itemsNotInSelection); }, [isInverted, itemsNotInSelection, itemsInSelection]);
    var selectionState = useMemo(function () {
        if (!isSearch) {
            // Negative filter with no selection
            if (isInverted && isSelectionEmpty) {
                return "all";
            }
            // Positive filter with all items selected
            if (!isInverted && loadedSelectedItems.length === totalItemsCount) {
                return "all";
            }
            // Positive filter with no selection
            if (!isInverted && isSelectionEmpty) {
                return "none";
            }
            // Negative filter with all items selected
            if (isInverted && loadedUnselectedItems.length === totalItemsCount) {
                return "none";
            }
        }
        else {
            if (isInverted && itemsInSelection.length === 0) {
                return "all";
            }
            if (!isInverted && itemsInSelection.length === totalItemsCount) {
                return "all";
            }
            if (isInverted && itemsInSelection.length === totalItemsCount) {
                return "none";
            }
            if (!isInverted && itemsInSelection.length === 0) {
                return "none";
            }
        }
        return "partial";
    }, [isInverted, isSelectionEmpty, totalItemsCount, loadedSelectedItems, isSearch, loadedUnselectedItems]);
    var getIsItemSelected = useCallback(function (item) {
        var itemKey = getItemKey(item);
        return isInverted ? !selectionMap[itemKey] : !!selectionMap[itemKey];
    }, [isInverted, selectionMap, getItemKey]);
    var selectAll = useCallback(function () {
        onSelect([], true);
    }, [onSelect]);
    var selectNone = useCallback(function () {
        onSelect([], false);
    }, [onSelect]);
    var selectOnly = useCallback(function (item) {
        onSelect([item], false);
    }, [onSelect]);
    var selectItems = useCallback(function (items) {
        var newItems = isInverted
            ? differenceBy(selectedItems, items, getItemKey)
            : selectedItems.concat(items);
        if (!isSearch && !isInverted && newItems.length === totalItemsCount) {
            // Selecting last item -> select all
            selectAll();
        }
        else {
            onSelect(newItems, isInverted);
        }
    }, [isInverted, selectedItems, onSelect, selectAll, getItemKey, totalItemsCount, isSearch]);
    var deselectItems = useCallback(function (items) {
        var newItems = isInverted
            ? selectedItems.concat(items)
            : differenceBy(selectedItems, items, getItemKey);
        if (!isSearch && isInverted && newItems.length === totalItemsCount) {
            selectNone();
        }
        else {
            onSelect(newItems, isInverted);
        }
    }, [isInverted, selectedItems, onSelect, selectNone, getItemKey, totalItemsCount, isSearch]);
    var onSelectAllCheckboxToggle = useCallback(function () {
        if (isSearch) {
            if (selectionState === "all" || loadedSelectedItems.length === items.length) {
                // Reduce selection, if is all, or all loaded is selected
                deselectItems(loadedSelectedItems);
            }
            else {
                // Extend selection if is none or partial
                selectItems(loadedUnselectedItems);
            }
        }
        else if (selectionState === "all") {
            // Is all -> select none
            selectNone();
        }
        else {
            // Is partial or none -> select all
            selectAll();
        }
    }, [
        items,
        selectionState,
        loadedUnselectedItems,
        loadedSelectedItems,
        selectItems,
        deselectItems,
        selectAll,
        selectNone,
        isSearch,
    ]);
    var onSelectAllCheckboxChange = useCallback(function (value) {
        if (isSearch) {
            if (value) {
                selectItems(loadedUnselectedItems);
            }
            else {
                deselectItems(loadedSelectedItems);
            }
        }
        else if (value) {
            selectAll();
        }
        else {
            selectNone();
        }
    }, [
        items,
        selectionState,
        loadedUnselectedItems,
        loadedSelectedItems,
        selectItems,
        deselectItems,
        selectAll,
        selectNone,
        isSearch,
    ]);
    return {
        onSelectAllCheckboxToggle: onSelectAllCheckboxToggle,
        onSelectAllCheckboxChange: onSelectAllCheckboxChange,
        getIsItemSelected: getIsItemSelected,
        selectionState: selectionState,
        selectItems: selectItems,
        deselectItems: deselectItems,
        selectOnly: selectOnly,
    };
}
//# sourceMappingURL=useInvertableSelect.js.map