import { __assign, __extends, __read } from "tslib";
// (C) 2020-2022 GoodData Corporation
import React from "react";
import { v4 as uuid } from "uuid";
import debounce from "lodash/debounce";
import noop from "lodash/noop";
import format from "date-fns/format";
import parse from "date-fns/parse";
import isValid from "date-fns/isValid";
import isSameDay from "date-fns/isSameDay";
import { enUS, de, es, fr, ja, nl, pt, ptBR, zhCN, ru } from "date-fns/locale";
import classNames from "classnames";
import { IntlWrapper } from "@gooddata/sdk-ui";
import { injectIntl } from "react-intl";
import { DayPicker } from "react-day-picker";
import { getOptimalAlignment } from "../utils/overlay";
import { elementRegion } from "../utils/domUtilities";
import { DEFAULT_DATE_FORMAT } from "../constants/platform";
var DATEPICKER_OUTSIDE_DAY_SELECTOR = "rdp-day_outside";
var convertedLocales = {
    "en-US": enUS,
    "de-DE": de,
    "es-ES": es,
    "fr-FR": fr,
    "ja-JP": ja,
    "nl-NL": nl,
    "pt-BR": ptBR,
    "pt-PT": pt,
    "zh-Hans": zhCN,
    "ru-RU": ru,
};
function formatDate(date, dateFormat) {
    return format(date, dateFormat);
}
function convertLocale(locale) {
    return convertedLocales[locale];
}
function parseDate(str, dateFormat) {
    try {
        var parsedDate = parse(str, dateFormat, new Date());
        // parse only dates with 4-digit years. this mimics moment.js behavior - it parses only dates above 1900
        // this is to make sure that the picker input is not overwritten in the middle of writing the year with year "0002" when writing 2020.
        //
        // it's also necessary to parse only when the input string fully matches with the desired format
        // to make sure that the picker input is not overwritten in the middle of writing.
        // e.g, let's consider a case where dateFormat is "dd/MM/yyyy" and the DayPickerInput has already been filled with a valid string "13/09/2020",
        // then an user wants to change only the month "13/09/2020" -> "13/11/2020" by removing "09" and typing "11".
        // in such case the parsing should wait until the user completes typing "11" (otherwise if parsing is done right after the first "1" is typed,
        // the cursor automatically moves to the end of the string in the middle of writing, causing a bad experience for the user).
        if (isValid(parsedDate) &&
            parsedDate.getFullYear() >= 1000 &&
            str === formatDate(parsedDate, dateFormat)) {
            return parsedDate;
        }
        return;
    }
    catch (_a) {
        return;
    }
}
var WrappedDatePicker = /** @class */ (function (_super) {
    __extends(WrappedDatePicker, _super);
    function WrappedDatePicker(props) {
        var _this = _super.call(this, props) || this;
        _this.datePickerContainerRef = React.createRef();
        _this.inputRef = React.createRef();
        _this.resizeHandler = debounce(function () { return _this.alignDatePicker(); }, 100);
        var alignPoints = props.alignPoints, date = props.date, dateFormat = props.dateFormat;
        _this.state = {
            align: alignPoints[0].align,
            selectedDate: date,
            monthDate: date,
            inputValue: formatDate(date || new Date(), dateFormat),
            isOpen: false,
        };
        _this.handleDayChanged = _this.handleDayChanged.bind(_this);
        _this.handleMonthChanged = _this.handleMonthChanged.bind(_this);
        _this.handleInputChanged = _this.handleInputChanged.bind(_this);
        _this.alignDatePicker = _this.alignDatePicker.bind(_this);
        _this.setComponentRef = _this.setComponentRef.bind(_this);
        _this.handleWrapperClick = _this.handleWrapperClick.bind(_this);
        _this.handleClickOutside = _this.handleClickOutside.bind(_this);
        _this.onKeyDown = _this.onKeyDown.bind(_this);
        return _this;
    }
    WrappedDatePicker.prototype.componentDidMount = function () {
        var _a = this.props, date = _a.date, dateFormat = _a.dateFormat;
        this.setState({ selectedDate: this.updateDate(date || new Date()) });
        this.setState({ inputValue: formatDate(date || new Date(), dateFormat) });
        window.addEventListener("resize", this.resizeHandler);
        document.addEventListener("mousedown", this.handleClickOutside);
    };
    WrappedDatePicker.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        var props = this.props;
        if (props.date > nextProps.date || props.date < nextProps.date) {
            var selectedDate = this.updateDate(nextProps.date);
            this.setState({ selectedDate: selectedDate });
            this.setState({ monthDate: selectedDate });
            this.setState({ inputValue: formatDate(selectedDate, props.dateFormat) });
        }
    };
    WrappedDatePicker.prototype.componentWillUnmount = function () {
        window.removeEventListener("resize", this.resizeHandler);
        document.removeEventListener("mousedown", this.handleClickOutside);
    };
    WrappedDatePicker.prototype.handleClickOutside = function (event) {
        if (this.datePickerContainerRef.current &&
            !this.datePickerContainerRef.current.contains(event.target) &&
            this.inputRef &&
            !this.inputRef.current.contains(event.target)) {
            this.setState({ isOpen: false });
        }
    };
    WrappedDatePicker.prototype.componentDidUpdate = function (_prevProps, prevState) {
        if (this.state.isOpen && !prevState.isOpen) {
            this.alignDatePicker();
        }
    };
    WrappedDatePicker.prototype.setComponentRef = function (ref) {
        this.rootRef = ref;
    };
    WrappedDatePicker.prototype.getInputClasses = function () {
        return classNames("input-text", "small-12", this.props.size, "gd-datepicker-input-" + uuid());
    };
    WrappedDatePicker.prototype.getComponentClasses = function () {
        return classNames("gd-datepicker", this.props.className, this.props.size, "gd-datepicker-input", this.state.isOpen ? "gd-datepicker-focused" : "");
    };
    WrappedDatePicker.prototype.getOverlayWrapperClasses = function () {
        var _a = __read(this.state.align.split(" "), 2), inputAnchorPoint = _a[0], pickerAnchorPoint = _a[1];
        return classNames("gd-datepicker-picker", "gd-datepicker-OverlayWrapper", "gd-datepicker-OverlayWrapper-" + inputAnchorPoint + "-xx", "gd-datepicker-OverlayWrapper-xx-" + pickerAnchorPoint);
    };
    WrappedDatePicker.prototype.updateDate = function (date) {
        return this.normalizeDate(date);
    };
    WrappedDatePicker.prototype.handleInputChanged = function (e) {
        var _this = this;
        var value = e.target.value;
        var parsedDate = parseDate(value, this.props.dateFormat);
        this.setState({ inputValue: value });
        if (parsedDate) {
            this.setState({
                selectedDate: parsedDate,
                monthDate: parsedDate,
            }, function () {
                _this.props.onChange(_this.state.selectedDate);
            });
        }
        else {
            if (this.props.resetOnInvalidValue) {
                this.setState({
                    selectedDate: this.state.selectedDate,
                    monthDate: this.state.selectedDate,
                });
                return;
            }
            this.setState({
                selectedDate: undefined,
                monthDate: undefined,
            }, function () {
                _this.props.onChange(null);
            });
        }
    };
    WrappedDatePicker.prototype.handleDayChanged = function (newlySelectedDate) {
        var _this = this;
        if (!newlySelectedDate) {
            this.setState({ isOpen: false });
            return;
        }
        if (isSameDay(this.state.selectedDate, newlySelectedDate)) {
            this.setState({ isOpen: false });
            return;
        }
        this.inputRef.current.focus();
        this.setState({
            selectedDate: newlySelectedDate,
            monthDate: newlySelectedDate,
            inputValue: formatDate(newlySelectedDate, this.props.dateFormat),
            isOpen: false,
        }, function () {
            _this.props.onChange(newlySelectedDate);
        });
    };
    WrappedDatePicker.prototype.handleMonthChanged = function (month) {
        this.inputRef.current.focus();
        this.setState({ monthDate: month });
    };
    WrappedDatePicker.prototype.normalizeDate = function (date) {
        return new Date(date.getFullYear(), date.getMonth(), date.getDate());
    };
    WrappedDatePicker.prototype.alignDatePicker = function () {
        var _this = this;
        var alignPoints = this.props.alignPoints;
        var container = this.datePickerContainerRef.current.parentElement;
        if (!alignPoints || !container)
            return;
        var optimalAlignment = getOptimalAlignment({
            targetRegion: elementRegion(this.rootRef),
            selfRegion: elementRegion(container),
            alignPoints: alignPoints,
        });
        var align = optimalAlignment.alignment.align;
        this.setState({
            align: align,
        }, function () {
            _this.props.onAlign(align);
        });
    };
    WrappedDatePicker.prototype.onKeyDown = function (e) {
        if (e.key === "Escape" || e.key === "Tab") {
            this.setState({ isOpen: false });
        }
    };
    WrappedDatePicker.prototype.handleWrapperClick = function (e) {
        var classList = e.target.classList;
        /**
         * Prevent default fixes bug BB-332 but prevents in closing other dropdowns (Bug BB-1102)
         * so we want to prevent default only when clicking on outside dates in datepicker
         */
        if (e.target && classList && classList.contains(DATEPICKER_OUTSIDE_DAY_SELECTOR)) {
            e.preventDefault();
        }
    };
    WrappedDatePicker.prototype.render = function () {
        var _this = this;
        var _a = this.state, inputValue = _a.inputValue, selectedDate = _a.selectedDate, monthDate = _a.monthDate, isOpen = _a.isOpen;
        var _b = this.props, placeholder = _b.placeholder, intl = _b.intl, tabIndex = _b.tabIndex;
        var classNamesProps = {
            root: this.getOverlayWrapperClasses(),
        };
        return (React.createElement("div", { role: "datepicker", className: this.getComponentClasses(), ref: this.setComponentRef, onClick: this.handleWrapperClick },
            React.createElement("input", { onKeyDown: this.onKeyDown, tabIndex: tabIndex, onClick: function () { return _this.setState({ isOpen: true }); }, onFocus: function () { return _this.setState({ isOpen: true }); }, ref: this.inputRef, value: inputValue, className: this.getInputClasses(), placeholder: placeholder, onChange: this.handleInputChanged }),
            isOpen ? (React.createElement("div", { role: "datepicker-picker", ref: this.datePickerContainerRef },
                React.createElement(DayPicker, { classNames: classNamesProps, locale: convertLocale(intl.locale), showOutsideDays: true, mode: "single", onSelect: this.handleDayChanged, selected: selectedDate, month: monthDate, onMonthChange: this.handleMonthChanged }))) : null,
            React.createElement("span", { className: "gd-datepicker-icon gd-icon-calendar" })));
    };
    WrappedDatePicker.defaultProps = {
        className: "",
        date: new Date(),
        placeholder: "",
        onChange: noop,
        resetOnInvalidValue: false,
        size: "",
        tabIndex: 0,
        alignPoints: [{ align: "bl tl" }, { align: "br tr" }, { align: "tl bl" }, { align: "tr br" }],
        onAlign: noop,
        dateFormat: DEFAULT_DATE_FORMAT,
    };
    return WrappedDatePicker;
}(React.PureComponent));
export { WrappedDatePicker };
var DatePickerWithIntl = injectIntl(WrappedDatePicker);
/**
 * @internal
 */
var Datepicker = /** @class */ (function (_super) {
    __extends(Datepicker, _super);
    function Datepicker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Datepicker.prototype.render = function () {
        return (React.createElement(IntlWrapper, { locale: this.props.locale },
            React.createElement(DatePickerWithIntl, __assign({}, this.props))));
    };
    return Datepicker;
}(React.PureComponent));
export { Datepicker };
//# sourceMappingURL=Datepicker.js.map