import { __assign, __extends, __read, __spread } from "tslib";
// (C) 2020-2022 GoodData Corporation
import React, { createRef } from "react";
import cx from "classnames";
import { Portal } from "react-portal";
import bindAll from "lodash/bindAll";
import pick from "lodash/pick";
import isEqual from "lodash/isEqual";
import isReactEqual from "react-fast-compare";
import findIndex from "lodash/findIndex";
import debounce from "lodash/debounce";
import noop from "lodash/noop";
import { v4 as uuid } from "uuid";
// eslint-disable-next-line import/no-unassigned-import
import "element-closest-polyfill";
import { DEFAULT_ALIGN_POINTS, getOptimalAlignment, getOverlayStyles } from "../utils/overlay";
import { elementRegion, isFixedPosition } from "../utils/domUtilities";
import { ENUM_KEY_CODE } from "../typings/utilities";
import { OverlayContext } from "./OverlayContext";
var events = [
    { name: "click", handler: "closeOnOutsideClick", target: document },
    {
        name: "mousedown",
        handler: "onDocumentMouseDown",
        target: document,
        requiredProp: "closeOnOutsideClick",
    },
    { name: "goodstrap.scrolled", handler: "closeOnParentScroll" },
    { name: "goodstrap.drag", handler: "closeOnMouseDrag" },
    { name: "keydown", handler: "closeOnEscape" },
];
var eventProps = events.map(function (event) { return event.handler; });
var ALIGN_TIMEOUT_MS = 10;
var INIT_STATE_ALIGN = -500;
export var POSITION_SAME_AS_TARGET = "sameAsTarget";
var OVERLAY_CONTENT_CLASS = "gd-overlay-content";
function exceedsThreshold(firstNumber, secondNumber) {
    return Math.abs(firstNumber - secondNumber) > 2;
}
function alignExceedsThreshold(firstAlignment, secondAlignment) {
    return (exceedsThreshold(firstAlignment.top, secondAlignment.top) ||
        exceedsThreshold(firstAlignment.left, secondAlignment.left) ||
        exceedsThreshold(firstAlignment.right, secondAlignment.right));
}
var stopPropagation = function (e) {
    var _a;
    e.stopPropagation();
    var reactMajorVersion = parseInt((_a = React.version) === null || _a === void 0 ? void 0 : _a.split(".")[0], 10);
    // Propagate events to `document` for react 17
    // (We need to get them for other overlays to close and the events did not get there due to changes
    // introduced in https://reactjs.org/blog/2020/08/10/react-v17-rc.html#changes-to-event-delegation)
    if (reactMajorVersion >= 17) {
        var evt = new MouseEvent(e.nativeEvent.type, e.nativeEvent);
        Object.defineProperty(evt, "target", { value: e.nativeEvent.target, enumerable: true });
        document.dispatchEvent(evt);
    }
};
/**
 * @internal
 */
var Overlay = /** @class */ (function (_super) {
    __extends(Overlay, _super);
    function Overlay(props) {
        var _this = _super.call(this, props) || this;
        _this.overlayRef = createRef();
        _this.containerRef = createRef();
        _this.resizeHandler = debounce(function () { return _this.align(); }, 100);
        _this.portalNode = null;
        _this.id = uuid();
        _this.align = function () {
            var _a = _this.props, alignPoints = _a.alignPoints, alignTo = _a.alignTo, positionType = _a.positionType;
            var overlay = _this.overlayRef.current;
            if (!alignPoints || !overlay) {
                return;
            }
            var isSameAsTarget = _this.isSameAsTargetPosition(positionType);
            var optimalAlign = getOptimalAlignment({
                targetRegion: elementRegion(alignTo, isSameAsTarget),
                selfRegion: elementRegion(overlay),
                alignPoints: alignPoints,
                ignoreScrollOffsets: isSameAsTarget,
            });
            if (alignExceedsThreshold(_this.state.alignment, optimalAlign.alignment)) {
                _this.setState({
                    alignment: optimalAlign.alignment,
                }, function () {
                    _this.props.onAlign(optimalAlign.alignment);
                });
            }
            else {
                _this.props.onAlign(optimalAlign.alignment);
            }
        };
        _this.clearAlignmentTimeout = function () {
            if (_this.alignmentTimeoutId) {
                window.clearTimeout(_this.alignmentTimeoutId);
            }
        };
        _this.alignWithTimeout = function () {
            _this.clearAlignmentTimeout();
            _this.alignmentTimeoutId = window.setTimeout(function () {
                _this.align();
            }, ALIGN_TIMEOUT_MS);
        };
        _this.onMaskClick = function (e) {
            if (!_this.props.closeOnOutsideClick) {
                e.stopPropagation();
            }
        };
        _this.getOverlayStyles = function () {
            var _a = _this.props, alignTo = _a.alignTo, positionType = _a.positionType;
            var alignment = _this.state.alignment;
            var position = _this.isSameAsTargetPosition(positionType)
                ? isFixedPosition(alignTo)
                    ? "fixed"
                    : "absolute"
                : positionType;
            return {
                position: position,
                left: alignment.left,
                top: alignment.top,
                zIndex: _this.getZIndex(),
                visibility: _this.isAligned() ? undefined : "hidden",
            };
        };
        _this.getOverlayClasses = function () {
            return cx(_this.props.className, _this.getAlignClasses(), {
                "overlay-wrapper": true,
            });
        };
        /**
         * Add CSS classes to overlay wrapper, so they can be used
         * for position of arrows and stuff
         */
        _this.getAlignClasses = function () {
            var align = _this.state.alignment.align.split(" ");
            return "target-" + align[0] + " self-" + align[1];
        };
        _this.isSameAsTargetPosition = function (positionType) {
            return positionType === POSITION_SAME_AS_TARGET;
        };
        _this.isEventOnParent = function (event) {
            var _a;
            var node = _this.containerRef.current;
            var eventNode = ((_a = event.detail) === null || _a === void 0 ? void 0 : _a.node) || event.target;
            return eventNode.contains(node);
        };
        _this.shouldCloseOnClick = function (e) {
            if (!_this.isComponentMounted) {
                return false;
            }
            if (!_this.isAligned()) {
                return false;
            }
            // an ignored node has been clicked, always keep the overlay open
            if (_this.hasClickedOnIgnoredNode(e)) {
                return false;
            }
            // non-ignored node clicked, give shouldCloseOnClick the chance
            // to override closing the dialog
            return _this.props.shouldCloseOnClick(e);
        };
        _this.hasClickedOnIgnoredNode = function (e) {
            if (e.defaultPrevented) {
                // Ignore event if it should be prevented (e.q. by click in child component)
                return true;
            }
            var clickedElement = e.target;
            if (_this.isElementInChildOverlay(clickedElement) || _this.clickedInside) {
                return true;
            }
            var ignoredRefElements = __spread([_this.overlayRef.current], _this.props.ignoreClicksOn);
            var clickInsideIgnoredRefElement = ignoredRefElements.some(function (ref) {
                return ref === null || ref === void 0 ? void 0 : ref.contains(clickedElement);
            });
            if (clickInsideIgnoredRefElement) {
                return true;
            }
            return _this.props.ignoreClicksOnByClass.some(function (selector) { return clickedElement.closest(selector); });
        };
        _this.isAligned = function () {
            return _this.state.alignment.left !== INIT_STATE_ALIGN && _this.state.alignment.top != INIT_STATE_ALIGN;
        };
        // makes assumption that overlays later in the DOM are child overlays
        _this.isElementInChildOverlay = function (element) {
            var overlays = Array.from(document.querySelectorAll(".overlay-wrapper"));
            var thisOverlayIndex = findIndex(overlays, function (overlay) { return overlay === _this.overlayRef.current; });
            return overlays.slice(thisOverlayIndex + 1).some(function (overlay) { return overlay.contains(element); });
        };
        _this.closeOnMouseDrag = function () {
            if (!_this.isComponentMounted) {
                return;
            }
            _this.props.onClose();
        };
        _this.updateListeners = function (method, props) {
            events.forEach(function (event) {
                if (props[event.handler] || props[event.requiredProp]) {
                    var handler = _this[event.handler];
                    if (handler) {
                        (event.target || window)[method + "EventListener"](event.name, handler);
                    }
                }
            });
        };
        _this.addListeners = function (props) {
            _this.updateListeners("add", props);
        };
        _this.removeListeners = function (props) {
            _this.updateListeners("remove", props);
        };
        _this.renderMask = function () {
            var styles = {
                zIndex: _this.context ? _this.context.getZIndex(_this.id) : null,
            };
            return _this.props.isModal ? (React.createElement("div", { className: "modalityPlugin-mask modalityPlugin-mask-visible", onClick: _this.onMaskClick, style: styles })) : (false);
        };
        _this.state = {
            alignment: {
                align: props.alignPoints[0].align,
                left: INIT_STATE_ALIGN,
                top: INIT_STATE_ALIGN,
                right: 0,
            },
        };
        _this.isComponentMounted = false;
        _this.clickedInside = false;
        _this.alignmentTimeoutId = 0;
        bindAll(_this, events.map(function (event) { return event.handler; }));
        _this.createPortalNode();
        return _this;
    }
    Overlay.prototype.UNSAFE_componentWillMount = function () {
        var _a;
        // reserve the zIndex via the context as soon as possible so that Overlays in the children get higher zIndex
        (_a = this.context) === null || _a === void 0 ? void 0 : _a.addOverlay(this.id);
    };
    Overlay.prototype.componentDidMount = function () {
        this.isComponentMounted = true;
        afterOverlayOpened();
        window.addEventListener("resize", this.resizeHandler);
        this.addListeners(this.props);
        this.alignWithTimeout();
    };
    Overlay.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        if (!isEqual(pick(this.props, eventProps), pick(nextProps, eventProps))) {
            this.removeListeners(this.props);
            this.addListeners(nextProps);
        }
    };
    Overlay.prototype.shouldComponentUpdate = function (nextProps, nextState) {
        var propsChanged = !isReactEqual(this.props, nextProps);
        var positionChanged = !isEqual(this.state.alignment, nextState.alignment);
        return propsChanged || positionChanged;
    };
    Overlay.prototype.componentDidUpdate = function () {
        this.alignWithTimeout();
    };
    Overlay.prototype.componentWillUnmount = function () {
        var _a;
        this.isComponentMounted = false;
        this.clearAlignmentTimeout();
        window.removeEventListener("resize", this.resizeHandler);
        this.removeListeners(this.props);
        this.removePortalNodeAfterAllTreeUnmount();
        (_a = this.context) === null || _a === void 0 ? void 0 : _a.removeOverlay(this.id);
        afterOverlayClosed();
    };
    Overlay.prototype.render = function () {
        // Need stop propagation of events from Portal thats new behavior of react 16
        // https://github.com/facebook/react/issues/11387
        return (React.createElement("span", { "aria-label": "portal-scroll-anchor", className: "s-portal-scroll-anchor", ref: this.containerRef },
            React.createElement(Portal, { node: this.portalNode },
                React.createElement("div", { className: cx(this.props.containerClassName, OVERLAY_CONTENT_CLASS), onClick: this.props.onClick, onMouseOver: this.props.onMouseOver, onMouseUp: this.props.onMouseUp },
                    this.renderMask(),
                    React.createElement("div", { ref: this.overlayRef, style: this.getOverlayStyles(), className: this.getOverlayClasses() }, this.props.children)))));
    };
    Overlay.prototype.getZIndex = function () {
        return this.context ? this.context.getZIndex(this.id) : this.props.zIndex;
    };
    Overlay.prototype.createPortalNode = function () {
        this.portalNode = document.createElement("div");
        document.body.appendChild(this.portalNode);
    };
    Overlay.prototype.removePortalNodeAfterAllTreeUnmount = function () {
        var _this = this;
        setTimeout(function () {
            if (_this.portalNode && document.body.contains(_this.portalNode)) {
                document.body.removeChild(_this.portalNode);
            }
            _this.portalNode = null;
        });
    };
    Overlay.prototype.onDocumentMouseDown = function (e) {
        this.clickedInside = this.overlayRef.current.contains(e.target);
        if (this.clickedInside) {
            e.stopPropagation();
        }
    };
    Overlay.prototype.closeOnParentScroll = function (e) {
        if (!this.isComponentMounted) {
            return;
        }
        if (this.isEventOnParent(e)) {
            this.props.onClose();
        }
    };
    Overlay.prototype.closeOnOutsideClick = function (e) {
        if (this.shouldCloseOnClick(e)) {
            this.props.onClose();
        }
    };
    Overlay.prototype.closeOnEscape = function (e) {
        if (this.isComponentMounted &&
            this.props.closeOnEscape &&
            e.keyCode === ENUM_KEY_CODE.KEY_CODE_ESCAPE) {
            this.props.onClose();
        }
    };
    Overlay.defaultProps = {
        alignPoints: DEFAULT_ALIGN_POINTS,
        alignTo: "body",
        children: false,
        className: "",
        containerClassName: "",
        positionType: "absolute",
        ignoreClicksOn: [],
        ignoreClicksOnByClass: [],
        shouldCloseOnClick: function () { return true; },
        onClick: stopPropagation,
        onMouseOver: stopPropagation,
        onMouseUp: stopPropagation,
        onAlign: noop,
        onClose: noop,
    };
    Overlay.contextType = OverlayContext;
    return Overlay;
}(React.Component));
export { Overlay };
var overlayState = {
    opened: 0,
    body: {},
    html: {},
};
function afterOverlayOpened() {
    if (overlayState.opened === 0) {
        var styles = getOverlayStyles();
        overlayState.html = applyStyles(document.documentElement, styles.html);
        overlayState.body = applyStyles(document.body, styles.body);
    }
    overlayState.opened++;
}
function afterOverlayClosed() {
    overlayState.opened--;
    if (overlayState.opened === 0) {
        applyStyles(document.documentElement, overlayState.html);
        applyStyles(document.body, overlayState.body);
    }
}
function applyStyles(el, newStyles) {
    return Object.keys(newStyles).reduce(function (prev, key) {
        var _a;
        var oldValue = el.style[key];
        el.style[key] = newStyles[key];
        return __assign(__assign({}, prev), (_a = {}, _a[key] = oldValue, _a));
    }, {});
}
//# sourceMappingURL=Overlay.js.map