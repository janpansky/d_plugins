import { __assign, __extends } from "tslib";
// (C) 2007-2022 GoodData Corporation
import React, { Component } from "react";
import { v4 as uuid } from "uuid";
import identity from "lodash/identity";
import TextareaAutosize from "react-textarea-autosize";
import cx from "classnames";
import { Overlay } from "../Overlay";
import { ENUM_KEY_CODE } from "../typings/utilities";
/**
 * @internal
 */
var EditableLabelInner = /** @class */ (function (_super) {
    __extends(EditableLabelInner, _super);
    function EditableLabelInner(props) {
        var _this = _super.call(this, props) || this;
        _this.focusTimeout = 0;
        _this.onDocumentClick = function (e) {
            if (_this.isClickOutsideTextarea(e.target)) {
                var textAreaNode = _this.textarea.current;
                textAreaNode.blur();
            }
        };
        _this.onKeyDown = function (e) {
            var isSubmit = e.keyCode === ENUM_KEY_CODE.KEY_CODE_ENTER;
            var isCancel = e.keyCode === ENUM_KEY_CODE.KEY_CODE_ESCAPE;
            if (isSubmit || isCancel) {
                e.preventDefault();
                e.stopPropagation();
            }
            if (isSubmit) {
                _this.onSubmit();
            }
            if (isCancel) {
                _this.onCancel();
            }
        };
        _this.onSubmit = function () {
            var oldValue = _this.props.value;
            var newTrimmedValue = _this.state.value.trim();
            if (newTrimmedValue === "") {
                _this.setState({
                    value: "",
                });
            }
            if (oldValue !== newTrimmedValue) {
                _this.props.onSubmit(newTrimmedValue);
            }
            else {
                _this.props.onCancel(oldValue);
            }
            _this.setState({
                value: newTrimmedValue,
                isEditing: false,
            });
            _this.removeListeners();
        };
        _this.onCancel = function () {
            var value = _this.props.value;
            _this.props.onCancel(value);
            _this.setState({
                value: value,
                isEditing: false,
            });
            _this.removeListeners();
        };
        _this.onChange = function (e) {
            var value = e.target.value;
            _this.setState({ value: value }, function () {
                _this.props.onChange(value);
            });
        };
        _this.edit = function (_e) {
            if (!_this.state.isEditing) {
                _this.setState({
                    isEditing: true,
                }, function () {
                    _this.selectAndFocus();
                    document.addEventListener("mousedown", _this.onDocumentClick);
                });
                _this.props.onEditingStart();
            }
        };
        _this.selectAndFocus = function () {
            var componentElement = _this.textarea.current;
            var _a = _this.props, scrollToEndOnEditingStart = _a.scrollToEndOnEditingStart, textareaInOverlay = _a.textareaInOverlay;
            if (componentElement) {
                window.clearTimeout(_this.focusTimeout);
                // without the timeout the focus sometimes got stolen by the previously active item for some reason
                _this.focusTimeout = window.setTimeout(function () {
                    componentElement.focus();
                    if (scrollToEndOnEditingStart && _this.isMultiLine()) {
                        componentElement.scrollTop = componentElement.scrollHeight;
                    }
                    componentElement.select();
                    if (textareaInOverlay) {
                        _this.measureRootDimensions();
                    }
                }, 1);
            }
        };
        _this.state = {
            value: props.value,
            isEditing: false,
            textareaWidth: 100,
        };
        _this.root = React.createRef();
        _this.textarea = React.createRef();
        return _this;
    }
    EditableLabelInner.prototype.componentDidMount = function () {
        var rootNode = this.root.current;
        rootNode.addEventListener("dragstart", this.onSelectStart);
        rootNode.addEventListener("selectstart", this.onSelectStart);
        if (this.props.autofocus) {
            this.edit();
        }
    };
    EditableLabelInner.prototype.UNSAFE_componentWillReceiveProps = function (newProps) {
        if (this.props.value !== newProps.value) {
            this.setState({
                value: newProps.value,
            });
        }
    };
    EditableLabelInner.prototype.componentWillUnmount = function () {
        var rootNode = this.root.current;
        rootNode.removeEventListener("dragstart", this.onSelectStart);
        rootNode.removeEventListener("selectstart", this.onSelectStart);
        this.removeListeners();
        clearTimeout(this.focusTimeout);
    };
    EditableLabelInner.prototype.onSelectStart = function (e) {
        e.stopPropagation();
    };
    EditableLabelInner.prototype.isClickOutsideTextarea = function (clickedTarget) {
        return this.textarea.current && !this.textarea.current.contains(clickedTarget);
    };
    EditableLabelInner.prototype.isMultiLine = function () {
        return this.props.maxRows > 1;
    };
    EditableLabelInner.prototype.removeListeners = function () {
        document.removeEventListener("mousedown", this.onDocumentClick);
    };
    EditableLabelInner.prototype.measureRootDimensions = function () {
        var rootElement = this.root.current;
        var rootElementFontSize = getComputedStyle(rootElement).fontSize;
        this.setState({
            textareaWidth: rootElement.offsetWidth,
            textareaFontSize: Math.floor(parseInt(rootElementFontSize, 10)),
        });
    };
    EditableLabelInner.prototype.renderTextAreaInOverlay = function () {
        var alignId = "gd-editable-label-" + uuid();
        var style = {
            width: this.state.textareaWidth,
            fontSize: this.state.textareaFontSize + "px",
            // http://stackoverflow.com/a/6295222
            lineHeight: this.state.textareaFontSize * 1.25 + "px",
        };
        return (React.createElement("div", { role: "textarea-wrapper", className: alignId + " gd-editable-label-textarea-wrapper" },
            React.createElement(Overlay, { alignTo: "." + alignId, alignPoints: [
                    {
                        align: "cr cr",
                    },
                ] },
                React.createElement("div", { className: "gd-editable-label-overlay" }, this.renderTextarea(style)))));
    };
    EditableLabelInner.prototype.renderTextarea = function (style) {
        if (style === void 0) { style = {}; }
        return (React.createElement(TextareaAutosize, { style: style, rows: 1, maxRows: this.props.maxRows, maxLength: this.props.maxLength, onKeyDown: this.onKeyDown, onBlur: this.onSubmit, onChange: this.onChange, defaultValue: this.props.value, placeholder: this.props.placeholder, ref: this.textarea }));
    };
    EditableLabelInner.prototype.renderEditableLabelEdit = function () {
        return this.props.textareaInOverlay
            ? this.renderTextAreaInOverlay()
            : this.renderTextarea(this.root.current && this.props.isEditableLabelWidthBasedOnText
                ? { width: this.root.current.getBoundingClientRect().width }
                : {});
    };
    EditableLabelInner.prototype.render = function () {
        var editableLabelClasses = cx({
            "gd-editable-label": true,
            "s-editable-label": true,
            "is-editing": this.state.isEditing,
            placeholder: this.state.value === "",
        }, this.props.className);
        var displayValue = this.props.children || this.state.value || this.props.placeholder;
        return (React.createElement("div", { role: "editable-label", ref: this.props.innerRef, className: editableLabelClasses, onClick: this.edit },
            React.createElement("div", { className: "gd-editable-label-inner", ref: this.root }, this.state.isEditing ? this.renderEditableLabelEdit() : displayValue)));
    };
    EditableLabelInner.defaultProps = {
        children: false,
        className: "",
        maxLength: 100000,
        maxRows: 1,
        onCancel: identity,
        onEditingStart: identity,
        onChange: identity,
        placeholder: "",
        scrollToEndOnEditingStart: true,
        textareaInOverlay: false,
        autofocus: false,
        isEditableLabelWidthBasedOnText: false,
    };
    return EditableLabelInner;
}(Component));
export { EditableLabelInner };
/**
 * @internal
 */
export var EditableLabel = React.forwardRef(function (props, ref) {
    return React.createElement(EditableLabelInner, __assign({}, props, { innerRef: ref }));
});
//# sourceMappingURL=EditableLabel.js.map