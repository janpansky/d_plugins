import { __spreadArrays } from "tslib";
// (C) 2022 GoodData Corporation
import { isResultTotalHeader } from "@gooddata/sdk-model";
import isEmpty from "lodash/isEmpty";
import flatMap from "lodash/flatMap";
import { dimensionLocalIdentifier } from "../../toBackend/afm/DimensionsConverter";
/**
 * Transform the grand total structure from Tiger API into a form acceptable by the SDK.
 * @param grandTotals - Grand total structure from Tiger API
 * @param definition - Original Execution definition from the SDK
 * @param dataHeaderItems - Headers for the main result structure from the Tiger API
 * @param transformDimensionHeaders - A function to transform grand total dimension headers into SDK compatible headers
 */
export function transformGrandTotalData(grandTotals, definition, dataHeaderItems, transformDimensionHeaders) {
    if (definition.dimensions.every(function (dim) { return isEmpty(dim.totals); })) {
        // SDK cannot work with explicit empty totals, undefined must be returned instead
        return undefined;
    }
    var grandTotalsData = definition.dimensions.map(function (_) { return []; });
    var dimensionIdxByLocalId = new Map(definition.dimensions.map(function (_, idx) { return [dimensionLocalIdentifier(idx), idx]; }));
    for (var _i = 0, grandTotals_1 = grandTotals; _i < grandTotals_1.length; _i++) {
        var grandTotal = grandTotals_1[_i];
        var totalDimensions = grandTotal.totalDimensions
            .map(function (dim) { return dimensionIdxByLocalId.get(dim); })
            .filter(function (dimIdx) { return dimIdx !== undefined; });
        var combinedHeaders = combineHeaders(transformDimensionHeaders(grandTotal.dimensionHeaders), dataHeaderItems, totalDimensions);
        var transformedTotals = transformGrandTotal(grandTotal, combinedHeaders, totalDimensions, definition);
        transformedTotals.forEach(function (total, totalIdx) {
            grandTotalsData[total.dimensionIdx][totalIdx] = total.data;
        });
    }
    return grandTotalsData;
}
/**
 * Fill in missing dimensions in grandTotalHeaderItems from dataHeaderItems.
 * Total dimensions in this case signify which dimensions we need to fill in.
 */
function combineHeaders(grandTotalHeaderItems, dataHeaderItems, totalDimensions) {
    var combinedHeaderItems = [];
    var grandTotalIdx = 0;
    dataHeaderItems.forEach(function (dimensionHeader, dimIdx) {
        if (totalDimensions.includes(dimIdx)) {
            combinedHeaderItems.push(dimensionHeader);
        }
        else {
            combinedHeaderItems.push(grandTotalHeaderItems[grandTotalIdx]);
            grandTotalIdx += 1;
        }
    });
    return combinedHeaderItems;
}
/**
 * SDK expects grand total data in an array with the lengths [dimensions][total types][values].
 * Tiger API returns an array of "Grand Totals", where each grand total has data in a multidimensional array
 * with the dimensions the same as the main result.
 * SDK supports only one-dimensional totals, so we will skip multidimensional totals to simplify the implementation.
 * This function takes the data from a grand total and by looking at the headers at each data value it assigns this
 * value to its place in the SDK format.
 */
function transformGrandTotal(grandTotal, headerItems, totalDimensions, definition) {
    var _a;
    if (totalDimensions.length !== 1) {
        // If the grand total belongs to multiple or zero dimensions it is either
        // a grand total from a >2D result or it is a total of totals,
        // neither of which can currently be handled
        return [];
    }
    // Tiger API returns dimensions whose headers are used in the total, while SDK wants the dimension which
    // is "totalled" - headers not used. Here we assume that there are only two dimensions in the definition, as we
    // need to find on which dimension the totals in this grand total result were defined.
    // If there were more than two dimensions, then a total definition on a single dimension would result
    // in >1 dimensions in `totalDimensions`, which we checked is not the case already.
    // TODO revisit when multidimensional totals are supported
    var dimensionIdx = definition.dimensions.findIndex(function (_, idx) { return idx !== totalDimensions[0]; });
    var totalDefinitions = (_a = definition.dimensions[dimensionIdx]) === null || _a === void 0 ? void 0 : _a.totals;
    if (totalDefinitions === undefined) {
        return [];
    }
    var transformedTotals = {};
    var resultData = grandTotal.data;
    /**
     * Iteratively walk through the data, get headers at each point and use them to assign data values to a total.
     */
    var walk = function (data, coordinates) {
        if (coordinates === void 0) { coordinates = []; }
        data.forEach(function (dataValue, idx) {
            var _a, _b;
            var position = __spreadArrays(coordinates, [idx]);
            if (Array.isArray(dataValue)) {
                walk(dataValue, position);
            }
            else {
                // Get headers at the current position, but skip total dimensions as they may have subtotals
                var headers = getHeadersAtPosition(headerItems, position, totalDimensions);
                var totalType = (_a = headers.find(isResultTotalHeader)) === null || _a === void 0 ? void 0 : _a.totalHeaderItem.type.toLowerCase();
                if (totalType === undefined) {
                    // Cannot assign to a total without a total header
                    return;
                }
                var total = (transformedTotals[totalType] = (_b = transformedTotals[totalType]) !== null && _b !== void 0 ? _b : []);
                total.push(dataValue);
            }
        });
    };
    walk(resultData);
    var sortedTotals = Object.keys(transformedTotals)
        .map(function (totalType) {
        var data = transformedTotals[totalType];
        return {
            data: data,
            defIdx: totalDefinitions.findIndex(function (def) { return def.type === totalType; }),
        };
    })
        .filter(function (total) { return total.defIdx !== -1; })
        .sort(function (totalA, totalB) { return totalA.defIdx - totalB.defIdx; });
    return sortedTotals.map(function (total) {
        return {
            dimensionIdx: dimensionIdx,
            data: total.data,
        };
    });
}
function getHeadersAtPosition(headerItems, position, skipDimensions) {
    if (skipDimensions === void 0) { skipDimensions = []; }
    return flatMap(position, function (coord, dimIdx) {
        if (skipDimensions.includes(dimIdx)) {
            return [];
        }
        // header groups in dimension `dimIdx`
        var headerGroups = headerItems[dimIdx];
        // get header at coordinate `coord` from each group
        return headerGroups.map(function (group) { return group[coord]; });
    });
}
//# sourceMappingURL=GrandTotalsConverter.js.map