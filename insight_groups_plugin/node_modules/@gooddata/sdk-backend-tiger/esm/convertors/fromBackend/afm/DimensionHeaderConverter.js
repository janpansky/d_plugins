import { __assign } from "tslib";
// (C) 2022 GoodData Corporation
import { isAttributeDescriptor, isMeasureGroupDescriptor, } from "@gooddata/sdk-model";
import { isResultAttributeHeader, isResultMeasureHeader, isResultTotalHeader, JsonApiAttributeOutAttributesGranularityEnum, } from "@gooddata/api-client-tiger";
import { createDateValueFormatter } from "../dateFormatting/dateValueFormatter";
import { toSdkGranularity } from "../dateGranularityConversions";
var supportedSuffixes = Object.keys(JsonApiAttributeOutAttributesGranularityEnum)
    .filter(function (item) { return isNaN(Number(item)); })
    .map(function (key) {
    return JsonApiAttributeOutAttributesGranularityEnum[key];
});
function getDateFormatProps(header) {
    if (!isAttributeDescriptor(header) ||
        !header.attributeHeader.granularity ||
        !supportedSuffixes.includes(header.attributeHeader.granularity) ||
        !header.attributeHeader.format) {
        return undefined;
    }
    var _a = header.attributeHeader, granularity = _a.granularity, format = _a.format;
    return {
        granularity: toSdkGranularity(granularity),
        format: {
            locale: format.locale,
            pattern: format.pattern,
        },
    };
}
function getMeasuresFromDimensions(dimensions) {
    for (var _i = 0, dimensions_1 = dimensions; _i < dimensions_1.length; _i++) {
        var dim = dimensions_1[_i];
        var measureGroup = dim.headers.find(isMeasureGroupDescriptor);
        if (measureGroup) {
            return measureGroup.measureGroupHeader.items;
        }
    }
    return [];
}
export function getTransformDimensionHeaders(dimensions, dateFormatter) {
    var measureDescriptors = getMeasuresFromDimensions(dimensions);
    var dateValueFormatter = createDateValueFormatter(dateFormatter);
    return function (dimensionHeaders) {
        return dimensionHeaders.map(function (dimensionHeader, dimensionIndex) {
            return dimensionHeader.headerGroups.map(function (headerGroup, headerGroupIndex) {
                var dateFormatProps = getDateFormatProps(dimensions[dimensionIndex].headers[headerGroupIndex]);
                return headerGroup.headers.map(function (header) {
                    if (isResultAttributeHeader(header)) {
                        return attributeMeasureItem(header, dateFormatProps, dateValueFormatter);
                    }
                    if (isResultMeasureHeader(header)) {
                        return measureHeaderItem(header, measureDescriptors);
                    }
                    if (isResultTotalHeader(header)) {
                        return totalHeaderItem(header);
                    }
                    // This code should never be reachable
                    throw new Error("Unexpected type of ResultHeader: " + header);
                });
            });
        });
    };
}
function attributeMeasureItem(header, dateFormatProps, dateValueFormatter) {
    var formattedNameObj = dateFormatProps
        ? {
            formattedName: dateValueFormatter(header.attributeHeader.labelValue, dateFormatProps.granularity, dateFormatProps.format.locale, dateFormatProps.format.pattern),
        }
        : {};
    return {
        attributeHeaderItem: __assign({ uri: header.attributeHeader.primaryLabelValue, name: header.attributeHeader.labelValue }, formattedNameObj),
    };
}
function measureHeaderItem(header, measureDescriptors) {
    var _a;
    /*
     * Funny stuff #1 - Tiger sends just the measure index in the measure headers. This is the index of the
     * measure descriptor within the measure group. The code looks up the measure descriptor so that
     * it can then fill in the `name` to the one in the descriptor
     */
    var measureIndex = header.measureHeader.measureIndex;
    return {
        measureHeaderItem: {
            name: (_a = measureDescriptors[measureIndex]) === null || _a === void 0 ? void 0 : _a.measureHeaderItem.name,
            order: measureIndex,
        },
    };
}
function totalHeaderItem(header) {
    return {
        totalHeaderItem: {
            type: header.totalHeader.function,
            name: header.totalHeader.function.toLowerCase(),
        },
    };
}
//# sourceMappingURL=DimensionHeaderConverter.js.map