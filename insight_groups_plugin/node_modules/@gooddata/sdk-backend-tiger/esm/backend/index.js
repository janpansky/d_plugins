import { __assign, __awaiter, __generator } from "tslib";
import invariant from "ts-invariant";
import { NotAuthenticated, isNotAuthenticated, isContractExpired, } from "@gooddata/sdk-backend-spi";
import { newAxios, tigerClientFactory } from "@gooddata/api-client-tiger";
import isEmpty from "lodash/isEmpty";
import isError from "lodash/isError";
import isString from "lodash/isString";
import inRange from "lodash/inRange";
import identity from "lodash/identity";
import omit from "lodash/omit";
import { convertApiError } from "../utils/errorHandling";
import { TigerWorkspace } from "./workspace";
import { TigerWorkspaceQueryFactory } from "./workspaces";
import { TigerUserService } from "./user";
import { AuthProviderCallGuard, AnonymousAuthProvider, } from "@gooddata/sdk-backend-base";
import { defaultDateFormatter } from "../convertors/fromBackend/dateFormatting/defaultDateFormatter";
import { TigerOrganization, TigerOrganizations } from "./organization";
import packageJson from "../../package.json";
import { buildTigerSpecificFunctions } from "./tigerSpecificFunctions";
import { TigerEntitlements } from "./entitlements";
var CAPABILITIES = {
    hasTypeScopedIdentifiers: true,
    canCalculateGrandTotals: true,
    canCalculateSubTotals: true,
    canCalculateNativeTotals: false,
    canCalculateTotals: true,
    canExportCsv: true,
    canExportXlsx: true,
    canSortData: false,
    canTransformExistingResult: false,
    canWorkspaceManagerSeeEverySharedObject: true,
    maxDimensions: 2,
    supportsElementUris: false,
    supportsObjectUris: false,
    supportsCsvUploader: false,
    supportsRankingFilter: true,
    supportsRankingFilterWithMeasureValueFilter: false,
    supportsElementsQueryParentFiltering: false,
    supportsKpiWidget: false,
    supportsWidgetEntity: false,
    supportsHyperlinkAttributeLabels: true,
    supportsGenericDateAttributeElements: true,
    supportsExplain: true,
    supportsAccessControl: true,
    usesStrictAccessControl: true,
    supportsOwners: false,
    allowsInconsistentRelations: true,
    supportsTimeGranularities: true,
    supportsHierarchicalWorkspaces: true,
    supportsCustomColorPalettes: true,
    supportsOrganizationSettings: true,
    supportsInlineMeasures: true,
    supportsBootstrapResource: false,
    supportsMetadataObjectLocking: false,
    supportsGranularAccessControl: true,
    supportsEveryoneUserGroupForAccessControl: false,
    supportsNonProductionDatasets: false,
    supportsShowAllAttributeValues: true,
    supportsSeparateLatitudeLongitudeLabels: true,
};
/**
 * An implementation of analytical backend for GoodData CloudNative (codename tiger).
 */
var TigerBackend = /** @class */ (function () {
    function TigerBackend(config, implConfig, telemetry, authProvider) {
        var _this = this;
        if (config === void 0) { config = {}; }
        if (implConfig === void 0) { implConfig = {}; }
        if (telemetry === void 0) { telemetry = {}; }
        var _a, _b, _c;
        this.capabilities = CAPABILITIES;
        this.isAuthenticated = function () { return __awaiter(_this, void 0, void 0, function () {
            var err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.authProvider.getCurrentPrincipal({ client: this.client, backend: this })];
                    case 1: 
                    // the return await is crucial here so that we also catch the async errors
                    return [2 /*return*/, _a.sent()];
                    case 2:
                        err_1 = _a.sent();
                        if (isNotAuthenticatedResponse(err_1) || isNotAuthenticated(err_1)) {
                            return [2 /*return*/, null];
                        }
                        throw err_1;
                    case 3: return [2 /*return*/];
                }
            });
        }); };
        this.authenticate = function (force) { return __awaiter(_this, void 0, void 0, function () {
            var err_2;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!force) {
                            return [2 /*return*/, this.authApiCall(function (client) { return __awaiter(_this, void 0, void 0, function () {
                                    var principal;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, this.authProvider.getCurrentPrincipal({ client: client, backend: this })];
                                            case 1:
                                                principal = _a.sent();
                                                invariant(principal, "Principal must be defined");
                                                return [2 /*return*/, principal];
                                        }
                                    });
                                }); })];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.triggerAuthentication(true)];
                    case 2: 
                    // the return await is crucial here so that we also catch the async errors
                    return [2 /*return*/, _a.sent()];
                    case 3:
                        err_2 = _a.sent();
                        invariant(isError(err_2)); // if this bombs, the code in the try block threw something strange
                        throw this.handleAnalyticalBackendError(convertApiError(err_2));
                    case 4: return [2 /*return*/];
                }
            });
        }); };
        /**
         * Perform API call that requires authentication. The call will be decorated with error handling
         * such that not authenticated errors will trigger authentication flow AND other errors will be
         * converted using the provided converter and throw.
         *
         * @param call - a call which requires an authenticated session
         * @param errorConverter - converter from rest client errors to analytical backend errors
         */
        this.authApiCall = function (call, errorConverter) {
            if (errorConverter === void 0) { errorConverter = convertApiError; }
            return __awaiter(_this, void 0, void 0, function () {
                var _a, _b, err_3, _c, _d, err2_1;
                return __generator(this, function (_e) {
                    switch (_e.label) {
                        case 0:
                            _e.trys.push([0, 3, , 10]);
                            _a = call;
                            _b = [this.client];
                            return [4 /*yield*/, this.getAsyncCallContext()];
                        case 1: return [4 /*yield*/, _a.apply(void 0, _b.concat([_e.sent()]))];
                        case 2: 
                        // the return await is crucial here so that we also catch the async errors
                        return [2 /*return*/, _e.sent()];
                        case 3:
                            err_3 = _e.sent();
                            invariant(isError(err_3)); // if this bombs, the code in the try block threw something strange
                            // if we receive some other error than missing auth, we fail fast: no need to try the auth
                            // one more time, since it was not the problem in the first place
                            if (!isNotAuthenticatedResponse(err_3)) {
                                throw this.handleAnalyticalBackendError(errorConverter(err_3));
                            }
                            _e.label = 4;
                        case 4:
                            _e.trys.push([4, 8, , 9]);
                            return [4 /*yield*/, this.triggerAuthentication()];
                        case 5:
                            _e.sent();
                            _c = call;
                            _d = [this.client];
                            return [4 /*yield*/, this.getAsyncCallContext()];
                        case 6: return [4 /*yield*/, _c.apply(void 0, _d.concat([_e.sent()]))];
                        case 7: 
                        // the return await is crucial here so that we also catch the async errors
                        return [2 /*return*/, _e.sent()];
                        case 8:
                            err2_1 = _e.sent();
                            invariant(isError(err2_1)); // if this bombs, the code in the try block threw something strange
                            throw this.handleAnalyticalBackendError(errorConverter(err2_1));
                        case 9: return [3 /*break*/, 10];
                        case 10: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Triggers relevant handler if the provided error is an instance of
         * {@link @gooddata/sdk-backend-spi#NotAuthenticated} or {@link @gooddata/sdk-backend-spi#ContractExpired}.
         *
         * @param err - error to observe and trigger handler for
         * @returns the original error to facilitate re-throwing
         */
        this.handleAnalyticalBackendError = function (err) {
            var _a, _b, _c, _d;
            if (isNotAuthenticated(err)) {
                (_b = (_a = _this.authProvider).onNotAuthenticated) === null || _b === void 0 ? void 0 : _b.call(_a, { client: _this.client, backend: _this }, err);
            }
            else if (isContractExpired(err)) {
                (_d = (_c = _this.implConfig).onContractExpired) === null || _d === void 0 ? void 0 : _d.call(_c, err.message);
            }
            return err;
        };
        this.getAuthenticationContext = function () {
            return { client: _this.client, backend: _this };
        };
        this.getAsyncCallContext = function () { return __awaiter(_this, void 0, void 0, function () {
            var getPrincipal;
            var _this = this;
            return __generator(this, function (_a) {
                getPrincipal = function () { return __awaiter(_this, void 0, void 0, function () {
                    var principal;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!this.authProvider) {
                                    throw new NotAuthenticated("Cannot obtain principal without an authProvider.");
                                }
                                return [4 /*yield*/, this.authProvider.getCurrentPrincipal({
                                        client: this.client,
                                        backend: this,
                                    })];
                            case 1:
                                principal = _a.sent();
                                return [2 /*return*/, principal !== null && principal !== void 0 ? principal : this.authProvider.authenticate(this.getAuthenticationContext())];
                        }
                    });
                }); };
                return [2 /*return*/, {
                        getPrincipal: getPrincipal,
                    }];
            });
        }); };
        this.triggerAuthentication = function (reset) {
            if (reset === void 0) { reset = false; }
            if (!_this.authProvider) {
                return Promise.reject(new NotAuthenticated("Backend is not set up with authentication provider."));
            }
            if (reset) {
                _this.authProvider.reset();
            }
            return _this.authProvider.authenticate({ client: _this.client, backend: _this });
        };
        this.config = config;
        this.implConfig = implConfig;
        this.telemetry = telemetry;
        this.authProvider = authProvider || new AnonymousAuthProvider();
        this.dateFormatter = (_a = implConfig.dateFormatter) !== null && _a !== void 0 ? _a : defaultDateFormatter;
        var axios = createAxios(this.config, this.implConfig, this.telemetry);
        interceptBackendErrorsToConsole(axios);
        this.client = tigerClientFactory(axios);
        (_c = (_b = this.authProvider).initializeClient) === null || _c === void 0 ? void 0 : _c.call(_b, this.client);
        if (this.implConfig.onTigerSpecificFunctionsReady) {
            var specificFunctions = buildTigerSpecificFunctions(this, this.authApiCall);
            this.implConfig.onTigerSpecificFunctionsReady(specificFunctions);
        }
    }
    TigerBackend.prototype.onHostname = function (hostname) {
        return new TigerBackend(__assign(__assign({}, this.config), { hostname: hostname }), this.implConfig, this.telemetry);
    };
    TigerBackend.prototype.withTelemetry = function (componentName, props) {
        return new TigerBackend(this.config, this.implConfig, { componentName: componentName, props: Object.keys(props) }, this.authProvider);
    };
    TigerBackend.prototype.withAuthentication = function (provider) {
        var guardedAuthProvider = new AuthProviderCallGuard(provider);
        return new TigerBackend(this.config, this.implConfig, this.telemetry, guardedAuthProvider);
    };
    TigerBackend.prototype.deauthenticate = function () {
        if (!this.authProvider) {
            throw new NotAuthenticated("Backend is not set up with authentication provider.");
        }
        return this.authProvider.deauthenticate(this.getAuthenticationContext());
    };
    TigerBackend.prototype.organization = function (organizationId) {
        return new TigerOrganization(this.authApiCall, organizationId);
    };
    TigerBackend.prototype.organizations = function () {
        return new TigerOrganizations(this.authApiCall);
    };
    TigerBackend.prototype.entitlements = function () {
        return new TigerEntitlements(this.authApiCall);
    };
    TigerBackend.prototype.currentUser = function () {
        return new TigerUserService(this.authApiCall);
    };
    TigerBackend.prototype.workspace = function (id) {
        invariant(isString(id), "Invalid workspaceId, expected a string, got: " + id);
        return new TigerWorkspace(this.authApiCall, id, this.dateFormatter);
    };
    TigerBackend.prototype.workspaces = function () {
        return new TigerWorkspaceQueryFactory(this.authApiCall, this.dateFormatter);
    };
    return TigerBackend;
}());
export { TigerBackend };
function createAxios(config, implConfig, telemetry) {
    var baseUrl = config.hostname ? config.hostname : undefined;
    var headers = createHeaders(implConfig, telemetry);
    return newAxios(baseUrl, headers);
}
function interceptBackendErrorsToConsole(client) {
    client.interceptors.response.use(identity, function (error) {
        var response = error.response;
        // If there is no response object (for example for blocked requests), print the whole error.
        if (!response) {
            console.error("Tiger backend threw an error:", error);
        }
        // Else if the response is an object (JSON parsed by axios) and there is a problem, then log error
        // into console for easier diagnostics.
        else if (inRange(response.status, 400, 600) && typeof response.data === "object") {
            // Title is redundant (Bad Request)
            var details = omit(response.data, ["title"]);
            console.error("Tiger backend threw an error:", details);
        }
        return Promise.reject(error);
    });
    return client;
}
function createHeaders(implConfig, telemetry) {
    var headers = {
        "X-GDC-JS-PACKAGE": packageJson.name,
        "X-GDC-JS-PACKAGE-VERSION": packageJson.version,
    };
    if (telemetry.componentName) {
        headers["X-GDC-JS-SDK-COMP"] = telemetry.componentName;
    }
    if (telemetry.props && !isEmpty(telemetry.props)) {
        headers["X-GDC-JS-SDK-COMP-PROPS"] = telemetry.props.join(",");
    }
    if (implConfig.packageName && implConfig.packageVersion) {
        headers["X-GDC-JS-PACKAGE"] = implConfig.packageName;
        headers["X-GDC-JS-PACKAGE-VERSION"] = implConfig.packageVersion;
    }
    return headers;
}
function isNotAuthenticatedResponse(err) {
    var _a;
    return ((_a = err === null || err === void 0 ? void 0 : err.response) === null || _a === void 0 ? void 0 : _a.status) === 401;
}
//# sourceMappingURL=index.js.map