import { GdcMetadata } from "../meta/GdcMetadata";
import { GdcExtendedDateFilters } from "../extendedDateFilters/GdcExtendedDateFilters";
/**
 * @public
 */
export declare namespace GdcKpi {
    interface IKPI {
        meta: GdcMetadata.IObjectMeta;
        content: IKpiContentWithoutComparison | IKpiContentWithComparison;
    }
    interface IWrappedKPI {
        kpi: IKPI;
    }
    interface IKpiContentBase {
        metric: string;
        ignoreDashboardFilters: Array<GdcExtendedDateFilters.IDateFilterReference | GdcExtendedDateFilters.IAttributeFilterReference>;
        drillTo?: IKpiProjectDashboardLink;
        dateDimension?: string;
        dateDataSet?: string;
        configuration?: IKpiConfiguration;
    }
    interface IKpiConfiguration {
        description?: IKpiDescriptionConfiguration;
    }
    interface IKpiDescriptionConfiguration {
        /**
         * Whether description should be visible or not
         */
        visible: boolean;
        /**
         * Whether description should be used from kpi or inherited from its metric
         */
        source: KpiDescriptionSourceType;
    }
    type KpiDescriptionSourceType = "kpi" | "metric";
    interface IKpiContentWithComparison extends IKpiContentBase {
        comparisonType: IKpiComparisonTypeComparison;
        comparisonDirection: IKpiComparisonDirection;
    }
    interface IKpiContentWithoutComparison extends IKpiContentBase {
        comparisonType: IKpiComparisonTypeNoComparison;
    }
    function isKpiContentWithoutComparison(obj: unknown): obj is IKpiContentWithoutComparison;
    interface IKpiProjectDashboardLink {
        projectDashboard: string;
        projectDashboardTab: string;
    }
    type IKpiComparisonTypeNoComparison = "none";
    type IKpiComparisonTypeComparison = "previousPeriod" | "lastYear";
    type IKpiComparisonDirection = "growIsGood" | "growIsBad";
    function isKpi(obj: unknown): obj is IKPI;
    function isWrappedKpi(obj: unknown): obj is IWrappedKPI;
}
//# sourceMappingURL=GdcKpi.d.ts.map