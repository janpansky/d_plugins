import { __read, __spread } from "tslib";
// (C) 2019-2022 GoodData Corporation
import { isAttribute, isMeasure, MeasureGroupIdentifier, newDimension, newTwoDimensional, } from "@gooddata/sdk-model";
import compact from "lodash/compact";
import isEmpty from "lodash/isEmpty";
import invariant from "ts-invariant";
/**
 * When caller desires just data series and no slicing, create a single-dim result.
 */
function seriesOnlyDim(seriesBy) {
    return [
        newDimension(compact(__spread(seriesBy.filter(isAttribute), [
            // only include MeasureGroupIdentifier if there are some measures, otherwise the execution will always fail on the backend
            seriesBy.some(isMeasure) && MeasureGroupIdentifier,
        ]))),
    ];
}
/**
 * When caller desires data series to be sliced further by some attributes (and perhaps with totals as well)
 * then create two-dim result resembling a pivot table:
 *
 * -  slices are in rows (first dim)
 * -  measures & scoping attributes will be in columns (second dim)
 */
function seriesAndSlicesDim(seriesBy, slices, totals) {
    return newTwoDimensional(__spread(slices, totals), compact(__spread(seriesBy.filter(isAttribute), [
        // only include MeasureGroupIdentifier if there are some measures, otherwise the execution will always fail on the backend
        seriesBy.some(isMeasure) && MeasureGroupIdentifier,
    ])));
}
/**
 * Given execute props, this will prepare execution to send to backend.
 *
 * @param options - create execution options
 * @internal
 */
export function createExecution(options) {
    var _a, _b;
    var backend = options.backend, workspace = options.workspace, seriesBy = options.seriesBy, _c = options.slicesBy, slicesBy = _c === void 0 ? [] : _c, _d = options.filters, filters = _d === void 0 ? [] : _d, _e = options.sortBy, sortBy = _e === void 0 ? [] : _e, _f = options.totals, totals = _f === void 0 ? [] : _f, _g = options.componentName, componentName = _g === void 0 ? "Execution" : _g;
    invariant(backend && workspace, "backend and workspace must be either specified explicitly or be provided by context");
    var dimensions = isEmpty(slicesBy)
        ? seriesOnlyDim(seriesBy)
        : seriesAndSlicesDim(seriesBy, slicesBy, totals);
    return (_a = (_b = backend
        .withTelemetry(componentName, options)
        .workspace(workspace)
        .execution()
        .forItems(seriesBy.concat(slicesBy), filters))
        .withSorting.apply(_b, __spread(sortBy)))
        .withDimensions.apply(_a, __spread(dimensions));
}
//# sourceMappingURL=createExecution.js.map