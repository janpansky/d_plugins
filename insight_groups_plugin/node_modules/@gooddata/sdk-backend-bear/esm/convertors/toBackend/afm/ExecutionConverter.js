import { __assign } from "tslib";
// (C) 2007-2022 GoodData Corporation
import isEmpty from "lodash/isEmpty";
import { convertFilters } from "./FilterConverter";
import { convertMeasure } from "./MeasureConverter";
import { dimensionsFindItem, dimensionTotals, isAttributeLocator, isMeasureSort, MeasureGroupIdentifier, totalIsNative, } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
import { toBearRef } from "../ObjRefConverter";
function convertAttribute(attribute, idx) {
    var alias = attribute.attribute.alias;
    var aliasProp = alias ? { alias: alias } : {};
    return __assign({ displayForm: toBearRef(attribute.attribute.displayForm), localIdentifier: attribute.attribute.localIdentifier || "a" + (idx + 1) }, aliasProp);
}
function convertAFM(def) {
    var attributes = def.attributes.map(convertAttribute);
    var attrProp = attributes.length ? { attributes: attributes } : {};
    var measures = def.measures.map(convertMeasure);
    var measuresProp = measures.length ? { measures: measures } : {};
    var filters = convertFilters(def.filters);
    var filtersProp = filters.length ? { filters: filters } : {};
    var nativeTotals = convertNativeTotals(def);
    var nativeTotalsProp = nativeTotals.length ? { nativeTotals: nativeTotals } : {};
    return __assign(__assign(__assign(__assign({}, measuresProp), attrProp), filtersProp), nativeTotalsProp);
}
function convertNativeTotals(def) {
    // first find all native totals defined across dimensions
    var nativeTotals = def.dimensions
        .map(dimensionTotals)
        .reduce(function (acc, totals) {
        acc.push.apply(acc, totals);
        return acc;
    }, [])
        .filter(totalIsNative);
    return nativeTotals.map(function (t) {
        // then for each native total, look across buckets (if any) for an attribute that is specified in
        // the total definition
        var attributeInDims = dimensionsFindItem(def.dimensions, t.attributeIdentifier);
        if (!attributeInDims.length) {
            throw new Error("Native total references attribute that is not in any dimension: " + t.attributeIdentifier);
        }
        else if (attributeInDims.length > 1) {
            throw new Error("Native total references attribute that is in multiple dimensions: " + t.attributeIdentifier);
        }
        var attributeDim = attributeInDims[0];
        // now, knowing the dimension and index of the attribute.. roll up all attributes that are before it
        var rollupAttributes = attributeDim.dim.itemIdentifiers
            .slice(0, attributeDim.itemIdx)
            .filter(function (id) { return id !== MeasureGroupIdentifier; });
        // and create native total such, that it rolls up all those attributes
        return {
            measureIdentifier: t.measureIdentifier,
            attributeIdentifiers: rollupAttributes,
        };
    });
}
function convertTotals(totals) {
    if (totals === void 0) { totals = []; }
    return totals.map(function (t) {
        return {
            type: t.type,
            attributeIdentifier: t.attributeIdentifier,
            measureIdentifier: t.measureIdentifier,
        };
    });
}
function convertDimensions(def) {
    return def.dimensions.map(function (dim) {
        var totals = convertTotals(dim.totals);
        var totalsProp = !isEmpty(totals) ? { totals: totals } : {};
        return __assign({ itemIdentifiers: dim.itemIdentifiers }, totalsProp);
    });
}
function assertNoNullsInSortBy(sortBy) {
    sortBy.forEach(function (item) {
        if (isMeasureSort(item)) {
            item.measureSortItem.locators.forEach(function (locator) {
                if (isAttributeLocator(locator)) {
                    invariant(locator.attributeLocatorItem.element !== null, "Nulls are not supported as attribute element values or uris on bear");
                }
            });
        }
    });
}
export function convertResultSpec(def) {
    var _a;
    assertNoNullsInSortBy((_a = def.sortBy) !== null && _a !== void 0 ? _a : []);
    var sortsProp = !isEmpty(def.sortBy)
        ? { sorts: def.sortBy } // checked above, the cast is safe
        : {};
    var dims = convertDimensions(def);
    var dimsProp = !isEmpty(dims) ? { dimensions: dims } : {};
    return __assign(__assign({}, sortsProp), dimsProp);
}
// This has to be const function, otherwise api-extractor breaks...
/**
 * Converts execution definition to AFM Execution
 *
 * @param def - execution definition
 * @returns AFM Execution
 *
 * @internal
 */
export var toAfmExecution = function (def) {
    return {
        execution: {
            afm: convertAFM(def),
            resultSpec: convertResultSpec(def),
        },
    };
};
//# sourceMappingURL=ExecutionConverter.js.map