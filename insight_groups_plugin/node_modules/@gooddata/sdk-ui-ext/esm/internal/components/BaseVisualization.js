import { __awaiter, __extends, __generator } from "tslib";
import { insightProperties, visClassUrl, } from "@gooddata/sdk-model";
import React from "react";
import { render } from "react-dom";
import { v4 as uuidv4 } from "uuid";
import { ConfigPanelClassName, } from "../interfaces/Visualization";
import { FullVisualizationCatalog } from "./VisualizationCatalog";
import isEmpty from "lodash/isEmpty";
import isEqual from "lodash/isEqual";
import noop from "lodash/noop";
import omit from "lodash/omit";
var BaseVisualization = /** @class */ (function (_super) {
    __extends(BaseVisualization, _super);
    function BaseVisualization(props) {
        var _this = _super.call(this, props) || this;
        _this.visElementId = uuidv4();
        _this.executionFactory = props.backend.workspace(props.projectId).execution();
        return _this;
    }
    BaseVisualization.prototype.componentWillUnmount = function () {
        this.visualization.unmount();
    };
    BaseVisualization.prototype.UNSAFE_componentWillReceiveProps = function (nextProps) {
        var newDerivedBucketItemsChanged = !isEmpty(nextProps.newDerivedBucketItems) &&
            !isEqual(nextProps.newDerivedBucketItems, this.props.newDerivedBucketItems);
        if (newDerivedBucketItemsChanged) {
            this.triggerPlaceNewDerivedBucketItems(nextProps);
            return;
        }
        var visualizationClassChanged = !isEqual(nextProps.visualizationClass, this.props.visualizationClass);
        var referencePointChanged = BaseVisualization.bucketReferencePointHasChanged(this.props.referencePoint, nextProps.referencePoint);
        var propertiesControlsChanged = BaseVisualization.propertiesControlsHasChanged(this.props.referencePoint, nextProps.referencePoint);
        if (visualizationClassChanged) {
            this.visElementId = uuidv4();
            this.setupVisualization(nextProps);
        }
        if (referencePointChanged || visualizationClassChanged) {
            this.triggerExtendedReferencePointChanged(nextProps, 
            // only pass current props if the visualization class is the same (see getExtendedReferencePoint JSDoc)
            visualizationClassChanged ? undefined : this.props);
            // Some of the properties eg. stacking of measures, dual axes influence sorting
        }
        else if (propertiesControlsChanged) {
            this.triggerPropertiesChanged(nextProps, this.props);
        }
    };
    BaseVisualization.prototype.componentDidMount = function () {
        this.setupVisualization(this.props);
        this.updateVisualization();
        this.triggerExtendedReferencePointChanged(this.props);
    };
    BaseVisualization.prototype.componentDidUpdate = function () {
        if (this.props.isMdObjectValid) {
            this.updateVisualization();
        }
    };
    BaseVisualization.prototype.render = function () {
        return React.createElement("div", { key: this.visElementId, style: { height: "100%" }, className: this.getClassName() });
    };
    BaseVisualization.prototype.getVisElementClassName = function () {
        return "gd-vis-" + this.visElementId;
    };
    BaseVisualization.prototype.getClassName = function () {
        return "gd-base-visualization " + this.getVisElementClassName();
    };
    BaseVisualization.prototype.setupVisualization = function (props) {
        var visualizationClass = props.visualizationClass, environment = props.environment, locale = props.locale, featureFlags = props.featureFlags, projectId = props.projectId, configPanelClassName = props.configPanelClassName, renderer = props.renderer;
        if (this.visualization) {
            this.visualization.unmount();
        }
        var visUri = visClassUrl(visualizationClass);
        var visFactory;
        try {
            visFactory = this.props.visualizationCatalog.forUri(visUri).getFactory();
        }
        catch (e) {
            // eslint-disable-next-line no-console
            console.error("Error: unsupported visualization type - " + visUri);
        }
        if (visFactory) {
            var constructorParams = {
                projectId: projectId,
                locale: locale,
                environment: environment,
                backend: props.backend,
                element: "." + this.getVisElementClassName(),
                configPanelElement: "." + configPanelClassName,
                callbacks: {
                    afterRender: props.afterRender,
                    onLoadingChanged: props.onLoadingChanged,
                    onError: props.onError,
                    onExportReady: props.onExportReady,
                    pushData: props.pushData,
                    onDrill: props.onDrill,
                },
                featureFlags: featureFlags,
                visualizationProperties: insightProperties(props.insight),
                renderFun: renderer,
            };
            this.visualization = visFactory(constructorParams);
        }
    };
    BaseVisualization.prototype.updateVisualization = function () {
        if (!this.visualization) {
            return;
        }
        this.visualization.update(this.getVisualizationProps(), this.props.insight, this.props.insightPropertiesMeta, this.executionFactory);
    };
    BaseVisualization.prototype.triggerPlaceNewDerivedBucketItems = function (props) {
        var newDerivedBucketItems = props.newDerivedBucketItems, referencePoint = props.referencePoint, onNewDerivedBucketItemsPlaced = props.onNewDerivedBucketItemsPlaced;
        if (this.visualization && referencePoint && newDerivedBucketItems && onNewDerivedBucketItemsPlaced) {
            this.visualization
                .addNewDerivedBucketItems(referencePoint, newDerivedBucketItems)
                .then(onNewDerivedBucketItemsPlaced);
        }
    };
    BaseVisualization.prototype.triggerExtendedReferencePointChanged = function (newProps, currentProps) {
        var _this = this;
        var newReferencePoint = newProps.referencePoint, onExtendedReferencePointChanged = newProps.onExtendedReferencePointChanged;
        if (this.visualization && newReferencePoint && onExtendedReferencePointChanged) {
            this.visualization
                .getExtendedReferencePoint(newReferencePoint, currentProps === null || currentProps === void 0 ? void 0 : currentProps.referencePoint)
                .then(function (extendedReferencePoint) { return __awaiter(_this, void 0, void 0, function () {
                var sortConfig;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.visualization.getSortConfig(extendedReferencePoint)];
                        case 1:
                            sortConfig = _a.sent();
                            // new sort config needs to be sent together with new reference point to avoid double executions with old invalid sort until new one arrives by its own handler
                            onExtendedReferencePointChanged(extendedReferencePoint, sortConfig);
                            return [2 /*return*/];
                    }
                });
            }); });
        }
    };
    BaseVisualization.prototype.triggerPropertiesChanged = function (newProps, currentProps) {
        var _this = this;
        var newReferencePoint = newProps.referencePoint, onSortingChanged = newProps.onSortingChanged;
        // Some of the properties eg. stacking of measures, dual axes influence sorting
        if (this.visualization && newReferencePoint && onSortingChanged) {
            this.visualization
                .getExtendedReferencePoint(newReferencePoint, currentProps === null || currentProps === void 0 ? void 0 : currentProps.referencePoint)
                .then(function (extendedRefPoint) {
                _this.visualization.getSortConfig(extendedRefPoint).then(onSortingChanged);
            });
        }
    };
    BaseVisualization.bucketReferencePointHasChanged = function (currentReferencePoint, nextReferencePoint) {
        return !isEqual(omit(currentReferencePoint, ["properties", "availableSorts"]), omit(nextReferencePoint, ["properties", "availableSorts"]));
    };
    BaseVisualization.propertiesControlsHasChanged = function (currentReferencePoint, nextReferencePoint) {
        var _a, _b;
        return !isEqual((_a = currentReferencePoint === null || currentReferencePoint === void 0 ? void 0 : currentReferencePoint.properties) === null || _a === void 0 ? void 0 : _a.controls, (_b = nextReferencePoint === null || nextReferencePoint === void 0 ? void 0 : nextReferencePoint.properties) === null || _b === void 0 ? void 0 : _b.controls);
    };
    BaseVisualization.prototype.getVisualizationProps = function () {
        return {
            locale: this.props.locale,
            dateFormat: this.props.dateFormat,
            dimensions: {
                width: this.props.width,
                height: this.props.height,
            },
            custom: {
                drillableItems: this.props.drillableItems,
                totalsEditAllowed: this.props.totalsEditAllowed,
            },
            config: this.props.config,
            theme: this.props.theme,
            executionConfig: this.props.executionConfig,
        };
    };
    BaseVisualization.prototype.getInsightWithDrillDownApplied = function (sourceVisualization, drillDownContext) {
        var _a;
        return this.visualization.getInsightWithDrillDownApplied(sourceVisualization, drillDownContext, (_a = this.props.backend.capabilities.supportsElementUris) !== null && _a !== void 0 ? _a : true);
    };
    BaseVisualization.prototype.getExecution = function () {
        if (!this.visualization) {
            this.setupVisualization(this.props);
        }
        return this.visualization.getExecution(this.getVisualizationProps(), this.props.insight, this.executionFactory);
    };
    BaseVisualization.defaultProps = {
        visualizationCatalog: FullVisualizationCatalog,
        newDerivedBucketItems: [],
        referencePoint: null,
        onExtendedReferencePointChanged: noop,
        onNewDerivedBucketItemsPlaced: noop,
        isMdObjectValid: true,
        configPanelClassName: ConfigPanelClassName,
        featureFlags: {},
        renderer: render,
    };
    return BaseVisualization;
}(React.PureComponent));
export { BaseVisualization };
//# sourceMappingURL=BaseVisualization.js.map