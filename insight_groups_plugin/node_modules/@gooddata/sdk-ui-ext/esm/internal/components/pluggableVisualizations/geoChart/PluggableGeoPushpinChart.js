import { __assign, __extends, __spreadArrays } from "tslib";
// (C) 2019-2022 GoodData Corporation
import React from "react";
import { EmptyAfmSdkError, } from "../../../interfaces/Visualization";
import { PluggableBaseChart } from "../baseChart/PluggableBaseChart";
import { ATTRIBUTE, BUCKETS, METRIC } from "../../../constants/bucket";
import { GEO_PUSHPIN_CHART_UICONFIG } from "../../../constants/uiConfig";
import { getAttributeItemsWithoutStacks, getItemsCount, getItemsFromBuckets, getAllMeasures, getPreferredBucketItems, isDateBucketItem, limitNumberOfMeasuresInBuckets, removeAllArithmeticMeasuresFromDerived, removeAllDerivedMeasures, removeShowOnSecondaryAxis, } from "../../../utils/bucketHelper";
import { setGeoPushpinUiConfig } from "../../../utils/uiConfigHelpers/geoPushpinChartUiConfigHelper";
import { DASHBOARDS_ENVIRONMENT, ANALYTICAL_ENVIRONMENT } from "../../../constants/properties";
import { GEOPUSHPIN_SUPPORTED_PROPERTIES } from "../../../constants/supportedProperties";
import GeoPushpinConfigurationPanel from "../../configurationPanels/GeoPushpinConfigurationPanel";
import { BucketNames, VisualizationTypes } from "@gooddata/sdk-ui";
import { attributeAlias, attributeDisplayFormRef, bucketAttribute, idRef, insightBucket, insightBuckets, insightFilters, insightHasDataDefined, isUriRef, newAttribute, newAttributeSort, newBucket, uriRef, } from "@gooddata/sdk-model";
import { CoreGeoChart, getGeoChartDimensions } from "@gooddata/sdk-ui-geo";
import set from "lodash/set";
import isEmpty from "lodash/isEmpty";
import includes from "lodash/includes";
import cloneDeep from "lodash/cloneDeep";
import { configurePercent } from "../../../utils/bucketConfig";
import { removeSort } from "../../../utils/sort";
var NUMBER_MEASURES_IN_BUCKETS_LIMIT = 2;
/**
 * PluggableGeoPushpinChart
 *
 * ## Buckets
 *
 * | Name        | Id          | Accepts                                                   |
 * |-------------|-------------|-----------------------------------------------------------|
 * | Location    | location    | geo attributes only                                       |
 * | Size        | size        | measures only                                             |
 * | Color       | color       | measures only                                             |
 * | Segment     | segment     | attributes only                                           |
 * | TooltipText | tooltipText | attributes only, added internally, not accessible from UI |
 *
 * ### Bucket axioms
 *
 * - |Location| = 1
 * - |Size| ≤ 1
 * - |Color| ≤ 1
 * - |Segment| ≤ 1
 *
 * ## Dimensions
 *
 * The PluggableGeoPushpinChart creates either one- or two dimensional execution.
 *
 * - |Size| + |Color| ≥ 1 ⇒ [[MeasureGroupIdentifier], [Location, Segment, TooltipText]]
 * - |Size| + |Color| = 0 ⇒ [[Location, Segment, TooltipText]]
 *
 * ## Sorts
 *
 * Unless the user specifies otherwise, the sorts used by default are:
 *
 * - |Segment| ≥ 1 ⇒ [attributeSort(Segment[0])]
 */
var PluggableGeoPushpinChart = /** @class */ (function (_super) {
    __extends(PluggableGeoPushpinChart, _super);
    function PluggableGeoPushpinChart(props) {
        var _this = _super.call(this, props) || this;
        // This is effectively calling super.handlePushData()
        // https://stackoverflow.com/questions/31088947/inheritance-method-call-triggers-typescript-compiler-error
        // https://github.com/basarat/typescript-book/blob/master/docs/arrow-functions.md#tip-arrow-functions-and-inheritance
        _this.superHandlePushData = _this.handlePushData;
        // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
        _this.handlePushData = function (data) {
            // For pushpin chart we do not support drilling from attributes.
            _this.superHandlePushData(__assign(__assign({}, data), (data.availableDrillTargets && {
                availableDrillTargets: _this.withEmptyAttributeTargets(data),
            })));
        };
        var element = props.element, visualizationProperties = props.visualizationProperties;
        _this.type = VisualizationTypes.PUSHPIN;
        _this.geoPushpinElement = element;
        _this.initializeProperties(visualizationProperties);
        return _this;
    }
    PluggableGeoPushpinChart.prototype.checkBeforeRender = function (insight) {
        if (!insightHasDataDefined(insight)) {
            throw new EmptyAfmSdkError();
        }
        return true;
    };
    PluggableGeoPushpinChart.prototype.getExtendedReferencePoint = function (referencePoint) {
        var _this = this;
        return _super.prototype.getExtendedReferencePoint.call(this, referencePoint)
            .then(function (extendedReferencePoint) {
            var newReferencePoint = setGeoPushpinUiConfig(extendedReferencePoint, _this.intl, _this.type);
            newReferencePoint = configurePercent(newReferencePoint, true);
            newReferencePoint = removeSort(newReferencePoint);
            return _this.updateSupportedProperties(newReferencePoint);
        });
    };
    PluggableGeoPushpinChart.prototype.getUiConfig = function () {
        return cloneDeep(GEO_PUSHPIN_CHART_UICONFIG);
    };
    PluggableGeoPushpinChart.prototype.getExecution = function (options, insight, executionFactory) {
        var _a;
        var executionConfig = options.executionConfig;
        var buckets = this.prepareBuckets(insight);
        return (_a = executionFactory
            .forBuckets(buckets, insightFilters(insight))
            .withDimensions(getGeoChartDimensions))
            .withSorting.apply(_a, this.createSort(insight)).withExecConfig(executionConfig);
    };
    PluggableGeoPushpinChart.prototype.getSupportedPropertiesList = function () {
        return GEOPUSHPIN_SUPPORTED_PROPERTIES;
    };
    PluggableGeoPushpinChart.prototype.configureBuckets = function (extendedReferencePoint) {
        var newExtendedReferencePoint = this.sanitizeMeasures(extendedReferencePoint);
        var buckets = limitNumberOfMeasuresInBuckets(newExtendedReferencePoint.buckets, NUMBER_MEASURES_IN_BUCKETS_LIMIT);
        var allMeasures = getAllMeasures(buckets);
        var primaryMeasures = getPreferredBucketItems(buckets, [BucketNames.MEASURES, BucketNames.SIZE], [METRIC]);
        var secondaryMeasures = getPreferredBucketItems(buckets, [BucketNames.SECONDARY_MEASURES, BucketNames.COLOR], [METRIC]);
        var sizeMeasures = (primaryMeasures.length > 0
            ? primaryMeasures
            : allMeasures.filter(function (measure) { return !includes(secondaryMeasures, measure); })).slice(0, this.getPreferredBucketItemLimit(BucketNames.SIZE));
        var colorMeasures = (secondaryMeasures.length > 0
            ? secondaryMeasures
            : allMeasures.filter(function (measure) { return !includes(sizeMeasures, measure); })).slice(0, this.getPreferredBucketItemLimit(BucketNames.COLOR));
        set(newExtendedReferencePoint, BUCKETS, [
            {
                localIdentifier: BucketNames.LOCATION,
                items: this.getLocationItems(buckets),
            },
            {
                localIdentifier: BucketNames.SIZE,
                items: removeShowOnSecondaryAxis(sizeMeasures),
            },
            {
                localIdentifier: BucketNames.COLOR,
                items: removeShowOnSecondaryAxis(colorMeasures),
            },
            {
                localIdentifier: BucketNames.SEGMENT,
                items: this.getSegmentItems(buckets),
            },
        ]);
        return newExtendedReferencePoint;
    };
    PluggableGeoPushpinChart.prototype.renderConfigurationPanel = function (insight) {
        var configPanelElement = document.querySelector(this.configPanelElement);
        // NOTE: using pushData directly; no handlePushData here as in other visualizations.
        if (configPanelElement) {
            this.renderFun(React.createElement(GeoPushpinConfigurationPanel, { locale: this.locale, pushData: this.pushData, properties: this.visualizationProperties, references: this.references, propertiesMeta: this.propertiesMeta, insight: insight, colors: this.colors, type: this.type, isError: this.getIsError(), isLoading: this.isLoading, featureFlags: this.featureFlags }), configPanelElement);
        }
    };
    PluggableGeoPushpinChart.prototype.buildVisualizationConfig = function (options, supportedControls) {
        var _a = options.config, config = _a === void 0 ? {} : _a, _b = options.customVisualizationConfig, customVisualizationConfig = _b === void 0 ? {} : _b;
        var center = supportedControls.center, legend = supportedControls.legend, _c = supportedControls.viewport, viewport = _c === void 0 ? {} : _c;
        var colorMapping = _super.prototype.buildVisualizationConfig.call(this, options, supportedControls).colorMapping;
        var centerProp = center ? { center: center } : {};
        var legendProp = legend ? { legend: legend } : {};
        var isInEditMode = config.isInEditMode, isExportMode = config.isExportMode;
        if (this.environment === DASHBOARDS_ENVIRONMENT && this.featureFlags["enableKDWidgetCustomHeight"]) {
            set(supportedControls, "legend.responsive", "autoPositionWithPopup");
        }
        var viewportProp = {
            viewport: __assign(__assign({}, viewport), { frozen: isInEditMode || isExportMode }),
        };
        var geoChartConfig = __assign(__assign(__assign(__assign({}, config), centerProp), legendProp), viewportProp);
        var isKDInViewMode = this.environment !== ANALYTICAL_ENVIRONMENT && !isInEditMode;
        var cooperativeGestures = (customVisualizationConfig === null || customVisualizationConfig === void 0 ? void 0 : customVisualizationConfig.cooperativeGestures) !== undefined
            ? customVisualizationConfig.cooperativeGestures
            : isKDInViewMode;
        return __assign(__assign(__assign(__assign(__assign({ separators: config.separators, colorPalette: config.colorPalette, mapboxToken: config.mapboxToken }, supportedControls), geoChartConfig), { colorMapping: colorMapping }), customVisualizationConfig), { cooperativeGestures: cooperativeGestures });
    };
    PluggableGeoPushpinChart.prototype.renderVisualization = function (options, insight, executionFactory) {
        var _a = options.dimensions, dimensions = _a === void 0 ? { height: undefined } : _a, _b = options.custom, custom = _b === void 0 ? {} : _b, locale = options.locale, theme = options.theme;
        var height = dimensions.height;
        var _c = this, geoPushpinElement = _c.geoPushpinElement, intl = _c.intl;
        // keep height undef for AD; causes indigo-visualizations to pick default 100%
        var resultingHeight = this.environment === DASHBOARDS_ENVIRONMENT ? height : undefined;
        var drillableItems = custom.drillableItems;
        var supportedControls = this.visualizationProperties.controls || {};
        var fullConfig = this.buildVisualizationConfig(options, supportedControls);
        var execution = this.getExecution(options, insight, executionFactory);
        var geoPushpinProps = {
            drillableItems: drillableItems,
            config: fullConfig,
            height: resultingHeight,
            intl: intl,
            locale: locale,
            execution: execution,
            pushData: this.handlePushData,
            afterRender: this.afterRender,
            onDrill: this.onDrill,
            onError: this.onError,
            onExportReady: this.onExportReady,
            onLoadingChanged: this.onLoadingChanged,
            LoadingComponent: null,
            ErrorComponent: null,
            theme: theme,
        };
        this.renderFun(React.createElement(CoreGeoChart, __assign({}, geoPushpinProps)), document.querySelector(geoPushpinElement));
    };
    PluggableGeoPushpinChart.prototype.withEmptyAttributeTargets = function (data) {
        return __assign(__assign({}, data.availableDrillTargets), { attributes: [] });
    };
    PluggableGeoPushpinChart.prototype.sanitizeMeasures = function (extendedReferencePoint) {
        var newExtendedReferencePoint = removeAllArithmeticMeasuresFromDerived(extendedReferencePoint);
        return removeAllDerivedMeasures(newExtendedReferencePoint);
    };
    PluggableGeoPushpinChart.prototype.createSort = function (insight) {
        var bucket = insightBucket(insight, BucketNames.SEGMENT);
        var segmentAttribute = bucket && bucketAttribute(bucket);
        // sort by second attribute (1st: location, 2nd: segmentBy, 3rd: tooltipText)
        if (segmentAttribute) {
            return [newAttributeSort(segmentAttribute, "asc")];
        }
        return [];
    };
    PluggableGeoPushpinChart.prototype.getSegmentItems = function (buckets) {
        var segments = getPreferredBucketItems(buckets, [BucketNames.STACK, BucketNames.SEGMENT, BucketNames.COLUMNS], [ATTRIBUTE]);
        var nonSegmentAttributes = getAttributeItemsWithoutStacks(buckets);
        if (nonSegmentAttributes.length > 1 && isEmpty(segments)) {
            var locationItems_1 = this.getLocationItems(buckets);
            segments = nonSegmentAttributes
                .filter(function (attribute) { return !includes(locationItems_1, attribute); })
                .filter(function (attribute) { return !isDateBucketItem(attribute); })
                .slice(0, 1);
        }
        return segments.slice(0, this.getPreferredBucketItemLimit(BucketNames.SEGMENT));
    };
    PluggableGeoPushpinChart.prototype.getLocationItems = function (buckets) {
        var locationItems = getItemsFromBuckets(buckets, [BucketNames.ATTRIBUTE, BucketNames.VIEW, BucketNames.LOCATION, BucketNames.TREND], [ATTRIBUTE]).filter(function (bucketItem) { return Boolean(bucketItem.locationDisplayFormRef); });
        return locationItems.slice(0, this.getPreferredBucketItemLimit(BucketNames.LOCATION));
    };
    PluggableGeoPushpinChart.prototype.getPreferredBucketItemLimit = function (preferredBucket) {
        var bucketsUiConfig = this.getUiConfig().buckets;
        return bucketsUiConfig[preferredBucket].itemsLimit;
    };
    PluggableGeoPushpinChart.prototype.updateSupportedProperties = function (referencePoint) {
        var _a, _b, _c;
        var buckets = (_a = referencePoint === null || referencePoint === void 0 ? void 0 : referencePoint.buckets) !== null && _a !== void 0 ? _a : [];
        var locationItem = this.getLocationItems(buckets)[0];
        if (!locationItem) {
            return referencePoint;
        }
        var referencePointConfigured = cloneDeep(referencePoint);
        var dfRef = locationItem.dfRef;
        var visualizationProperties = this.visualizationProperties || {};
        var _d = visualizationProperties.controls, controls = _d === void 0 ? {} : _d;
        var hasSizeMeasure = getItemsCount(buckets, BucketNames.SIZE) > 0;
        var hasColorMeasure = getItemsCount(buckets, BucketNames.COLOR) > 0;
        var hasLocationAttribute = getItemsCount(buckets, BucketNames.LOCATION) > 0;
        var hasSegmentAttribute = getItemsCount(buckets, BucketNames.SEGMENT) > 0;
        var groupNearbyPoints = hasLocationAttribute && !hasColorMeasure && !hasSizeMeasure && !hasSegmentAttribute;
        // for tooltip, prefer standard text display form (whose type is `undefined`) over geo or hyperlink display forms
        var tooltipDfRef = ((_c = (_b = locationItem.displayForms) === null || _b === void 0 ? void 0 : _b.find(function (displayForm) { return !displayForm.type; })) === null || _c === void 0 ? void 0 : _c.ref) || dfRef;
        var tooltipText = isUriRef(tooltipDfRef) ? tooltipDfRef.uri : tooltipDfRef.identifier;
        set(referencePointConfigured, "properties", {
            controls: __assign(__assign({ points: {
                    groupNearbyPoints: groupNearbyPoints,
                } }, controls), { tooltipText: tooltipText }),
        });
        if (this.references) {
            set(referencePointConfigured, "references", this.references);
        }
        return referencePointConfigured;
    };
    PluggableGeoPushpinChart.prototype.prepareBuckets = function (insight) {
        var _a;
        var supportedControls = ((_a = this.visualizationProperties) === null || _a === void 0 ? void 0 : _a.controls) || {};
        // we need to shallow copy the buckets so that we can add more without mutating the original array
        var buckets = __spreadArrays(insightBuckets(insight));
        if (supportedControls === null || supportedControls === void 0 ? void 0 : supportedControls.tooltipText) {
            var tooltipText = supportedControls === null || supportedControls === void 0 ? void 0 : supportedControls.tooltipText;
            /*
             * The display form to use for tooltip text is provided in properties :( This is unfortunate; the chart
             * props could very well contain an extra prop for the tooltip bucket.
             *
             * Current guess is that this is because AD creates insight buckets; in order to create the tooltip
             * bucket, AD would have to actually show the tooltip bucket in the UI - which is not desired. Thus the
             * displayForm to add as bucket is passed in visualization properties.
             *
             * This workaround is highly unfortunate for two reasons:
             *
             * 1.  It leaks all the way to the API of geo chart: bucket geo does not have the tooltip bucket. Instead
             *     it duplicates then here logic in chart transform
             *
             * 2.  The executeVisualization endpoint is useless for GeoChart; cannot be used to render geo chart because
             *     the buckets stored in vis object are not complete. execVisualization takes buckets as is.
             */
            var locationBucket = insightBucket(insight, BucketNames.LOCATION);
            var ref = idRef(tooltipText, "displayForm");
            var alias_1 = "";
            if (locationBucket) {
                var attribute = bucketAttribute(locationBucket);
                if (attribute) {
                    alias_1 = attributeAlias(attribute);
                    if (isUriRef(attributeDisplayFormRef(attribute))) {
                        ref = uriRef(tooltipText);
                    }
                }
            }
            var existingTooltipTextBucket = insightBucket(insight, BucketNames.TOOLTIP_TEXT);
            if (!existingTooltipTextBucket) {
                buckets.push(newBucket(BucketNames.TOOLTIP_TEXT, newAttribute(ref, function (m) { return m.localId("tooltipText_df").alias(alias_1); })));
            }
        }
        return buckets;
    };
    return PluggableGeoPushpinChart;
}(PluggableBaseChart));
export { PluggableGeoPushpinChart };
//# sourceMappingURL=PluggableGeoPushpinChart.js.map