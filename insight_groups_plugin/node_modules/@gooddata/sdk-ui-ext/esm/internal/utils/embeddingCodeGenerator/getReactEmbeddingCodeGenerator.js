import { __spreadArrays } from "tslib";
// (C) 2022 GoodData Corporation
import compact from "lodash/compact";
import flow from "lodash/fp/flow";
import groupBy from "lodash/fp/groupBy";
import isEmpty from "lodash/isEmpty";
import isFunction from "lodash/isFunction";
import isString from "lodash/isString";
import join from "lodash/fp/join";
import map from "lodash/fp/map";
import partition from "lodash/fp/partition";
import repeat from "lodash/repeat";
import sortBy from "lodash/sortBy";
import toPairs from "lodash/fp/toPairs";
import uniqBy from "lodash/uniqBy";
import { factoryNotationFor } from "@gooddata/sdk-model";
import { normalizeInsight } from "./normalizeInsight";
// these are in line with what `factoryNotationFor` supports
var defaultFactories = [
    // ObjRef factories
    "uriRef",
    "idRef",
    "localIdRef",
    // attribute factories
    "newAttribute",
    // measure factories
    "newMeasure",
    "newArithmeticMeasure",
    "newPopMeasure",
    "newPreviousPeriodMeasure",
    // filter factories
    "newAbsoluteDateFilter",
    "newRelativeDateFilter",
    "newNegativeAttributeFilter",
    "newPositiveAttributeFilter",
    "newMeasureValueFilter",
    "newRankingFilter",
    // sort factories
    "newAttributeSort",
    "newAttributeAreaSort",
    "newMeasureSort",
    // total factories
    "newTotal",
].map(function (name) { return ({ name: name, importType: "named", package: "@gooddata/sdk-model" }); });
function detectFactoryImports(propDeclarations, additionalFactories) {
    var serializedProps = propDeclarations.join("\n");
    return __spreadArrays(defaultFactories, additionalFactories.map(function (f) { return f.importInfo; })).filter(function (_a) {
        var name = _a.name;
        return serializedProps.includes(name);
    });
}
function extendedFactoryNotationFor(value, additionalFactories) {
    return factoryNotationFor(value, function (obj) {
        var additionalMatch;
        for (var _i = 0, additionalFactories_1 = additionalFactories; _i < additionalFactories_1.length; _i++) {
            var f = additionalFactories_1[_i];
            additionalMatch = f.transformation(obj);
            if (additionalMatch) {
                break;
            }
        }
        return additionalMatch;
    });
}
var TAB_SIZE = 4;
var DEFAULT_HEIGHT = 400;
function indent(str, tabs) {
    return str
        .split("\n")
        .map(function (chunk) { return "" + repeat(" ", tabs * TAB_SIZE) + chunk; })
        .join("\n");
}
var renderImports = flow(groupBy(function (i) { return i.package; }), toPairs, map(function (_a) {
    var pkg = _a[0], imports = _a[1];
    var _b = partition(function (i) { return i.importType === "default"; }, imports), defaultImport = _b[0][0], namedImports = _b[1];
    return compact([
        "import",
        compact([
            defaultImport === null || defaultImport === void 0 ? void 0 : defaultImport.name,
            namedImports.length &&
                "{ " + sortBy(namedImports.map(function (i) { return i.name; }), function (i) { return i.toLowerCase(); }).join(", ") + " }",
        ]).join(", "),
        "from",
        "\"" + pkg + "\";",
    ]).join(" ");
}), join("\n"));
var REACT_IMPORT_INFO = { name: "React", package: "react", importType: "default" };
function walkProps(props, additionalFactories, config) {
    var _a, _b;
    var language = (_a = config === null || config === void 0 ? void 0 : config.language) !== null && _a !== void 0 ? _a : "ts";
    var propsToOmit = (_b = config === null || config === void 0 ? void 0 : config.omitChartProps) !== null && _b !== void 0 ? _b : [];
    var importsUsed = [];
    // we ignore undefined values and functions as there is no bullet-proof way to serialize them
    var propPairsIgnoredFunctions = toPairs(props).filter(function (_a) {
        var _ = _a[0], meta = _a[1];
        return meta !== undefined && !isFunction(meta.value) && !isEmpty(meta.value);
    });
    //omit chart configuration when define in config
    var propPairs = propPairsIgnoredFunctions.filter(function (_a) {
        var key = _a[0], _ = _a[1];
        return !propsToOmit.includes(key);
    });
    // get variable declaration for each prop to render outside of the component
    var propDeclarations = propPairs.map(function (_a) {
        var key = _a[0], _b = _a[1], value = _b.value, meta = _b.meta;
        if (isString(value)) {
            return "const " + key + " = \"" + value + "\";";
        }
        var rhsValue = extendedFactoryNotationFor(value, additionalFactories !== null && additionalFactories !== void 0 ? additionalFactories : []);
        var needsType = language === "ts";
        if (needsType) {
            var typeDeclaration = meta.cardinality === "array" ? meta.typeImport.name + "[]" : meta.typeImport.name;
            importsUsed.push(meta.typeImport);
            return "const " + key + ": " + typeDeclaration + " = " + rhsValue + ";";
        }
        else {
            return "const " + key + " = " + rhsValue + ";";
        }
    });
    // get the prop={prop} pairs to fill the component with
    var propUsages = propPairs.map(function (_a) {
        var key = _a[0];
        return key + "={" + key + "}";
    });
    // add all the factories used in the propDeclarations so that we can add their imports later
    var detectedFactories = detectFactoryImports(propDeclarations, additionalFactories !== null && additionalFactories !== void 0 ? additionalFactories : []);
    importsUsed.push.apply(importsUsed, detectedFactories);
    return {
        importsUsed: uniqBy(importsUsed, function (i) { return i.package + "#" + i.name; }),
        propDeclarations: propDeclarations,
        propUsages: propUsages,
    };
}
/**
 * Creates a React embedding code generator.
 *
 * @remarks
 * This abstracts away much of the particular-pluggable-visualization-type-agnostic logic,
 * taking the visualization-type-specific information in the `specification` parameter.
 *
 * @param specification - specification of the code generator
 * @returns function that can be used to obtain React embedding code
 */
export function getReactEmbeddingCodeGenerator(specification) {
    var component = specification.component, insightToProps = specification.insightToProps, additionalFactories = specification.additionalFactories;
    return function (insight, config) {
        var _a;
        var normalizedInsight = normalizeInsight(insight);
        var props = insightToProps(normalizedInsight, config === null || config === void 0 ? void 0 : config.context);
        var _b = walkProps(props, additionalFactories, config), importsUsed = _b.importsUsed, propDeclarations = _b.propDeclarations, propUsages = _b.propUsages;
        var imports = compact(__spreadArrays([REACT_IMPORT_INFO], importsUsed, [component]));
        var height = (_a = config === null || config === void 0 ? void 0 : config.height) !== null && _a !== void 0 ? _a : DEFAULT_HEIGHT;
        var stringifiedHeight = isString(height) ? "\"" + height + "\"" : height.toString();
        var componentBody = "<" + component.name + "\n" + indent(propUsages.join("\n"), 1) + "\n/>";
        return renderImports(imports) + "\n\n" + propDeclarations.join("\n") + "\nconst style = {height: " + stringifiedHeight + "};\n\nexport function MyComponent() {\n    return (\n        <div style={style}>\n" + indent(componentBody, 3) + "\n        </div>\n    );\n}\n";
    };
}
//# sourceMappingURL=getReactEmbeddingCodeGenerator.js.map