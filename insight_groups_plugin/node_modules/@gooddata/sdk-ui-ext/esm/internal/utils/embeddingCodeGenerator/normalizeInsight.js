import { __spreadArrays } from "tslib";
// (C) 2022 GoodData Corporation
import flow from "lodash/fp/flow";
import fromPairs from "lodash/fp/fromPairs";
import map from "lodash/fp/map";
import toPairs from "lodash/fp/toPairs";
import { attributeLocalId, bucketItems, bucketTotals, insightBuckets, insightProperties, insightSetBuckets, insightSetFilters, insightSetProperties, insightSetSorts, isAttribute, measureLocalId, newBucket, newDefForInsight, newTotal, } from "@gooddata/sdk-model";
import { Normalizer } from "@gooddata/sdk-backend-base";
function normalizeProperties(properties, o2nMap) {
    // do simple search/replace of all the original items
    var stringified = JSON.stringify(properties);
    var replaced = toPairs(o2nMap).reduce(function (acc, _a) {
        var original = _a[0], normalized = _a[1];
        var regex = new RegExp(original, "g");
        return acc.replace(regex, normalized);
    }, stringified);
    return JSON.parse(replaced);
}
/**
 * Creates an insight that has reasonable local ids instead of potentially long illegible ones in the original insight.
 *
 * @privateRemarks
 * Makes use of the {@link @gooddata/sdk-backed-base#Normalizer} to do most of the work.
 *
 * @param insight - the insight to "normalize"
 * @returns always a new instance
 * @internal
 */
export function normalizeInsight(insight) {
    var execution = newDefForInsight("foo", insight);
    var _a = Normalizer.normalize(execution, { keepRemovableProperties: true }), n2oMap = _a.n2oMap, normalized = _a.normalized;
    var o2nMap = flow(toPairs, map(function (_a) {
        var normalized = _a[0], original = _a[1];
        return [original, normalized];
    }), fromPairs)(n2oMap);
    var processedBuckets = insightBuckets(insight).map(function (originalBucket) {
        // put back stuff deleted by the normalizer
        var processedItems = bucketItems(originalBucket).map(function (originalBucketItem) {
            if (isAttribute(originalBucketItem)) {
                var normalizedId_1 = o2nMap[attributeLocalId(originalBucketItem)];
                return normalized.attributes.find(function (attr) { return attributeLocalId(attr) === normalizedId_1; });
            }
            else {
                var normalizedId_2 = o2nMap[measureLocalId(originalBucketItem)];
                return normalized.measures.find(function (measure) { return measureLocalId(measure) === normalizedId_2; });
            }
        });
        var processedTotals = bucketTotals(originalBucket).map(function (originalTotal) {
            var attributeIdentifier = originalTotal.attributeIdentifier, measureIdentifier = originalTotal.measureIdentifier, type = originalTotal.type, alias = originalTotal.alias;
            return newTotal(type, o2nMap[measureIdentifier], o2nMap[attributeIdentifier], alias);
        });
        return newBucket.apply(void 0, __spreadArrays([originalBucket.localIdentifier], processedItems, processedTotals));
    });
    var properties = insightProperties(insight);
    var processedProperties = properties && normalizeProperties(properties, o2nMap);
    return flow(function (i) { return insightSetBuckets(i, processedBuckets); }, function (i) { return insightSetFilters(i, normalized.filters); }, function (i) { return insightSetSorts(i, normalized.sortBy); }, function (i) { return insightSetProperties(i, processedProperties); })(insight);
}
//# sourceMappingURL=normalizeInsight.js.map