// (C) 2021 GoodData Corporation
import invariant from "ts-invariant";
import isNil from "lodash/isNil";
/**
 * Simplistic implementation of the HashLRU algorithm with maxAge. Heavily inspired by quick-lru.
 *
 * @remarks
 * Once IE11 support is dropped, we should remove this and just use quick-lru directly. Unfortunately,
 * the version of quick-lru that supports maxAge uses generators, so it cannot be used in IE11.
 *
 * @internal
 */
var LRUCache = /** @class */ (function () {
    function LRUCache(options) {
        if (options === void 0) { options = {}; }
        var _a, _b;
        invariant(isNil(options.maxSize) || options.maxSize >= 1, "The cache max size must be a positive number");
        invariant(isNil(options.maxAge) || options.maxAge >= 1, "The cache max age must be a positive number");
        this.maxSize = (_a = options === null || options === void 0 ? void 0 : options.maxSize) !== null && _a !== void 0 ? _a : Infinity;
        this.maxAge = (_b = options === null || options === void 0 ? void 0 : options.maxAge) !== null && _b !== void 0 ? _b : undefined;
        this.cache = new Map();
        this.oldCache = new Map();
        this.currentSize = 0;
    }
    LRUCache.prototype.set = function (key, value) {
        var expireOn = this.maxAge ? Date.now() + this.maxAge : undefined;
        if (this.cache.has(key)) {
            // if the cache already has the key, re-set it with new expiry
            this.cache.set(key, { expireOn: expireOn, value: value });
        }
        else {
            // else perform the set operation
            this.performSet(key, { expireOn: expireOn, value: value });
        }
    };
    LRUCache.prototype.get = function (key) {
        if (this.cache.has(key)) {
            // if current cache has item, check its eviction and return it
            var entry = this.cache.get(key);
            return this.getOrEvictIfExpired(key, entry);
        }
        if (this.oldCache.has(key)) {
            // if old cache has item, check its expiry, move it to current cache and return it
            var entry = this.oldCache.get(key);
            if (!this.evictIfExpired(key, entry)) {
                this.moveToCurrent(key, entry);
                return entry.value;
            }
        }
    };
    LRUCache.prototype.has = function (key) {
        // check both caches for the key and evict them if they expired
        if (this.cache.has(key)) {
            return !this.evictIfExpired(key, this.cache.get(key));
        }
        if (this.oldCache.has(key)) {
            return !this.evictIfExpired(key, this.oldCache.get(key));
        }
        return false;
    };
    LRUCache.prototype.delete = function (key) {
        // delete from both caches but only decrement currentSize of deleted from the current cache
        var didDeleteFromCurrent = this.cache.delete(key);
        var didDeleteFromOld = this.oldCache.delete(key);
        if (didDeleteFromCurrent) {
            this.currentSize--;
        }
        return didDeleteFromOld || didDeleteFromCurrent;
    };
    LRUCache.prototype.clear = function () {
        this.cache.clear();
        this.oldCache.clear();
        this.currentSize = 0;
    };
    LRUCache.prototype.performSet = function (key, entry) {
        // insert into current cache and if maxSize hit, get rid of oldCache and replace it with current
        this.cache.set(key, entry);
        this.currentSize++;
        if (this.currentSize >= this.maxSize) {
            this.currentSize = 0;
            this.oldCache = this.cache;
            this.cache = new Map();
        }
    };
    LRUCache.prototype.evictIfExpired = function (key, entry) {
        if (entry.expireOn && entry.expireOn < Date.now()) {
            return this.delete(key);
        }
        return false;
    };
    LRUCache.prototype.getOrEvictIfExpired = function (key, entry) {
        if (!entry.expireOn) {
            return entry.value;
        }
        var didDelete = this.evictIfExpired(key, entry);
        if (!didDelete) {
            return entry.value;
        }
    };
    LRUCache.prototype.moveToCurrent = function (key, entry) {
        // move the item to the current cache, this effectively implements the "LRU-ness"
        this.oldCache.delete(key);
        this.performSet(key, entry);
    };
    return LRUCache;
}());
export { LRUCache };
//# sourceMappingURL=lruCache.js.map