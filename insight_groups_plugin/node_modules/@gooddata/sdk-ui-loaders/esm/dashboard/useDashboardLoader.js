import { __assign } from "tslib";
// (C) 2021-2022 GoodData Corporation
import { useEffect, useMemo, useState } from "react";
import { useBackendStrict, useCancelablePromise, useWorkspaceStrict, } from "@gooddata/sdk-ui";
import { idRef, objRefToString, serializeObjRef } from "@gooddata/sdk-model";
import isArray from "lodash/isArray";
import compact from "lodash/compact";
import { DashboardLoader } from "./dashboardLoader";
import invariant from "ts-invariant";
var InitialStatus = {
    result: undefined,
    error: undefined,
    status: "loading",
};
var getDashboardConfig = function (config, allowUnfinishedFeatures) {
    if (config === void 0) { config = {}; }
    if (allowUnfinishedFeatures === "alwaysAllow" || allowUnfinishedFeatures === "staticOnly") {
        return __assign(__assign({}, config), { allowUnfinishedFeatures: true });
    }
    return __assign(__assign({}, config), { allowUnfinishedFeatures: false });
};
/**
 * This hook encapsulates load, bootstrap and teardown of a dashboard enhanced by plugins.
 *
 * @remarks
 * It is a one-stop hook to use for React embedding of a Dashboard and when building new dashboard plugins.
 *
 * See {@link IDashboardLoadOptions.loadingMode} to learn about loading modes
 *
 * @param options - load options
 * @public
 */
export function useDashboardLoader(options) {
    var backend = useBackendStrict(options.backend);
    var workspace = useWorkspaceStrict(options.workspace);
    var _a = useState(InitialStatus), loadStatus = _a[0], setLoadStatus = _a[1];
    var dashboard = options.dashboard, filterContextRef = options.filterContextRef, config = options.config, permissions = options.permissions, clientWorkspace = options.clientWorkspace, loadingMode = options.loadingMode, extraPlugins = options.extraPlugins, adaptiveLoadOptions = options.adaptiveLoadOptions, _b = options.allowUnfinishedFeatures, allowUnfinishedFeatures = _b === void 0 ? "alwaysPrevent" : _b;
    var dashboardRef = typeof dashboard === "string" ? idRef(dashboard) : dashboard;
    useEffect(function () {
        return function () {
            if (!loadStatus || loadStatus.status !== "success") {
                return;
            }
            var _a = loadStatus.result, ctx = _a.ctx, plugins = _a.plugins;
            plugins.forEach(function (plugin) {
                var _a;
                (_a = plugin.onPluginUnload) === null || _a === void 0 ? void 0 : _a.call(plugin, ctx);
            });
        };
    }, []);
    var dashboardLoader = useMemo(function () {
        var dashboardConfig = getDashboardConfig(config, allowUnfinishedFeatures);
        var baseProps = {
            backend: backend,
            workspace: workspace,
            dashboard: dashboardRef,
            filterContextRef: filterContextRef,
            config: dashboardConfig,
            permissions: permissions,
        };
        var loader;
        var useAdaptiveLoader = loadingMode !== "staticOnly";
        if (useAdaptiveLoader) {
            invariant(adaptiveLoadOptions, "'adaptiveLoadOptions' must be specified when adaptive loading mode is used.");
            loader = DashboardLoader.adaptive(adaptiveLoadOptions);
        }
        else {
            loader = DashboardLoader.staticOnly();
        }
        var extraPluginsArr = isArray(extraPlugins) ? extraPlugins : compact([extraPlugins]);
        initializeLoader(loader, baseProps, extraPluginsArr, clientWorkspace);
        // eslint-disable-next-line no-console
        console.log("Dashboard loader initialized in " + loadingMode + " mode to load " + (dashboardRef ? objRefToString(dashboardRef) : "empty dashboard") + ".");
        return loader;
    }, [
        backend,
        workspace,
        dashboardRef && serializeObjRef(dashboardRef),
        filterContextRef,
        config,
        permissions,
        clientWorkspace,
        extraPlugins,
    ]);
    useCancelablePromise({
        promise: function () { return dashboardLoader.load(options); },
        onLoading: function () {
            setLoadStatus(InitialStatus);
        },
        onError: function (error) {
            // eslint-disable-next-line no-console
            console.error("Dashboard load failed", error);
            setLoadStatus({
                status: "error",
                error: error,
                result: undefined,
            });
        },
        onSuccess: function (result) {
            // eslint-disable-next-line no-console
            console.log("Loaded dashboard engine", result.engine.version);
            // eslint-disable-next-line no-console
            console.log("Dashboard engine " + result.engine.version + " initialized with plugins", result.plugins.map(function (plugin) { return plugin.displayName + "/" + plugin.version; }).join(", "));
            setLoadStatus({
                status: "success",
                result: result,
                error: undefined,
            });
        },
    }, [dashboardLoader]);
    return loadStatus;
}
function initializeLoader(loader, baseProps, extraPlugins, clientWorkspace) {
    var _a;
    (_a = loader.withBaseProps(baseProps)).withEmbeddedPlugins.apply(_a, extraPlugins);
    if (clientWorkspace) {
        loader.fromClientWorkspace(clientWorkspace);
    }
    return loader;
}
//# sourceMappingURL=useDashboardLoader.js.map