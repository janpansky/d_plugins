import { __awaiter, __generator } from "tslib";
import { areObjRefsEqual, objRefToString } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
import isEmpty from "lodash/isEmpty";
import { determineDashboardEngine } from "./determineDashboardEngine";
import { DynamicScriptLoadSdkError } from "@gooddata/sdk-ui";
/**
 * @internal
 */
export function dynamicDashboardEngineLoader(dashboard, moduleFederationIntegration) {
    return __awaiter(this, void 0, void 0, function () {
        var plugins, loadedEngines;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    plugins = dashboard.references.plugins;
                    // if this bombs, this loader was called with no plugins (which means noop version should have been used)
                    invariant(!isEmpty(plugins));
                    return [4 /*yield*/, Promise.all(plugins.map(function (plugin) { return __awaiter(_this, void 0, void 0, function () {
                            var loadedEngineModule, engineFactory;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, loadEngine(moduleNameFromUrl(plugin.url), moduleFederationIntegration)()];
                                    case 1:
                                        loadedEngineModule = _a.sent();
                                        engineFactory = loadedEngineModule.default;
                                        return [2 /*return*/, engineFactory()];
                                }
                            });
                        }); }))];
                case 1:
                    loadedEngines = _a.sent();
                    return [2 /*return*/, determineDashboardEngine(loadedEngines)];
            }
        });
    });
}
/**
 * @internal
 */
export function dynamicDashboardPluginLoader(_ctx, dashboard, moduleFederationIntegration) {
    return __awaiter(this, void 0, void 0, function () {
        var referencedPlugins, pluginLinks;
        var _this = this;
        return __generator(this, function (_a) {
            referencedPlugins = dashboard.references.plugins;
            pluginLinks = dashboard.dashboard.plugins;
            if (!referencedPlugins.length || !(pluginLinks === null || pluginLinks === void 0 ? void 0 : pluginLinks.length)) {
                return [2 /*return*/, []];
            }
            return [2 /*return*/, Promise.all(
                // order of the pluginLinks is important: the plugins MUST be loaded in that order
                pluginLinks.map(function (pluginLink) { return __awaiter(_this, void 0, void 0, function () {
                    var pluginMeta, loadedModule, pluginFactory, plugin, loadedEngineModule, engineFactory, engine;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                pluginMeta = referencedPlugins.find(function (plugin) {
                                    return areObjRefsEqual(pluginLink.plugin, plugin.ref);
                                });
                                invariant(pluginMeta, "Plugin in plugin links not found in referenced plugins. Plugin ref: " + objRefToString(pluginLink.plugin));
                                return [4 /*yield*/, loadPlugin(moduleNameFromUrl(pluginMeta.url), moduleFederationIntegration)()];
                            case 1:
                                loadedModule = _a.sent();
                                pluginFactory = loadedModule.default;
                                plugin = pluginFactory();
                                if (!(plugin.maxEngineVersion === "bundled" || plugin.minEngineVersion === "bundled")) return [3 /*break*/, 3];
                                return [4 /*yield*/, loadEngine(moduleNameFromUrl(pluginMeta.url), moduleFederationIntegration)()];
                            case 2:
                                loadedEngineModule = _a.sent();
                                engineFactory = loadedEngineModule.default;
                                engine = engineFactory();
                                // We can't use spread operator here, because we need to preserve
                                // the dashboard plugin prototype methods (eg. onPluginLoaded / register / onPluginUnload)
                                plugin = Object.assign(plugin, {
                                    minEngineVersion: plugin.minEngineVersion === "bundled" ? engine.version : plugin.minEngineVersion,
                                    maxEngineVersion: plugin.maxEngineVersion === "bundled" ? engine.version : plugin.maxEngineVersion,
                                });
                                _a.label = 3;
                            case 3: return [2 /*return*/, {
                                    plugin: plugin,
                                    parameters: pluginLink === null || pluginLink === void 0 ? void 0 : pluginLink.parameters,
                                }];
                        }
                    });
                }); }))];
        });
    });
}
/**
 * @internal
 */
export function dynamicDashboardBeforeLoad(_ctx, dashboard) {
    return __awaiter(this, void 0, void 0, function () {
        var plugins, urls, tasks;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    plugins = dashboard.references.plugins;
                    if (!plugins.length) {
                        return [2 /*return*/];
                    }
                    urls = plugins.map(function (plugin) { return plugin.url; });
                    tasks = urls.map(addScriptTag);
                    // add the script tags...
                    return [4 /*yield*/, Promise.all(tasks.map(function (task) { return task.promise; }))];
                case 1:
                    // add the script tags...
                    _a.sent();
                    // ...and once they are added (and added to the global scope), remove them immediately, they are not needed anymore
                    tasks.forEach(function (_a) {
                        var element = _a.element;
                        document.head.removeChild(element);
                    });
                    return [2 /*return*/];
            }
        });
    });
}
function moduleNameFromUrl(url) {
    var _a;
    var moduleName = (_a = /.*\/([^/]+)\.js$/.exec(url)) === null || _a === void 0 ? void 0 : _a[1];
    invariant(moduleName, "Invalid plugin URL provided, it must point to the root .js file");
    return moduleName;
}
function addScriptTag(url) {
    var element = document.createElement("script");
    var promise = new Promise(function (resolve, reject) {
        element.src = url;
        element.type = "text/javascript";
        element.async = true;
        element.onload = function () {
            // eslint-disable-next-line no-console
            console.log("Dynamic Script Loaded: " + url);
            resolve();
        };
        element.onerror = function () {
            var message = "Dynamic Script Error: " + url;
            // eslint-disable-next-line no-console
            console.error(message);
            reject(new DynamicScriptLoadSdkError(message));
        };
        document.head.appendChild(element);
    });
    return {
        promise: promise,
        element: element,
    };
}
function loadEntry(moduleName, _a) {
    var _this = this;
    var __webpack_init_sharing__ = _a.__webpack_init_sharing__, __webpack_share_scopes__ = _a.__webpack_share_scopes__;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        var container, entryFactory;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: 
                // Initializes the share scope. This fills it with known provided modules from this build and all remotes
                return [4 /*yield*/, __webpack_init_sharing__("default")];
                case 1:
                    // Initializes the share scope. This fills it with known provided modules from this build and all remotes
                    _a.sent();
                    container = window[moduleName];
                    // Initialize the container, it may provide shared modules
                    return [4 /*yield*/, container.init(__webpack_share_scopes__.default)];
                case 2:
                    // Initialize the container, it may provide shared modules
                    _a.sent();
                    return [4 /*yield*/, window[moduleName].get("./" + moduleName + "_ENTRY")];
                case 3:
                    entryFactory = _a.sent();
                    return [2 /*return*/, entryFactory().default];
            }
        });
    }); };
}
function loadPlugin(moduleName, moduleFederationIntegration) {
    var _this = this;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        var entry, factory;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadEntry(moduleName, moduleFederationIntegration)()];
                case 1:
                    entry = _a.sent();
                    return [4 /*yield*/, window[moduleName].get(entry.pluginKey)];
                case 2:
                    factory = _a.sent();
                    return [2 /*return*/, factory()];
            }
        });
    }); };
}
function loadEngine(moduleName, moduleFederationIntegration) {
    var _this = this;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        var entry, factory;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, loadEntry(moduleName, moduleFederationIntegration)()];
                case 1:
                    entry = _a.sent();
                    return [4 /*yield*/, window[moduleName].get(entry.engineKey)];
                case 2:
                    factory = _a.sent();
                    return [2 /*return*/, factory()];
            }
        });
    }); };
}
//# sourceMappingURL=dynamicComponentLoaders.js.map