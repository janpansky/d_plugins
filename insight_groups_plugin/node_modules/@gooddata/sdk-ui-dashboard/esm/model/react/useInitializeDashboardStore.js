import { __assign, __read } from "tslib";
// (C) 2021-2022 GoodData Corporation
import { useEffect, useRef, useState } from "react";
import { useBackendStrict, useClientWorkspaceIdentifiers, usePrevious, useWorkspace } from "@gooddata/sdk-ui";
import { isDashboard } from "@gooddata/sdk-model";
import { objectUtils } from "@gooddata/util";
import { newRenderingWorker } from "../commandHandlers/render/renderingWorker";
import { initializeDashboard, InitialLoadCorrelationId } from "../commands";
import { createDashboardStore } from "../store/dashboardStore";
import { dashboardDeinitialized } from "../events/dashboard";
function dispatchDeinitialized(dashboardStore, initProps) {
    var dashboardRef = isDashboard(initProps.dashboard) ? initProps.dashboard.ref : initProps.dashboard;
    dashboardStore === null || dashboardStore === void 0 ? void 0 : dashboardStore.store.dispatch(dashboardDeinitialized({
        backend: initProps.backend,
        workspace: initProps.workspace,
        dashboardRef: dashboardRef,
        filterContextRef: initProps.filterContextRef,
        clientId: initProps.clientId,
        dataProductId: initProps.dataProductId,
    }, dashboardRef));
}
function useNotifyDeinitializedOnUnmount(dashboardStore, initProps) {
    // we need to keep these in refs to be able to access them from the "componentDidUnmount" effect
    // otherwise, by the time we get to that effect these would be null
    var dashboardStoreRef = useRef(dashboardStore);
    var initPropsRef = useRef(initProps);
    useEffect(function () {
        dashboardStoreRef.current = dashboardStore;
        initPropsRef.current = initProps;
    });
    useEffect(function () {
        return function () {
            dispatchDeinitialized(dashboardStoreRef.current, initPropsRef.current);
        };
    }, []);
}
/**
 * This hook is responsible for properly initializing and re-initializing the dashboard redux store,
 * when the props of the Dashboard component change.
 * It also cancels currently running sagas before the re-initialization.
 *
 * @internal
 */
export var useInitializeDashboardStore = function (props) {
    var _a;
    var dashboard = props.dashboard;
    var backend = useBackendStrict(props.backend);
    var workspace = useWorkspace(props.workspace);
    var _b = (_a = useClientWorkspaceIdentifiers()) !== null && _a !== void 0 ? _a : {}, clientId = _b.client, dataProductId = _b.dataProduct;
    var _c = __read(useState(null), 2), dashboardStore = _c[0], setDashboardStore = _c[1];
    var dashboardRef = isDashboard(dashboard) ? dashboard.ref : dashboard;
    var currentInitProps = {
        backend: backend,
        workspace: workspace,
        dashboard: dashboard,
        filterContextRef: props.filterContextRef,
        clientId: clientId,
        dataProductId: dataProductId,
        initialEventHandlers: props.eventHandlers,
    };
    var previousInitProps = usePrevious(currentInitProps);
    useNotifyDeinitializedOnUnmount(dashboardStore, currentInitProps);
    useEffect(function () {
        var _a;
        if (!objectUtils.shallowEqualObjects(previousInitProps, currentInitProps) || !dashboardStore) {
            if (dashboardStore) {
                // Trigger the deinitialize event, we are going to initialize a whole ne store right away
                // Use the previousInitProps: we want to notify the dashboard being discarded, not the new one.
                dispatchDeinitialized(dashboardStore, previousInitProps);
                // When props are different and dashboardStore is already initialized or initializing,
                // cancel all running sagas.
                dashboardStore.rootSagaTask.cancel();
            }
            var backgroundWorkers = [newRenderingWorker()];
            // Create new store and fire load dashboard command.
            var newDashboardStore = createDashboardStore({
                dashboardContext: {
                    backend: backend,
                    workspace: workspace,
                    dashboardRef: dashboardRef,
                    filterContextRef: currentInitProps.filterContextRef,
                    clientId: currentInitProps.clientId,
                    dataProductId: currentInitProps.dataProductId,
                },
                eventing: {
                    initialEventHandlers: props.eventHandlers,
                    onStateChange: props.onStateChange,
                    onEventingInitialized: props.onEventingInitialized,
                },
                backgroundWorkers: backgroundWorkers,
                privateContext: __assign(__assign({}, props.customizationFns), { preloadedDashboard: isDashboard(dashboard) ? dashboard : undefined }),
                initialRenderMode: (_a = props.initialRenderMode) !== null && _a !== void 0 ? _a : "view",
            });
            newDashboardStore.store.dispatch(initializeDashboard(props.config, props.permissions, InitialLoadCorrelationId));
            setDashboardStore(newDashboardStore);
        }
    });
    return dashboardStore;
};
//# sourceMappingURL=useInitializeDashboardStore.js.map