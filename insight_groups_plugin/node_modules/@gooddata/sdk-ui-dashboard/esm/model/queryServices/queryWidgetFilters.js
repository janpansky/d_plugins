import { __generator, __read, __spread } from "tslib";
import { all, call, select } from "redux-saga/effects";
import { createQueryService } from "../store/_infra/queryService";
import { areObjRefsEqual, filterObjRef, idRef, insightFilters, insightMeasures, isAllTimeDateFilter, isAttributeFilter, isDateFilter, isMeasureValueFilter, isRankingFilter, isSimpleMeasure, measureFilters, newAllTimeFilter, objRefToString, uriRef, isDashboardAttributeFilterReference, isInsightWidget, } from "@gooddata/sdk-model";
import { selectAllFiltersForWidgetByRef, selectWidgetByRef } from "../store/layout/layoutSelectors";
import { selectInsightByRef } from "../store/insights/insightsSelectors";
import { invalidQueryArguments } from "../events/general";
import compact from "lodash/compact";
import { selectAllCatalogDateDatasetsMap } from "../store/catalog/catalogSelectors";
import { resolveDisplayFormMetadata } from "../utils/displayFormResolver";
import invariant from "ts-invariant";
import isEmpty from "lodash/isEmpty";
export var QueryWidgetFiltersService = createQueryService("GDC.DASH/QUERY.WIDGET.FILTERS", queryService);
function refMatchesMdObject(ref, mdObject, type) {
    return (areObjRefsEqual(ref, mdObject.ref) ||
        areObjRefsEqual(ref, idRef(mdObject.id, type)) ||
        areObjRefsEqual(ref, uriRef(mdObject.uri)));
}
function loadDisplayFormsForAttributeFilters(ctx, filters) {
    var refs, resolvedObjects;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                refs = filters.map(filterObjRef);
                return [4 /*yield*/, call(resolveDisplayFormMetadata, ctx, compact(refs))];
            case 1:
                resolvedObjects = _a.sent();
                // if some display forms could not be resolved then there is something seriously amiss
                invariant(isEmpty(resolvedObjects.missing));
                return [2 /*return*/, filters.map(function (filter) {
                        return {
                            filter: filter,
                            displayForm: resolvedObjects.resolved.get(filterObjRef(filter)),
                        };
                    })];
        }
    });
}
function selectDateDatasetsForDateFilters(state, filters) {
    var fromCatalog = selectAllCatalogDateDatasetsMap(state);
    return filters.map(function (filter) {
        var dateDataset = fromCatalog.get(filterObjRef(filter));
        return {
            dateDataset: dateDataset,
            filter: filter,
        };
    });
}
function getResolvedInsightAttributeFilters(ctx, widget, dashboardAttributeFilters, insightAttributeFilters) {
    var resolvedDashboardFilters;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(getResolvedAttributeFilters, ctx, widget, dashboardAttributeFilters)];
            case 1:
                resolvedDashboardFilters = _a.sent();
                return [2 /*return*/, __spread(resolvedDashboardFilters, insightAttributeFilters)];
        }
    });
}
function getResolvedAttributeFilters(ctx, widget, attributeFilters) {
    var attributeFilterDisplayFormPairs, attributeFilterDisplayFormPairsWithIgnoreResolved;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, call(loadDisplayFormsForAttributeFilters, ctx, attributeFilters)];
            case 1:
                attributeFilterDisplayFormPairs = _a.sent();
                attributeFilterDisplayFormPairsWithIgnoreResolved = resolveWidgetFilterIgnore(widget, attributeFilterDisplayFormPairs);
                return [2 /*return*/, attributeFilterDisplayFormPairsWithIgnoreResolved.map(function (item) { return item.filter; })];
        }
    });
}
function resolveWidgetFilterIgnore(widget, dashboardNonDateFilterDisplayFormPairs) {
    return dashboardNonDateFilterDisplayFormPairs.filter(function (_a) {
        var _b;
        var displayForm = _a.displayForm;
        var matches = displayForm && ((_b = widget.ignoreDashboardFilters) === null || _b === void 0 ? void 0 : _b.filter(isDashboardAttributeFilterReference).some(function (ignored) { return refMatchesMdObject(ignored.displayForm, displayForm, "displayForm"); }));
        return !matches;
    });
}
/**
 * Tests whether dashboard's date filter should not be applied on the insight included in the provided widget.
 *
 * This should happen for insights whose simple measures are all already set up with date filters. I guess ignoring
 * global date filter is desired because otherwise there is a large chance that the intersection of global date filter
 * and measure's date filters would lead to empty set and no data shown for the insight?
 */
export function isDashboardDateFilterIgnoredForInsight(insight) {
    var simpleMeasures = insightMeasures(insight, isSimpleMeasure);
    return simpleMeasures.length > 0 && simpleMeasures.every(function (m) { var _a; return (_a = measureFilters(m)) === null || _a === void 0 ? void 0 : _a.some(isDateFilter); });
}
function selectResolvedInsightDateFilters(state, insight, dashboardDateFilters, insightDateFilters) {
    if (isDashboardDateFilterIgnoredForInsight(insight)) {
        return insightDateFilters;
    }
    return selectResolvedDateFilters(state, __spread(insightDateFilters, dashboardDateFilters));
}
function selectResolvedDateFilters(state, dateFilters) {
    var allDateFilterDateDatasetPairs = selectDateDatasetsForDateFilters(state, dateFilters);
    return resolveDateFilters(allDateFilterDateDatasetPairs);
}
function resolveDateFilters(allDateFilterDateDatasetPairs) {
    // go through the filters in reverse order using the first filter for a given dimension encountered
    // and strip useless all time filters at the end
    return allDateFilterDateDatasetPairs
        .filter(function (item) { return !!item.dateDataset; })
        .reduceRight(function (acc, curr) {
        var alreadyPresent = acc.some(function (item) {
            return refMatchesMdObject(filterObjRef(item), curr.dateDataset.dataSet, "dataSet");
        });
        if (!alreadyPresent) {
            acc.push(curr.filter);
        }
        return acc;
    }, [])
        .filter(function (item) { return !isAllTimeDateFilter(item); });
}
function queryWithInsight(ctx, widget, insight) {
    var widgetAwareDashboardFiltersSelector, widgetAwareDashboardFilters, effectiveInsightFilters, _a, dateFilters, attributeFilters;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                widgetAwareDashboardFiltersSelector = selectAllFiltersForWidgetByRef(widget.ref);
                return [4 /*yield*/, select(widgetAwareDashboardFiltersSelector)];
            case 1:
                widgetAwareDashboardFilters = _b.sent();
                // add all time filter explicitly in case the date widgetAwareDashboardFilters are empty
                // this will cause the all time filter to be used instead of the insight date filter
                // if the dashboard date filter is not ignored by the widget
                if (!widgetAwareDashboardFilters.filter(isDateFilter).length && widget.dateDataSet) {
                    widgetAwareDashboardFilters.push(newAllTimeFilter(widget.dateDataSet));
                }
                effectiveInsightFilters = insightFilters(insight);
                return [4 /*yield*/, all([
                        select(selectResolvedInsightDateFilters, insight, widgetAwareDashboardFilters.filter(isDateFilter), effectiveInsightFilters.filter(isDateFilter)),
                        call(getResolvedInsightAttributeFilters, ctx, widget, widgetAwareDashboardFilters.filter(isAttributeFilter), effectiveInsightFilters.filter(isAttributeFilter)),
                    ])];
            case 2:
                _a = __read.apply(void 0, [_b.sent(), 2]), dateFilters = _a[0], attributeFilters = _a[1];
                return [2 /*return*/, __spread(dateFilters, attributeFilters, effectiveInsightFilters.filter(isMeasureValueFilter), effectiveInsightFilters.filter(isRankingFilter))];
        }
    });
}
function queryWithoutInsight(ctx, widget) {
    var widgetAwareDashboardFiltersSelector, widgetAwareDashboardFilters, _a, dateFilters, attributeFilters;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                widgetAwareDashboardFiltersSelector = selectAllFiltersForWidgetByRef(widget.ref);
                return [4 /*yield*/, select(widgetAwareDashboardFiltersSelector)];
            case 1:
                widgetAwareDashboardFilters = _b.sent();
                return [4 /*yield*/, all([
                        select(selectResolvedDateFilters, widgetAwareDashboardFilters.filter(isDateFilter)),
                        call(getResolvedAttributeFilters, ctx, widget, widgetAwareDashboardFilters.filter(isAttributeFilter)),
                    ])];
            case 2:
                _a = __read.apply(void 0, [_b.sent(), 2]), dateFilters = _a[0], attributeFilters = _a[1];
                return [2 /*return*/, __spread(dateFilters, attributeFilters)];
        }
    });
}
function queryService(ctx, query) {
    var _a, widgetRef, insight, correlationId, widgetSelector, widget, insightRef, insightSelector, linkedInsight;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _a = query.payload, widgetRef = _a.widgetRef, insight = _a.insight, correlationId = query.correlationId;
                widgetSelector = selectWidgetByRef(widgetRef);
                return [4 /*yield*/, select(widgetSelector)];
            case 1:
                widget = _b.sent();
                if (!widget) {
                    throw invalidQueryArguments(ctx, "Widget with ref " + objRefToString(widgetRef) + " does not exist on the dashboard", correlationId);
                }
                if (!insight) return [3 /*break*/, 3];
                return [4 /*yield*/, call(queryWithInsight, ctx, widget, insight)];
            case 2: return [2 /*return*/, _b.sent()];
            case 3:
                if (!isInsightWidget(widget)) return [3 /*break*/, 6];
                insightRef = widget.insight;
                insightSelector = selectInsightByRef(insightRef);
                return [4 /*yield*/, select(insightSelector)];
            case 4:
                linkedInsight = _b.sent();
                if (!linkedInsight) {
                    throw invalidQueryArguments(ctx, "Insight with ref " + objRefToString(insightRef) + " does not exist on the dashboard", correlationId);
                }
                return [4 /*yield*/, call(queryWithInsight, ctx, widget, linkedInsight)];
            case 5: return [2 /*return*/, _b.sent()];
            case 6: return [4 /*yield*/, call(queryWithoutInsight, ctx, widget)];
            case 7: return [2 /*return*/, _b.sent()];
        }
    });
}
//# sourceMappingURL=queryWidgetFilters.js.map