import { __generator } from "tslib";
// (C) 2021-2022 GoodData Corporation
import { all, call, put, select } from "redux-saga/effects";
import invariant from "ts-invariant";
import { objRefToString } from "@gooddata/sdk-model";
import { invalidArgumentsProvided } from "../../../events/general";
import { attributeFilterAdded } from "../../../events/filters";
import { filterContextActions } from "../../../store/filterContext";
import { selectAttributeFilterDisplayFormsMap, selectFilterContextAttributeFilterByDisplayForm, selectFilterContextAttributeFilters, } from "../../../store/filterContext/filterContextSelectors";
import { dispatchFilterContextChanged } from "../common";
import { canFilterBeAdded } from "./validation/uniqueFiltersValidation";
import { dispatchDashboardEvent } from "../../../store/_infra/eventDispatcher";
import { resolveDisplayFormMetadata } from "../../../utils/displayFormResolver";
import isEmpty from "lodash/isEmpty";
import { batchActions } from "redux-batched-actions";
export function addAttributeFilterHandler(ctx, cmd) {
    var _a, displayForm, index, initialIsNegativeSelection, initialSelection, parentFilters, allFilters, resolvedDisplayForm, canBeAdded, displayFormMetadata, addedFilter, connectingAttributes;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                _a = cmd.payload, displayForm = _a.displayForm, index = _a.index, initialIsNegativeSelection = _a.initialIsNegativeSelection, initialSelection = _a.initialSelection, parentFilters = _a.parentFilters;
                return [4 /*yield*/, select(selectFilterContextAttributeFilters)];
            case 1:
                allFilters = _b.sent();
                return [4 /*yield*/, call(resolveDisplayFormMetadata, ctx, [displayForm])];
            case 2:
                resolvedDisplayForm = _b.sent();
                if (!isEmpty(resolvedDisplayForm.missing)) {
                    throw invalidArgumentsProvided(ctx, cmd, "Attempting to add filter for a non-existing display form " + objRefToString(displayForm) + ".");
                }
                return [4 /*yield*/, call(canFilterBeAdded, ctx, displayForm, allFilters)];
            case 3:
                canBeAdded = _b.sent();
                if (!canBeAdded) {
                    throw invalidArgumentsProvided(ctx, cmd, "Filter for the displayForm " + objRefToString(displayForm) + " already exists in the filter context.");
                }
                displayFormMetadata = resolvedDisplayForm.resolved.get(displayForm);
                invariant(displayFormMetadata);
                return [4 /*yield*/, put(batchActions([
                        filterContextActions.addAttributeFilter({
                            displayForm: displayFormMetadata.ref,
                            index: index,
                            initialIsNegativeSelection: initialIsNegativeSelection,
                            initialSelection: initialSelection,
                            parentFilters: parentFilters,
                        }),
                        filterContextActions.addAttributeFilterDisplayForm(displayFormMetadata),
                    ]))];
            case 4:
                _b.sent();
                return [4 /*yield*/, select(selectFilterContextAttributeFilterByDisplayForm(displayFormMetadata.ref))];
            case 5:
                addedFilter = _b.sent();
                invariant(addedFilter, "Inconsistent state in attributeFilterAddCommandHandler");
                return [4 /*yield*/, all(allFilters.map(function (filter) { return call(getConnectingAttributes, ctx, displayFormMetadata.attribute, filter); }))];
            case 6:
                connectingAttributes = _b.sent();
                return [4 /*yield*/, put(filterContextActions.updateConnectingAttributesOnFilterAdded({
                        addedFilterLocalId: addedFilter.attributeFilter.localIdentifier,
                        connectingAttributes: connectingAttributes,
                    }))];
            case 7:
                _b.sent();
                return [4 /*yield*/, dispatchDashboardEvent(attributeFilterAdded(ctx, addedFilter, cmd.payload.index, cmd.correlationId))];
            case 8:
                _b.sent();
                return [4 /*yield*/, call(dispatchFilterContextChanged, ctx, cmd)];
            case 9:
                _b.sent();
                return [2 /*return*/];
        }
    });
}
export function getConnectingAttributes(ctx, addedFilterAttribute, neighborFilter) {
    var backend, workspace, displayFormsMap, neighborFilterAttribute, connectingAttributeRefs, connectingAttributesMeta, connectingAttributes;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                backend = ctx.backend, workspace = ctx.workspace;
                return [4 /*yield*/, select(selectAttributeFilterDisplayFormsMap)];
            case 1:
                displayFormsMap = _b.sent();
                neighborFilterAttribute = (_a = displayFormsMap.get(neighborFilter.attributeFilter.displayForm)) === null || _a === void 0 ? void 0 : _a.attribute;
                invariant(neighborFilterAttribute, "Inconsistent state in attributeFilterAddCommandHandler");
                return [4 /*yield*/, call(getCommonAttributesRefs, ctx.backend, ctx.workspace, addedFilterAttribute, neighborFilterAttribute)];
            case 2:
                connectingAttributeRefs = _b.sent();
                return [4 /*yield*/, all(connectingAttributeRefs.map(function (ref) { return call(getConnectingAttributeByRef, backend, workspace, ref); }))];
            case 3:
                connectingAttributesMeta = _b.sent();
                connectingAttributes = connectingAttributesMeta.map(function (meta) {
                    return {
                        title: meta.title,
                        ref: meta.ref,
                    };
                });
                return [2 /*return*/, {
                        filterLocalId: neighborFilter.attributeFilter.localIdentifier,
                        connectingAttributes: connectingAttributes,
                    }];
        }
    });
}
function getCommonAttributesRefs(backend, workspace, addedFilterAttribute, neighborFilterAttribute) {
    return backend
        .workspace(workspace)
        .attributes()
        .getCommonAttributes([addedFilterAttribute, neighborFilterAttribute]);
}
function getConnectingAttributeByRef(backend, workspace, ref) {
    return backend.workspace(workspace).attributes().getAttribute(ref);
}
//# sourceMappingURL=addAttributeFilterHandler.js.map