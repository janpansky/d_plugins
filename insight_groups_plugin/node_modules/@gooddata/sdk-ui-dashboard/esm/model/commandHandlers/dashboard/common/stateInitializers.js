// (C) 2021-2022 GoodData Corporation
import { __assign, __generator } from "tslib";
import { alertsActions } from "../../../store/alerts";
import { filterContextActions } from "../../../store/filterContext";
import { createDefaultFilterContext } from "../../../../_staging/dashboard/defaultFilterContext";
import { layoutActions } from "../../../store/layout";
import { insightsActions } from "../../../store/insights";
import { metaActions } from "../../../store/meta";
import { uiActions } from "../../../store/ui";
import { areObjRefsEqual, isDashboardAttributeFilter, } from "@gooddata/sdk-model";
import { dashboardFilterContextDefinition, dashboardFilterContextIdentity, } from "../../../../_staging/dashboard/dashboardFilterContext";
import { dashboardLayoutSanitize } from "../../../../_staging/dashboard/dashboardLayout";
import { resolveFilterDisplayForms } from "../../../utils/filterResolver";
import { call, select } from "redux-saga/effects";
import { getPrivateContext } from "../../../store/_infra/contexts";
import { loadAvailableDisplayFormRefs } from "./loadAvailableDisplayFormRefs";
import update from "lodash/fp/update";
import isEmpty from "lodash/isEmpty";
import { loadFiltersToIndexMapping } from "../initializeDashboardHandler/loadFiltersToIndexMapping";
import { loadConnectingAttributesMatrix } from "../initializeDashboardHandler/loadConnectingAttributesMatrix";
import { selectCatalogAttributes } from "../../../store/catalog/catalogSelectors";
export var EmptyDashboardLayout = {
    type: "IDashboardLayout",
    sections: [],
};
/**
 * Returns a list of actions which when processed will initialize the essential parts of the dashboard
 * state so that it shows a new, empty dashboard.
 *
 * @param dateFilterConfig - date filter config to use for the new dashboard
 */
export function actionsToInitializeNewDashboard(dateFilterConfig) {
    return [
        alertsActions.setAlerts([]),
        filterContextActions.setFilterContext({
            filterContextDefinition: createDefaultFilterContext(dateFilterConfig),
            attributeFilterDisplayForms: [],
            filterToIndexMap: {},
            connectingAttributesMatrix: [],
        }),
        layoutActions.setLayout(EmptyDashboardLayout),
        insightsActions.setInsights([]),
        metaActions.setMeta({}),
    ];
}
function sanitizeFilterContext(ctx, filterContext) {
    var usedFilterDisplayForms, availableRefs;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                // we don't need sanitize filter references, if backend guarantees consistent references
                if (!ctx.backend.capabilities.allowsInconsistentRelations) {
                    return [2 /*return*/, filterContext];
                }
                if (!filterContext || isEmpty(filterContext.filters)) {
                    return [2 /*return*/, filterContext];
                }
                usedFilterDisplayForms = filterContext.filters
                    .filter(isDashboardAttributeFilter)
                    .map(function (f) { return f.attributeFilter.displayForm; });
                return [4 /*yield*/, call(loadAvailableDisplayFormRefs, ctx, usedFilterDisplayForms)];
            case 1:
                availableRefs = _a.sent();
                return [2 /*return*/, update("filters", function (filters) {
                        return filters.filter(function (filter) {
                            if (!isDashboardAttributeFilter(filter)) {
                                return true;
                            }
                            return availableRefs.some(function (ref) { return areObjRefsEqual(ref, filter.attributeFilter.displayForm); });
                        });
                    }, filterContext)];
        }
    });
}
/**
 * Returns a list of actions which when processed will initialize filter context, layout and meta parts
 * of the state for an existing dashboard.
 *
 * This generator will perform the essential cleanup, sanitization and resolution on top of of the input
 * dashboard and use the sanitized values to initialize the state:
 *
 * -  Layout sizing sanitization happens here
 * -  Resolution of attribute filter display forms happens here (this may be async)
 *
 * @param ctx - dashboard context in which the initialization is done
 * @param dashboard - dashboard to create initialization actions for
 * @param insights - insights used on the dashboard; note that this function will not create actions to store
 *  these insights in the state; it uses the insights to perform sanitization of the dashboard layout
 * @param settings - settings currently in effect; note that this function will not create actions to store
 *  the settings in the state; it uses the settings during layout sanitization
 * @param dateFilterConfig - effective date filter config to use; note that this function will not store
 *  the date filter config anywhere; it uses the config during filter context sanitization & determining
 *  which date option is selected
 * @param displayForms - specify display forms that should be used for in-memory resolution of
 *  attribute filter display forms to metadata objects
 */
export function actionsToInitializeExistingDashboard(ctx, dashboard, insights, settings, dateFilterConfig, displayForms) {
    var sanitizedFilterContext, sanitizedDashboard, privateCtx, customizedDashboard, filterContextDefinition, filterContextIdentity, attributeFilterDisplayForms, catalogAttributes, attributeFilters, filterToIndexMap, connectingAttributesMatrix, dashboardLayout;
    var _a, _b, _c, _d;
    return __generator(this, function (_e) {
        switch (_e.label) {
            case 0: return [4 /*yield*/, call(sanitizeFilterContext, ctx, dashboard.filterContext)];
            case 1:
                sanitizedFilterContext = _e.sent();
                sanitizedDashboard = __assign(__assign({}, dashboard), { layout: (_a = dashboard.layout) !== null && _a !== void 0 ? _a : EmptyDashboardLayout, filterContext: sanitizedFilterContext });
                return [4 /*yield*/, call(getPrivateContext)];
            case 2:
                privateCtx = _e.sent();
                customizedDashboard = (_c = (_b = privateCtx === null || privateCtx === void 0 ? void 0 : privateCtx.existingDashboardTransformFn) === null || _b === void 0 ? void 0 : _b.call(privateCtx, sanitizedDashboard)) !== null && _c !== void 0 ? _c : sanitizedDashboard;
                filterContextDefinition = dashboardFilterContextDefinition(customizedDashboard, dateFilterConfig);
                filterContextIdentity = dashboardFilterContextIdentity(customizedDashboard);
                return [4 /*yield*/, call(resolveFilterDisplayForms, ctx, filterContextDefinition.filters, displayForms)];
            case 3:
                attributeFilterDisplayForms = _e.sent();
                return [4 /*yield*/, select(selectCatalogAttributes)];
            case 4:
                catalogAttributes = _e.sent();
                attributeFilters = filterContextDefinition.filters.filter(isDashboardAttributeFilter);
                return [4 /*yield*/, call(loadFiltersToIndexMapping, attributeFilters)];
            case 5:
                filterToIndexMap = _e.sent();
                return [4 /*yield*/, call(loadConnectingAttributesMatrix, ctx.backend, ctx.workspace, attributeFilters, catalogAttributes)];
            case 6:
                connectingAttributesMatrix = _e.sent();
                dashboardLayout = dashboardLayoutSanitize((_d = customizedDashboard.layout) !== null && _d !== void 0 ? _d : EmptyDashboardLayout, insights, settings);
                return [2 /*return*/, [
                        filterContextActions.setFilterContext({
                            originalFilterContextDefinition: filterContextDefinition,
                            filterContextDefinition: filterContextDefinition,
                            filterContextIdentity: filterContextIdentity,
                            attributeFilterDisplayForms: attributeFilterDisplayForms,
                            filterToIndexMap: filterToIndexMap,
                            connectingAttributesMatrix: connectingAttributesMatrix,
                        }),
                        layoutActions.setLayout(dashboardLayout),
                        metaActions.setMeta({
                            dashboard: dashboard,
                        }),
                        uiActions.clearWidgetSelection(),
                    ]];
        }
    });
}
//# sourceMappingURL=stateInitializers.js.map