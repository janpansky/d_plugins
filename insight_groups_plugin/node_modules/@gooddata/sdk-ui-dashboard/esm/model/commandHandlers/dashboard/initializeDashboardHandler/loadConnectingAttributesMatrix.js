import { __generator } from "tslib";
// (C) 2022 GoodData Corporation
import { all, call } from "redux-saga/effects";
import compact from "lodash/compact";
import flatMap from "lodash/flatMap";
import uniqWith from "lodash/uniqWith";
import { areObjRefsEqual } from "@gooddata/sdk-model";
/**
 * Creates a matrix of connecting attribute refs for every possible combination of attribute filters.
 *
 * These connecting attributes serve to connect two attribute filters within the parent-child relationship.
 */
export function loadConnectingAttributesMatrix(backend, workspace, filters, catalogAttributes) {
    var attributes, attributePairs, connectingAttributeRefs, connectingAttributeMeta, connectingAttributeMatrix, connectingAttributeIndex, row, column, connectingAttributes;
    var _a;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0:
                attributes = compact(filters.map(function (filter) { var _a; return (_a = catalogAttributes.find(function (catalogAttribute) {
                    return catalogAttribute.displayForms.some(function (df) {
                        return areObjRefsEqual(df, filter.attributeFilter.displayForm);
                    });
                })) === null || _a === void 0 ? void 0 : _a.attribute.ref; }));
                attributePairs = attributes.map(function (attribute, index) {
                    var pairs = [];
                    for (var neighborFilterIndex = index + 1; neighborFilterIndex < attributes.length; neighborFilterIndex++) {
                        pairs.push([attribute, attributes[neighborFilterIndex]]);
                    }
                    return pairs;
                });
                if (!attributePairs.length) {
                    return [2 /*return*/, []];
                }
                return [4 /*yield*/, all(flatMap(attributePairs).map(function (pair) { return call(getConnectingAttributes, backend, workspace, pair); }))];
            case 1:
                connectingAttributeRefs = _b.sent();
                return [4 /*yield*/, all(uniqWith(flatMap(connectingAttributeRefs), areObjRefsEqual).map(function (attribute) {
                        return call(getConnectingAttributesMeta, backend, workspace, attribute);
                    }))];
            case 2:
                connectingAttributeMeta = _b.sent();
                connectingAttributeMatrix = [];
                connectingAttributeIndex = 0;
                /**
                 * Creates the connecting attributes matrix.
                 */
                for (row = 0; row < filters.length; row++) {
                    connectingAttributeMatrix[row] = connectingAttributeMatrix[row] ? connectingAttributeMatrix[row] : [];
                    for (column = row + 1; column < filters.length; column++) {
                        connectingAttributeMatrix[column] = connectingAttributeMatrix[column]
                            ? connectingAttributeMatrix[column]
                            : [];
                        connectingAttributes = (_a = connectingAttributeRefs[connectingAttributeIndex++]) === null || _a === void 0 ? void 0 : _a.map(function (ref) {
                            return connectingAttributeMeta.find(function (meta) { return areObjRefsEqual(meta.ref, ref); });
                        });
                        /**
                         * Push fetched data to square matrix.
                         */
                        connectingAttributeMatrix[row][column] = compact(connectingAttributes);
                        connectingAttributeMatrix[column][row] = compact(connectingAttributes);
                    }
                }
                return [2 /*return*/, connectingAttributeMatrix];
        }
    });
}
function getConnectingAttributesMeta(backend, workspace, ref) {
    return backend.workspace(workspace).attributes().getAttribute(ref);
}
function getConnectingAttributes(backend, workspace, refs) {
    return backend.workspace(workspace).attributes().getCommonAttributes(refs);
}
//# sourceMappingURL=loadConnectingAttributesMatrix.js.map