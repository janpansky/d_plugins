import { __read, __spread, __values } from "tslib";
import { DefaultDashboardInsight, DefaultInsightBody, } from "../../presentation";
import { InvariantError } from "ts-invariant";
import includes from "lodash/includes";
import { insightTags } from "@gooddata/sdk-model";
var DefaultDashboardInsightComponentProvider = function () {
    return DefaultDashboardInsight;
};
var DefaultInsightBodyComponentProvider = function () {
    return DefaultInsightBody;
};
var DefaultInsightCustomizerState = /** @class */ (function () {
    function DefaultInsightCustomizerState(logger, defaultCoreProvider, defaultInsightBodyProvider) {
        var _this = this;
        /*
         * Maintains index between tag and the position within coreProviderChain where the provider
         * for each tag is located. This is used to replace existing providers in case plugins make
         * multiple calls to `withTag` with the same tag.
         */
        this.tagProviderIndexes = {};
        /*
         * Core provider encapsulates resolution using the chain of core providers.
         */
        this.coreProvider = function (insight, widget) {
            var e_1, _a;
            var providerStack = __spread(_this.coreProviderChain).reverse();
            try {
                for (var providerStack_1 = __values(providerStack), providerStack_1_1 = providerStack_1.next(); !providerStack_1_1.done; providerStack_1_1 = providerStack_1.next()) {
                    var provider = providerStack_1_1.value;
                    var Component = provider(insight, widget);
                    if (Component) {
                        return Component;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (providerStack_1_1 && !providerStack_1_1.done && (_a = providerStack_1.return)) _a.call(providerStack_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            // if this happens then the provider chain got messed up. by default the chain contains the default
            // provider which never returns undefined
            throw new InvariantError();
        };
        /*
         * Insight Renderer provider encapsulates resolution using the chain of Insight Renderer providers.
         */
        this.insightRendererProvider = function (insight, widget) {
            var e_2, _a;
            var providerStack = __spread(_this.insightBodyProviderChain).reverse();
            try {
                for (var providerStack_2 = __values(providerStack), providerStack_2_1 = providerStack_2.next(); !providerStack_2_1.done; providerStack_2_1 = providerStack_2.next()) {
                    var provider = providerStack_2_1.value;
                    var Component = provider(insight, widget);
                    if (Component) {
                        return Component;
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (providerStack_2_1 && !providerStack_2_1.done && (_a = providerStack_2.return)) _a.call(providerStack_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
            // if this happens then the provider chain got messed up. by default the chain contains the default
            // provider which never returns undefined
            throw new InvariantError();
        };
        /*
         * Root provider is THE provider that should be used in the dashboard extension properties. The
         * provider function included here will reflect the setup where there may be N registered decorators
         * sitting on top of a chain of core providers.
         *
         * In the initial state the root provider IS the core provider - meaning no decorations. As the
         * decorators get registered, the rootProvider changes.
         */
        this.rootProvider = this.coreProvider;
        this.logger = logger;
        this.coreProviderChain = [defaultCoreProvider];
        this.insightBodyProviderChain = [defaultInsightBodyProvider];
    }
    DefaultInsightCustomizerState.prototype.addTagProvider = function (tag, provider) {
        // provider may already be registered for this tag
        var providerIdx = this.tagProviderIndexes[tag];
        if (providerIdx !== undefined) {
            this.logger.warn("Overriding insight component provider for tag '" + tag + "'.");
            // if that is the case, replace the previous provider (last provider wins) with this
            // new provider
            this.coreProviderChain[providerIdx] = provider;
        }
        else {
            // otherwise add new provider onto the chain
            this.tagProviderIndexes[tag] = this.coreProviderChain.length;
            this.coreProviderChain.push(provider);
        }
    };
    DefaultInsightCustomizerState.prototype.addCustomProvider = function (provider) {
        this.coreProviderChain.push(provider);
    };
    DefaultInsightCustomizerState.prototype.addInsightBodyProvider = function (provider) {
        this.insightBodyProviderChain.push(provider);
    };
    DefaultInsightCustomizerState.prototype.getRootProvider = function () {
        return this.rootProvider;
    };
    DefaultInsightCustomizerState.prototype.getInsightBodyComponentProvider = function () {
        return this.insightRendererProvider;
    };
    DefaultInsightCustomizerState.prototype.switchRootProvider = function (provider) {
        this.rootProvider = provider;
    };
    return DefaultInsightCustomizerState;
}());
/**
 * Sealed customizer state will not allow to perform any modifications of the state. Sealing the state
 * is essential to make the customization more defensive: during the registration, the plugin can hang
 * onto the dashboard customizer - stash it somewhere. And then after registration try to use the customizer
 * and try to do additional 'ad-hoc' customizations.
 *
 * Such a thing is not supported by the lifecycle and this sealing is in place to prevent plugins going into
 * that dangerous territory.
 */
var SealedInsightCustomizerState = /** @class */ (function () {
    function SealedInsightCustomizerState(logger, state) {
        var _this = this;
        this.logger = logger;
        this.state = state;
        this.addCustomProvider = function () {
            // eslint-disable-next-line no-console
            _this.logger.warn("Attempting to customize insight rendering outside of plugin registration. Ignoring.");
        };
        // eslint-disable-next-line sonarjs/no-identical-functions
        this.addInsightBodyProvider = function () {
            // eslint-disable-next-line no-console
            _this.logger.warn("Attempting to customize insight rendering outside of plugin registration. Ignoring.");
        };
        // eslint-disable-next-line sonarjs/no-identical-functions
        this.addTagProvider = function (_tag) {
            // eslint-disable-next-line no-console
            _this.logger.warn("Attempting to customize insight rendering outside of plugin registration. Ignoring.");
        };
        // eslint-disable-next-line sonarjs/no-identical-functions
        this.switchRootProvider = function () {
            // eslint-disable-next-line no-console
            _this.logger.warn("Attempting to customize insight rendering outside of plugin registration. Ignoring.");
        };
        this.getRootProvider = function () {
            return _this.state.getRootProvider();
        };
        this.getInsightBodyComponentProvider = function () {
            return _this.state.getInsightBodyComponentProvider();
        };
    }
    return SealedInsightCustomizerState;
}());
/**
 * Default implementation of the insight rendering customizer. Notice that the state of the customizations
 * is kept separate from this class.
 *
 * This code is responsible for creation of the providers (if needed) and then updating the state
 * accordingly. The customizer state methods are responsible for doing correct updates of the state itself. This
 * decoupling is in place so that it is possible to seal the state and prevent write operations from some point
 * onward. See {@link SealedInsightCustomizerState} for more motivation behind this.
 *
 * @internal
 */
var DefaultInsightCustomizer = /** @class */ (function () {
    function DefaultInsightCustomizer(logger, defaultCoreProvider, defaultInsightBodyProvider) {
        var _this = this;
        if (defaultCoreProvider === void 0) { defaultCoreProvider = DefaultDashboardInsightComponentProvider; }
        if (defaultInsightBodyProvider === void 0) { defaultInsightBodyProvider = DefaultInsightBodyComponentProvider; }
        this.withTag = function (tag, component) {
            if (!tag) {
                _this.logger.warn("The 'withTag' was called with an empty 'tag' parameter. This is effectively a noop.");
                return _this;
            }
            var newProvider = function (insight) {
                if (includes(insightTags(insight), tag)) {
                    return component;
                }
            };
            _this.state.addTagProvider(tag, newProvider);
            return _this;
        };
        this.withCustomProvider = function (provider) {
            _this.state.addCustomProvider(provider);
            return _this;
        };
        this.withCustomDecorator = function (providerFactory) {
            // snapshot current root provider
            var rootSnapshot = _this.state.getRootProvider();
            // call user's factory in order to obtain the actual provider - pass the current root so that user's
            // code can use it to obtain component to decorate
            var decoratorProvider = providerFactory(rootSnapshot);
            // construct new root provider; this will be using user's provider with a fallback to root provider
            // in case user's code does not return anything
            var newRootProvider = function (insight, widget) {
                var Component = decoratorProvider(insight, widget);
                if (Component) {
                    return Component;
                }
                return rootSnapshot(insight, widget);
            };
            // finally modify the root provider; next time someone registers decorator, it will be on top of
            // this currently registered one
            _this.state.switchRootProvider(newRootProvider);
            return _this;
        };
        this.getInsightProvider = function () {
            return _this.state.getRootProvider();
        };
        this.getInsightBodyComponentProvider = function () {
            return _this.state.getInsightBodyComponentProvider();
        };
        this.sealCustomizer = function () {
            _this.state = new SealedInsightCustomizerState(_this.logger, _this.state);
        };
        this.logger = logger;
        this.state = new DefaultInsightCustomizerState(logger, defaultCoreProvider, defaultInsightBodyProvider);
    }
    DefaultInsightCustomizer.prototype.withCustomInsightBodyProvider = function (provider) {
        this.state.addInsightBodyProvider(provider);
        return this;
    };
    return DefaultInsightCustomizer;
}());
export { DefaultInsightCustomizer };
//# sourceMappingURL=insightCustomizer.js.map