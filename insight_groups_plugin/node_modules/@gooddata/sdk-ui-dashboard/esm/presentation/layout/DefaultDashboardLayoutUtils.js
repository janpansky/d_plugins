import { __assign } from "tslib";
// (C) 2020-2022 GoodData Corporation
import { insightId, insightUri, isWidget, widgetUri, widgetId, isInsightWidget, } from "@gooddata/sdk-model";
import invariant from "ts-invariant";
import stringify from "json-stable-stringify";
import flow from "lodash/flow";
import { validateDashboardLayoutWidgetSize, } from "./DefaultDashboardLayoutRenderer";
/**
 * We need to aggressively memoize the widget sanitization results in order to prevent expensive re-renders
 * down the line - we need to keep the widgets referentially equal whenever they are not changed.
 */
export var getMemoizedWidgetSanitizer = function (cache) {
    return function (getInsightByRef, enableKDWidgetCustomHeight) {
        return function (item) {
            var widget = item.facade().widget();
            var insightAvailable = isInsightWidget(widget) && !!getInsightByRef(widget.insight);
            // we need to check if the result was made with insight available or not, it might change the result
            // of polluteWidgetRefsWithBothIdAndUri which touches the insight as well
            var cacheKey = stringify(item.facade().raw(), { space: 0 }) + "__" + insightAvailable;
            if (!cache.has(cacheKey)) {
                var resultBuilder = flow(polluteWidgetRefsWithBothIdAndUri(getInsightByRef), validateItemsSize(getInsightByRef, enableKDWidgetCustomHeight))(item);
                cache.set(cacheKey, resultBuilder.build());
            }
            return item.setItem(cache.get(cacheKey));
        };
    };
};
/**
 * Ensure that areObjRefsEqual() and other predicates will be working with uncontrolled user ref inputs
 * in custom layout transformation and/or custom widget/item renderers.
 *
 * @internal
 */
export function polluteWidgetRefsWithBothIdAndUri(getInsightByRef) {
    return function (item) {
        return item.widget(function (c) {
            var updatedContent = c;
            if (isWidget(updatedContent)) {
                updatedContent = __assign(__assign({}, updatedContent), { ref: __assign(__assign({}, updatedContent.ref), { uri: widgetUri(updatedContent), identifier: widgetId(updatedContent) }) });
            }
            if (isInsightWidget(updatedContent)) {
                var insight = getInsightByRef(updatedContent.insight);
                // sometimes this seems to be called sooner than insights are loaded leading to invariant errors
                // since the behavior is nearly impossible to replicate reliably, let's be defensive here
                if (insight) {
                    updatedContent = __assign(__assign({}, updatedContent), { insight: __assign(__assign({}, updatedContent.insight), { uri: insightUri(insight), identifier: insightId(insight) }) });
                }
            }
            return updatedContent;
        });
    };
}
/**
 * Ensure the insight widgets conform to their allowed sizes.
 *
 * @internal
 */
export function validateItemsSize(getInsightByRef, enableKDWidgetCustomHeight) {
    return function (item) {
        var widget = item.facade().widget();
        if (isInsightWidget(widget)) {
            var insight = getInsightByRef(widget.insight);
            invariant(insight, "Inconsistent insight store");
            var currentSize = item.facade().size().xl;
            var currentWidth = currentSize.gridWidth, currentHeight = currentSize.gridHeight;
            var _a = validateDashboardLayoutWidgetSize(currentWidth, currentHeight, "insight", insight, { enableKDWidgetCustomHeight: enableKDWidgetCustomHeight }), validWidth = _a.validWidth, validHeight = _a.validHeight;
            if (currentWidth !== validWidth || currentHeight !== validHeight) {
                var gridWidthProp = currentWidth !== validWidth ? { gridWidth: validWidth } : {};
                var gridHeightProp = currentHeight !== validHeight ? { gridHeight: validHeight } : {};
                return item.size({
                    xl: __assign(__assign(__assign({}, currentSize), gridWidthProp), gridHeightProp),
                });
            }
        }
        return item;
    };
}
//# sourceMappingURL=DefaultDashboardLayoutUtils.js.map