import { __assign } from "tslib";
// (C) 2019-2022 GoodData Corporation
import { useCallback } from "react";
import { isInsightWidget, } from "@gooddata/sdk-model";
import isEqual from "lodash/isEqual";
import { useDashboardSelector, selectDashboardTitle, selectDashboardUriRef, selectCurrentUser, selectLocale, selectFilterContextFilters, selectDateFormat, selectEnableKPIDashboardScheduleRecipients, selectCanListUsersInWorkspace, selectEnableKPIDashboardSchedule, selectEnableInsightExportScheduling, selectOriginalFilterContextFilters, selectWidgets, isCustomWidget, selectCanExportReport, selectScheduleEmailDialogDefaultAttachment, selectInsightsMap, } from "../../../model";
import { useCreateScheduledEmail } from "./useCreateScheduledEmail";
import { invariant } from "ts-invariant";
import { useSaveScheduledEmail } from "./useSaveScheduledEmail";
import { stripLocalIdentifierFromFilters } from "./utils/stripLocalIdentifierFromFilters";
export var useScheduledEmail = function (props) {
    var onSubmit = props.onSubmit, onSubmitSuccess = props.onSubmitSuccess, onSubmitError = props.onSubmitError, onSave = props.onSave, onSaveSuccess = props.onSaveSuccess, onSaveError = props.onSaveError;
    // Bear model expects that all refs are sanitized to uriRefs.
    var dashboardUriRef = useDashboardSelector(selectDashboardUriRef);
    // if this bombs then the controller code is bugged because it should not even allow to get
    // to this point for dashboards that are not persisted. scheduling is not possible for such
    // dashboards and so the respective menus to trigger the scheduling must not be present
    invariant(dashboardUriRef, "attempting to schedule email for unsaved dashboard");
    var dashboardTitle = useDashboardSelector(selectDashboardTitle);
    var dashboardWidgets = useDashboardSelector(selectWidgets);
    var dashboardInsights = useDashboardSelector(selectInsightsMap);
    var dashboardInsightWidgets = dashboardWidgets
        .filter(isInsightWidget)
        .filter(function (widget) { return !isCustomWidget(widget); })
        .map(function (widget) {
        var _a;
        return __assign(__assign({}, widget), { visualizationUrl: (_a = dashboardInsights.get(widget.insight)) === null || _a === void 0 ? void 0 : _a.insight.visualizationUrl });
    });
    var currentUser = useDashboardSelector(selectCurrentUser);
    var locale = useDashboardSelector(selectLocale);
    var filters = useDashboardSelector(selectFilterContextFilters);
    var originalFilters = useDashboardSelector(selectOriginalFilterContextFilters);
    var dateFormat = useDashboardSelector(selectDateFormat);
    var enableKPIDashboardScheduleRecipients = useDashboardSelector(selectEnableKPIDashboardScheduleRecipients);
    var canListUsersInWorkspace = useDashboardSelector(selectCanListUsersInWorkspace);
    var canExportReport = useDashboardSelector(selectCanExportReport);
    var enableKPIDashboardSchedule = useDashboardSelector(selectEnableKPIDashboardSchedule);
    var enableWidgetExportScheduling = useDashboardSelector(selectEnableInsightExportScheduling);
    var defaultAttachment = useDashboardSelector(selectScheduleEmailDialogDefaultAttachment);
    var scheduledEmailCreator = useCreateScheduledEmail({
        onSuccess: onSubmitSuccess,
        onError: onSubmitError,
        onBeforeRun: onSubmit,
    });
    // Compare filters without local identifiers as they are optional
    // which might cause false negative comparison result.
    var originalFiltersWithouLocalIdentifiers = stripLocalIdentifierFromFilters(originalFilters);
    var filtersWithoutLocalIdentifiers = stripLocalIdentifierFromFilters(filters);
    var hasDefaultFilters = isEqual(originalFiltersWithouLocalIdentifiers, filtersWithoutLocalIdentifiers);
    var handleCreateScheduledEmail = useCallback(function (scheduledEmail, customFilters) {
        // If dashboard filters are not changed, do not save them to scheduled email filter context.
        // Like this, future filter changes stored in the original dashboard filter context
        // are correctly propagated to the scheduled emails with the original filter context.
        var filtersToStore = hasDefaultFilters ? undefined : filters;
        scheduledEmailCreator.create(scheduledEmail, customFilters !== null && customFilters !== void 0 ? customFilters : filtersToStore);
    }, [filters, hasDefaultFilters]);
    var scheduledEmailCreationStatus = scheduledEmailCreator.creationStatus;
    var scheduledEmailSaver = useSaveScheduledEmail({
        onSuccess: onSaveSuccess,
        onError: onSaveError,
        onBeforeRun: onSave,
    });
    var handleSaveScheduledEmail = useCallback(function (scheduledEmail, filterContextRef) {
        scheduledEmailSaver.save(scheduledEmail, filterContextRef);
    }, []);
    var scheduledEmailSavingStatus = scheduledEmailSaver.savingStatus;
    return {
        dashboardRef: dashboardUriRef,
        dashboardTitle: dashboardTitle,
        dashboardInsightWidgets: dashboardInsightWidgets,
        hasDefaultFilters: hasDefaultFilters,
        canListUsersInWorkspace: canListUsersInWorkspace,
        canExportReport: canExportReport,
        enableKPIDashboardSchedule: enableKPIDashboardSchedule,
        enableKPIDashboardScheduleRecipients: enableKPIDashboardScheduleRecipients,
        enableWidgetExportScheduling: enableWidgetExportScheduling,
        dateFormat: dateFormat,
        currentUser: currentUser,
        locale: locale,
        defaultAttachment: defaultAttachment,
        handleCreateScheduledEmail: handleCreateScheduledEmail,
        scheduledEmailCreationStatus: scheduledEmailCreationStatus,
        handleSaveScheduledEmail: handleSaveScheduledEmail,
        scheduledEmailSavingStatus: scheduledEmailSavingStatus,
    };
};
//# sourceMappingURL=useScheduledEmail.js.map