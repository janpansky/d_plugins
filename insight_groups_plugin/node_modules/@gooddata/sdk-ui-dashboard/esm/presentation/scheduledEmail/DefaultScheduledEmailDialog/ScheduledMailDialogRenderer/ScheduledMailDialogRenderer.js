import { __assign, __awaiter, __extends, __generator } from "tslib";
// (C) 2019-2022 GoodData Corporation
import * as React from "react";
import cloneDeep from "lodash/cloneDeep";
import differenceBy from "lodash/differenceBy";
import isEqual from "lodash/isEqual";
import omit from "lodash/omit";
import { injectIntl, FormattedMessage } from "react-intl";
import invariant from "ts-invariant";
import parse from "date-fns/parse";
import { normalizeTime, ConfirmDialogBase, Overlay, Message } from "@gooddata/sdk-ui-kit";
import { uriRef, objRefToString, areObjRefsEqual, isDashboardAttachment, isWidgetAttachment, } from "@gooddata/sdk-model";
import { CancelError, makeCancelable, withContexts, } from "@gooddata/sdk-ui";
import memoize from "lodash/memoize";
import { DEFAULT_REPEAT_PERIOD, PLATFORM_DATE_FORMAT, REPEAT_EXECUTE_ON, REPEAT_FREQUENCIES, REPEAT_TYPES, } from "../constants";
import { isScheduleEmailExistingRecipient, isScheduleEmailExternalRecipient, } from "../interfaces";
import { generateRepeatString, setDailyRepeat, setMonthlyRepeat, setWeeklyRepeat, parseRepeatString, } from "../utils/repeat";
import { getScheduledEmailSummaryString } from "../utils/scheduledMailSummary";
import { getScheduledEmailRecipientEmail } from "../utils/scheduledMailRecipients";
import { getTimezoneByIdentifier, getUserTimezone, TIMEZONE_DEFAULT } from "../utils/timezone";
import { getDate, getMonth, getYear, convertDateToDisplayDateString, convertDateToPlatformDateString, } from "../utils/datetime";
import { isEmail } from "../utils/validate";
import { Textarea } from "./Textarea";
import { RepeatSelect } from "./RepeatSelect/RepeatSelect";
import { Input } from "./Input";
import { DateTime } from "./DateTime";
import { Attachments } from "./Attachments/Attachments";
import { RecipientsSelect } from "./RecipientsSelect/RecipientsSelect";
import { IntlWrapper } from "../../../localization";
import { DASHBOARD_TITLE_MAX_LENGTH } from "../../../constants";
import { AttachmentNoWidgets } from "./Attachments/AttachmentNoWidgets";
var MAX_MESSAGE_LENGTH = 200;
var MAX_SUBJECT_LENGTH = 200;
var MAX_DASHBOARD_TITLE_LENGTH = DASHBOARD_TITLE_MAX_LENGTH;
var MAX_HYPHEN_LENGTH = 3;
var userToRecipient = memoize(function (user) { return ({
    user: user,
}); });
var ScheduledMailDialogRendererUI = /** @class */ (function (_super) {
    __extends(ScheduledMailDialogRendererUI, _super);
    function ScheduledMailDialogRendererUI(props) {
        var _this = _super.call(this, props) || this;
        _this.onAlign = function (alignment) {
            if (alignment.top < 0) {
                _this.setState({ alignment: "tc tc" });
            }
        };
        _this.renderAttachment = function () {
            var _a = _this.props, intl = _a.intl, dashboardTitle = _a.dashboardTitle, dashboardInsightWidgets = _a.dashboardInsightWidgets, enableWidgetExportScheduling = _a.enableWidgetExportScheduling, canExportReport = _a.canExportReport;
            var _b = _this.state.attachments, dashboardSelected = _b.dashboardSelected, widgetsSelected = _b.widgetsSelected, configuration = _b.configuration;
            var defaultAttachment = _this.getDefaultAttachment();
            var fileName = defaultAttachment + ".pdf";
            return enableWidgetExportScheduling ? (React.createElement(Attachments, { dashboardTitle: dashboardTitle, insightWidgets: dashboardInsightWidgets, dashboardSelected: dashboardSelected, widgetsSelected: widgetsSelected, configuration: configuration, canExportReport: canExportReport, onAttachmentsSelectionChanged: _this.onAttachmentsChange, onAttachmentsConfigurationChanged: _this.onAttachmentsConfigurationChange })) : (React.createElement(AttachmentNoWidgets, { className: "s-gd-schedule-email-dialog-attachment", label: intl.formatMessage({ id: "dialogs.schedule.email.attachment.label" }), fileName: fileName }));
        };
        _this.renderDateTime = function () {
            var _a = _this.props, dateFormat = _a.dateFormat, intl = _a.intl, locale = _a.locale;
            var _b = _this.state, time = _b.repeat.time, startDate = _b.startDate;
            var sendDate = new Date(getYear(startDate), getMonth(startDate) - 1, getDate(startDate), time.hour, time.minute);
            return (React.createElement(DateTime, { date: sendDate, dateFormat: dateFormat, label: intl.formatMessage({ id: "dialogs.schedule.email.time.label" }), locale: locale, timezone: _this.state.userTimezone.title, onDateChange: _this.onDateChange, onTimeChange: _this.onTimeChange }));
        };
        _this.renderMessage = function () {
            var intl = _this.props.intl;
            var defaultEmailBody = _this.getDefaultEmailBody();
            return (React.createElement(Textarea, { className: "s-gd-schedule-email-dialog-message", label: intl.formatMessage({ id: "dialogs.schedule.email.message.label" }), maxlength: MAX_MESSAGE_LENGTH, placeholder: defaultEmailBody, rows: 4, onChange: _this.onMessageChange, value: _this.state.emailBody }));
        };
        _this.renderFiltersMessage = function () {
            var _a = _this.props, enableWidgetExportScheduling = _a.enableWidgetExportScheduling, hasDefaultFilters = _a.hasDefaultFilters, editSchedule = _a.editSchedule;
            if (editSchedule) {
                return (React.createElement(Message, { className: "gd-schedule-email-dialog-filters-message ", type: "progress" },
                    React.createElement(FormattedMessage, { id: "dialogs.schedule.email.filters.not.saved" })));
            }
            if (enableWidgetExportScheduling && !hasDefaultFilters) {
                return (React.createElement(Message, { className: "gd-schedule-email-dialog-filters-message ", type: "progress" },
                    React.createElement(FormattedMessage, { id: "dialogs.schedule.email.filters" })));
            }
        };
        _this.renderRecipients = function () {
            var _a, _b;
            var selectedRecipients = _this.state.selectedRecipients;
            var _c = _this.props, backend = _c.backend, workspace = _c.workspace, canListUsersInProject = _c.canListUsersInProject, enableKPIDashboardScheduleRecipients = _c.enableKPIDashboardScheduleRecipients, currentUser = _c.currentUser, editSchedule = _c.editSchedule;
            // it should be possible to remove the only remaining recipient if the author unsubscribed
            var allowEmptySelection = (_a = editSchedule === null || editSchedule === void 0 ? void 0 : editSchedule.unsubscribed) === null || _a === void 0 ? void 0 : _a.some(function (unsubscribedRecipient) { var _a; return unsubscribedRecipient === ((_a = editSchedule.createdBy) === null || _a === void 0 ? void 0 : _a.email); });
            return (React.createElement(RecipientsSelect, { author: userToRecipient((editSchedule === null || editSchedule === void 0 ? void 0 : editSchedule.createdBy) ? editSchedule === null || editSchedule === void 0 ? void 0 : editSchedule.createdBy : currentUser), currentUser: currentUser, canListUsersInProject: canListUsersInProject, enableKPIDashboardScheduleRecipients: enableKPIDashboardScheduleRecipients, value: selectedRecipients, originalValue: ((_b = _this.originalEditState) === null || _b === void 0 ? void 0 : _b.selectedRecipients) || [], onChange: _this.onRecipientsChange, onError: _this.props.onError, backend: backend, workspace: workspace, allowEmptySelection: allowEmptySelection }));
        };
        _this.renderUnsubscribedRecipients = function () {
            var _a;
            var _b = _this.props, intl = _b.intl, editSchedule = _b.editSchedule;
            var unsubscribedAmount = ((_a = editSchedule === null || editSchedule === void 0 ? void 0 : editSchedule.unsubscribed) === null || _a === void 0 ? void 0 : _a.length) === undefined ? 0 : editSchedule.unsubscribed.length;
            return (unsubscribedAmount !== 0 && (React.createElement("div", { className: "gd-input-component" },
                React.createElement("span", { className: "gd-schedule-email-dialog-unsubscribed-recipients" }, intl.formatMessage({ id: "dialogs.schedule.email.unsubscribed.recipients" }, { n: unsubscribedAmount })))));
        };
        _this.renderRepeats = function () {
            var intl = _this.props.intl;
            var _a = _this.state, startDate = _a.startDate, repeat = _a.repeat;
            var repeatFrequency = REPEAT_FREQUENCIES.DAY;
            var repeatExecuteOn = REPEAT_EXECUTE_ON.DAY_OF_MONTH;
            if (repeat.repeatFrequency.week) {
                repeatFrequency = REPEAT_FREQUENCIES.WEEK;
            }
            else if (repeat.repeatFrequency.month) {
                repeatFrequency = REPEAT_FREQUENCIES.MONTH;
                repeatExecuteOn = repeat.repeatFrequency.month.type;
            }
            return (React.createElement(RepeatSelect, { label: intl.formatMessage({ id: "dialogs.schedule.email.repeats.label" }), repeatExecuteOn: repeatExecuteOn, repeatFrequency: repeatFrequency, repeatPeriod: repeat.repeatPeriod, repeatType: repeat.repeatType, startDate: startDate, onChange: _this.onRepeatsChange }));
        };
        _this.renderSubject = function () {
            var intl = _this.props.intl;
            return (React.createElement(Input, { className: "s-gd-schedule-email-dialog-subject", label: intl.formatMessage({ id: "dialogs.schedule.email.subject.label" }), maxlength: MAX_SUBJECT_LENGTH, placeholder: _this.getDefaultSubject(), value: _this.state.emailSubject, onChange: _this.onSubjectChange }));
        };
        // Listeners
        _this.onScheduleDialogSubmit = function () {
            var _a;
            var _b = _this.props, onSubmit = _b.onSubmit, onSave = _b.onSave, editSchedule = _b.editSchedule;
            if (editSchedule) {
                if (onSave) {
                    var originalFilterContext = (_a = editSchedule === null || editSchedule === void 0 ? void 0 : editSchedule.attachments[0]) === null || _a === void 0 ? void 0 : _a.filterContext;
                    onSave(_this.getScheduleEmailData(), originalFilterContext);
                }
            }
            else {
                if (onSubmit) {
                    onSubmit(_this.getScheduleEmailData());
                }
            }
        };
        _this.onDateChange = function (selectedDateObject) {
            var repeatFrequency = _this.state.repeat.repeatFrequency;
            var newRepeat = cloneDeep(_this.state.repeat);
            if (repeatFrequency.month) {
                setMonthlyRepeat(newRepeat, repeatFrequency.month.type, selectedDateObject);
            }
            else if (repeatFrequency.week) {
                setWeeklyRepeat(newRepeat, selectedDateObject);
            }
            else {
                setDailyRepeat(newRepeat);
            }
            _this.setState({
                startDate: selectedDateObject,
                repeat: newRepeat,
            });
        };
        _this.onTimeChange = function (time) {
            _this.setState(function (prevState) {
                return {
                    repeat: __assign(__assign({}, prevState.repeat), { time: time }),
                };
            });
        };
        _this.onRecipientsChange = function (selectedRecipients) {
            var _a = _this.props, editSchedule = _a.editSchedule, currentUser = _a.currentUser;
            var allRecipientsAreEmails = selectedRecipients.map(getScheduledEmailRecipientEmail).every(isEmail);
            var newExternalRecipientsEmails = selectedRecipients
                .filter(isScheduleEmailExternalRecipient)
                .map(function (recipient) { return recipient.email; });
            var hasNewExternalRecipients = editSchedule
                ? differenceBy(newExternalRecipientsEmails, editSchedule.bcc || []).length > 0
                : false;
            var author = userToRecipient((editSchedule === null || editSchedule === void 0 ? void 0 : editSchedule.createdBy) ? editSchedule === null || editSchedule === void 0 ? void 0 : editSchedule.createdBy : currentUser);
            var currentUserIsAuthor = isScheduleEmailExistingRecipient(author) && areObjRefsEqual(author.user.ref, currentUser.ref);
            _this.setState({
                selectedRecipients: selectedRecipients,
                // new external recipients are not allowed when the current user is not the author of edited schedule
                isValidScheduleEmailData: allRecipientsAreEmails && (currentUserIsAuthor || !hasNewExternalRecipients),
            });
        };
        _this.onMessageChange = function (value) {
            _this.setState({
                emailBody: value,
            });
        };
        _this.onRepeatsChange = function (data) {
            var repeatExecuteOn = data.repeatExecuteOn, repeatFrequency = data.repeatFrequency, repeatPeriod = data.repeatPeriod, repeatType = data.repeatType;
            var startDate = _this.state.startDate;
            var newRepeat = cloneDeep(_this.state.repeat);
            newRepeat.repeatType = repeatType;
            newRepeat.repeatPeriod = repeatPeriod;
            if (repeatType === REPEAT_TYPES.CUSTOM) {
                if (repeatFrequency === REPEAT_FREQUENCIES.MONTH) {
                    setMonthlyRepeat(newRepeat, repeatExecuteOn, startDate);
                }
                else if (repeatFrequency === REPEAT_FREQUENCIES.WEEK) {
                    setWeeklyRepeat(newRepeat, startDate);
                }
                else {
                    setDailyRepeat(newRepeat);
                }
            }
            else if (repeatType === REPEAT_TYPES.MONTHLY) {
                setMonthlyRepeat(newRepeat, REPEAT_EXECUTE_ON.DAY_OF_WEEK, startDate);
            }
            else if (repeatType === REPEAT_TYPES.WEEKLY) {
                setWeeklyRepeat(newRepeat, startDate);
            }
            else {
                setDailyRepeat(newRepeat);
            }
            _this.setState({ repeat: newRepeat });
        };
        _this.onSubjectChange = function (value) {
            _this.setState({
                emailSubject: value,
            });
        };
        _this.onAttachmentsChange = function (dashboardSelected, widgetsSelected) {
            _this.setState({
                attachments: __assign(__assign({}, _this.state.attachments), { dashboardSelected: dashboardSelected,
                    widgetsSelected: widgetsSelected }),
            });
        };
        _this.onAttachmentsConfigurationChange = function (configuration) {
            _this.setState({
                attachments: __assign(__assign({}, _this.state.attachments), { configuration: configuration }),
            });
        };
        // Internal utils
        _this.getDefaultAttachment = function () {
            var _a = _this.props, dashboardTitle = _a.dashboardTitle, dateFormat = _a.dateFormat;
            var startDate = _this.state.startDate;
            var displayDateString = convertDateToDisplayDateString(startDate, dateFormat);
            var dashboardTitleMaxLength = _this.getDashboardTitleMaxLength(displayDateString);
            var isDashboardTitleTooLong = dashboardTitle.length > dashboardTitleMaxLength;
            var truncatedDashboardTitle = isDashboardTitleTooLong
                ? dashboardTitle.substring(0, dashboardTitleMaxLength)
                : dashboardTitle;
            return truncatedDashboardTitle + " - " + displayDateString;
        };
        _this.getDefaultSubject = function () {
            var dashboardTitle = _this.props.dashboardTitle;
            var isDashboardTitleTooLong = dashboardTitle.length > MAX_DASHBOARD_TITLE_LENGTH;
            var truncatedDashboardTitle = isDashboardTitleTooLong
                ? dashboardTitle.substring(0, MAX_DASHBOARD_TITLE_LENGTH)
                : dashboardTitle;
            return truncatedDashboardTitle;
        };
        _this.getDefaultEmailBody = function () {
            var intl = _this.props.intl;
            return intl.formatMessage({
                id: "dialogs.schedule.email.message.placeholder",
            });
        };
        _this.getAttachments = function (dashboard) {
            var result = [];
            var _a = _this.state.attachments, dashboardSelected = _a.dashboardSelected, widgetsSelected = _a.widgetsSelected, configuration = _a.configuration;
            if (dashboardSelected) {
                result.push({
                    dashboard: dashboard,
                    format: "pdf",
                });
            }
            var exportOptions = configuration.format === "xlsx"
                ? {
                    mergeHeaders: configuration.mergeHeaders,
                    includeFilters: configuration.includeFilters,
                }
                : undefined;
            var widgetsRefStringToUriRefMap = _this.props.dashboardInsightWidgets.reduce(function (acc, widget) {
                acc[objRefToString(widget)] = uriRef(widget.uri);
                return acc;
            }, {});
            for (var widgetRefString in widgetsSelected) {
                if (widgetsSelected[widgetRefString]) {
                    result.push({
                        widget: widgetsRefStringToUriRefMap[widgetRefString],
                        widgetDashboard: dashboard,
                        formats: [configuration.format],
                        exportOptions: exportOptions,
                    });
                }
            }
            return result;
        };
        _this.getScheduleEmailData = function () {
            var editSchedule = _this.props.editSchedule;
            var when = _this.getTimeSchedule();
            var _a = _this.state, recipients = _a.selectedRecipients, emailSubject = _a.emailSubject, emailBody = _a.emailBody;
            /// To: is currently only owner
            var toEmails = recipients
                .filter(isScheduleEmailExistingRecipient)
                .map(function (recipient) { return recipient.user.login; });
            /// All other emails (without owner)
            var bccEmails = recipients
                .filter(isScheduleEmailExternalRecipient)
                .map(function (recipient) { return recipient.email; });
            var subject = emailSubject || _this.getDefaultSubject();
            var body = emailBody || _this.getDefaultEmailBody();
            var description = _this.getSummaryMessage();
            var attachments = _this.getAttachments(_this.props.dashboard);
            var unsubscribed = undefined;
            if (editSchedule) {
                unsubscribed = differenceBy(editSchedule.unsubscribed, toEmails.concat(bccEmails));
            }
            return {
                when: when,
                to: toEmails,
                bcc: bccEmails,
                unsubscribed: unsubscribed,
                subject: subject,
                body: body,
                attachments: attachments,
                description: description,
                title: subject,
                // Every scheduled email is private for the logged in user.
                unlisted: true,
                uri: editSchedule ? editSchedule.uri : undefined,
            };
        };
        _this.getTimeSchedule = function () {
            var recurrence = generateRepeatString(_this.state.repeat);
            var startDate = convertDateToPlatformDateString(_this.state.startDate);
            return {
                recurrence: recurrence,
                startDate: startDate,
                timeZone: _this.state.userTimezone.identifier,
            };
        };
        _this.getSummaryMessage = function () {
            var _a = _this.state, startDate = _a.startDate, repeat = _a.repeat;
            return getScheduledEmailSummaryString(_this.props.intl, repeat, startDate);
        };
        _this.state = _this.props.editSchedule
            ? _this.getEditState(_this.props.editSchedule)
            : _this.getDefaultState();
        return _this;
    }
    ScheduledMailDialogRendererUI.prototype.componentWillUnmount = function () {
        var _a;
        (_a = this.getUsersCancellable) === null || _a === void 0 ? void 0 : _a.cancel();
    };
    ScheduledMailDialogRendererUI.prototype.getDefaultState = function () {
        var _a;
        var now = new Date();
        var normalizedTime = normalizeTime(now);
        return {
            alignment: "cc cc",
            startDate: now,
            userTimezone: getUserTimezone(),
            emailSubject: "",
            emailBody: "",
            repeat: {
                time: {
                    hour: normalizedTime.getHours(),
                    minute: normalizedTime.getMinutes(),
                    second: 0,
                },
                repeatType: REPEAT_TYPES.DAILY,
                repeatPeriod: DEFAULT_REPEAT_PERIOD,
                repeatFrequency: (_a = {},
                    _a[REPEAT_FREQUENCIES.DAY] = true,
                    _a),
            },
            selectedRecipients: [userToRecipient(this.props.currentUser)],
            isValidScheduleEmailData: true,
            attachments: __assign(__assign({}, this.getDefaultAttachments()), { configuration: {
                    format: "csv",
                    mergeHeaders: true,
                    includeFilters: true,
                } }),
        };
    };
    ScheduledMailDialogRendererUI.prototype.getEditState = function (schedule) {
        var _a, _b;
        var defaultState = this.getDefaultState();
        /**
         *  At this point, all recipients except the author are stored as external (IScheduleEmailExternalRecipient).
         *  They will be compared with workspace users and potentially switched to workspace recipients (IScheduleEmailExistingRecipient)
         *  silently by the method identifyWorkspaceRecipients.
         */
        var selectedRecipients = schedule.to.concat(schedule.bcc || []).map(function (email) {
            var _a;
            if (email === ((_a = schedule.createdBy) === null || _a === void 0 ? void 0 : _a.email)) {
                return userToRecipient(schedule.createdBy);
            }
            return {
                email: email,
            };
        });
        this.identifyWorkspaceRecipients();
        var dashboardAttachments = schedule.attachments.filter(isDashboardAttachment);
        var widgetAttachments = schedule.attachments.filter(isWidgetAttachment);
        var widgetsSelected = this.props.dashboardInsightWidgets.reduce(function (acc, widget) {
            var widgetKey = objRefToString(widget);
            acc[widgetKey] = widgetAttachments.some(function (widgetAttachment) {
                return areObjRefsEqual(widgetAttachment.widget, widget);
            });
            return acc;
        }, {});
        var configuration = widgetAttachments.length === 0
            ? defaultState.attachments.configuration
            : {
                format: widgetAttachments[0].formats[0] || "csv",
                mergeHeaders: ((_a = widgetAttachments[0].exportOptions) === null || _a === void 0 ? void 0 : _a.mergeHeaders) || false,
                includeFilters: ((_b = widgetAttachments[0].exportOptions) === null || _b === void 0 ? void 0 : _b.includeFilters) || false,
            };
        return __assign(__assign({}, defaultState), { emailSubject: schedule.subject, emailBody: schedule.body, selectedRecipients: selectedRecipients, userTimezone: getTimezoneByIdentifier(schedule.when.timeZone) || TIMEZONE_DEFAULT, startDate: parse(schedule.when.startDate, PLATFORM_DATE_FORMAT, new Date()), isValidScheduleEmailData: true, repeat: parseRepeatString(schedule.when.recurrence), attachments: {
                dashboardSelected: dashboardAttachments.length !== 0,
                widgetsSelected: widgetsSelected,
                configuration: configuration,
            } });
    };
    ScheduledMailDialogRendererUI.prototype.getDefaultAttachments = function () {
        var _a;
        var _b = this.props, enableWidgetExportScheduling = _b.enableWidgetExportScheduling, defaultAttachment = _b.defaultAttachment, dashboardInsightWidgets = _b.dashboardInsightWidgets;
        var isDefaultAttachmentValid = dashboardInsightWidgets.some(function (widget) {
            return areObjRefsEqual(widget.ref, defaultAttachment);
        });
        if (enableWidgetExportScheduling && defaultAttachment && isDefaultAttachmentValid) {
            return {
                dashboardSelected: false,
                widgetsSelected: (_a = {}, _a[objRefToString(defaultAttachment)] = true, _a),
            };
        }
        else {
            return {
                dashboardSelected: true,
                widgetsSelected: dashboardInsightWidgets.reduce(function (acc, widget) {
                    acc[objRefToString(widget)] = false;
                    return acc;
                }, {}),
            };
        }
    };
    ScheduledMailDialogRendererUI.prototype.render = function () {
        var _a;
        var _b = this.props, intl = _b.intl, onCancel = _b.onCancel, editSchedule = _b.editSchedule, enableWidgetExportScheduling = _b.enableWidgetExportScheduling;
        var _c = this.state, alignment = _c.alignment, isValidScheduleEmailData = _c.isValidScheduleEmailData;
        var alignPoints = [
            {
                align: alignment,
            },
        ];
        var isSubmitDisabled = !isValidScheduleEmailData ||
            (editSchedule &&
                // in editing mode wait for email addresses to be processed by this.identifyWorkspaceRecipients() and check whether anything changed
                (!((_a = this.getUsersCancellable) === null || _a === void 0 ? void 0 : _a.getHasFulfilled()) ||
                    isEqual(omit(this.originalEditState, "alignment"), omit(this.state, "alignment"))));
        return (React.createElement(Overlay, { alignPoints: alignPoints, className: "gd-schedule-email-dialog-overlay", isModal: true, positionType: "fixed", onAlign: this.onAlign },
            React.createElement(ConfirmDialogBase, { className: "gd-schedule-email-dialog s-gd-schedule-email-dialog", isPositive: true, headline: enableWidgetExportScheduling
                    ? intl.formatMessage({ id: "dialogs.schedule.email.heading" })
                    : intl.formatMessage({ id: "dialogs.schedule.email.headline" }), cancelButtonText: intl.formatMessage({ id: "cancel" }), submitButtonText: editSchedule
                    ? intl.formatMessage({ id: "dialogs.schedule.email.save" })
                    : intl.formatMessage({ id: "dialogs.schedule.email.submit" }), isSubmitDisabled: isSubmitDisabled, submitOnEnterKey: false, onCancel: onCancel, onSubmit: this.onScheduleDialogSubmit },
                this.renderFiltersMessage(),
                this.renderRecipients(),
                this.renderUnsubscribedRecipients(),
                this.renderSubject(),
                this.renderMessage(),
                this.renderAttachment(),
                React.createElement("div", { className: "hr" }),
                this.renderDateTime(),
                this.renderRepeats())));
    };
    ScheduledMailDialogRendererUI.prototype.identifyWorkspaceRecipients = function () {
        return __awaiter(this, void 0, void 0, function () {
            var _a, backend, workspace;
            var _this = this;
            return __generator(this, function (_b) {
                _a = this.props, backend = _a.backend, workspace = _a.workspace;
                invariant(backend, "backend must be defined");
                invariant(workspace, "workspace must be defined");
                this.getUsersCancellable = makeCancelable(backend.workspace(workspace).users().queryAll());
                this.getUsersCancellable.promise
                    .then(function (workspaceUsers) {
                    // process recipients and convert the general-external type to workspace recipient type
                    var processedRecipients = _this.state.selectedRecipients.map(function (recipient) {
                        if (isScheduleEmailExternalRecipient(recipient)) {
                            var user = workspaceUsers.find(function (user) { return user.email === recipient.email; });
                            if (user) {
                                return { user: user };
                            }
                        }
                        return recipient;
                    });
                    var newState = __assign(__assign({}, _this.state), { selectedRecipients: processedRecipients });
                    _this.originalEditState = newState;
                    _this.setState(newState);
                })
                    .catch(function (e) {
                    // CancelError is expected from CancellablePromise and does not mean an actual error
                    if (!(e instanceof CancelError)) {
                        throw e;
                    }
                });
                return [2 /*return*/];
            });
        });
    };
    ScheduledMailDialogRendererUI.prototype.getDashboardTitleMaxLength = function (displayDateString) {
        return MAX_DASHBOARD_TITLE_LENGTH - displayDateString.trim().length - MAX_HYPHEN_LENGTH;
    };
    ScheduledMailDialogRendererUI.defaultProps = {
        dateFormat: "MM/dd/yyyy",
    };
    return ScheduledMailDialogRendererUI;
}(React.PureComponent));
export { ScheduledMailDialogRendererUI };
export var ScheduledMailDialogRendererIntl = withContexts(injectIntl(ScheduledMailDialogRendererUI));
export var ScheduledMailDialogRenderer = function (props) { return (React.createElement(IntlWrapper, { locale: props.locale },
    React.createElement(ScheduledMailDialogRendererIntl, __assign({}, props)))); };
//# sourceMappingURL=ScheduledMailDialogRenderer.js.map