import { __assign, __read } from "tslib";
// (C) 2021-2022 GoodData Corporation
import { objRefToString } from "@gooddata/sdk-model";
import React, { useCallback } from "react";
import { changeAttributeFilterSelection, changeDateFilterSelection, clearDateFilterSelection, selectEffectiveDateFilterAvailableGranularities, selectEffectiveDateFilterMode, selectEffectiveDateFilterOptions, selectEffectiveDateFilterTitle, selectFilterContextFilters, selectIsExport, useDashboardDispatch, useDashboardSelector, } from "../../../model";
import { useDashboardComponentsContext } from "../../dashboardContexts";
import { AttributeFilterDropZone, AttributeFilterDropZoneHint, DraggableAttributeFilter, } from "../../dragAndDrop";
import { AttributesDropdown } from "../attributeFilter/addAttributeFilter/AttributesDropdown";
import { DashboardDateFilter, HiddenDashboardDateFilter } from "../dateFilter";
import { DefaultFilterBarContainer } from "./DefaultFilterBarContainer";
import { isFilterBarAttributeFilterPlaceholder, useFiltersWithAddedPlaceholder, } from "./useFiltersWithAddedPlaceholder";
import { HiddenFilterBar } from "./HiddenFilterBar";
/**
 * @alpha
 */
export var useFilterBarProps = function () {
    var filters = useDashboardSelector(selectFilterContextFilters);
    var dispatch = useDashboardDispatch();
    var onAttributeFilterChanged = useCallback(function (filter) {
        var _a = filter.attributeFilter, attributeElements = _a.attributeElements, negativeSelection = _a.negativeSelection, localIdentifier = _a.localIdentifier;
        dispatch(changeAttributeFilterSelection(localIdentifier, attributeElements, negativeSelection ? "NOT_IN" : "IN"));
    }, [dispatch]);
    var onDateFilterChanged = useCallback(function (filter, dateFilterOptionLocalId) {
        if (!filter) {
            // all time filter
            dispatch(clearDateFilterSelection());
        }
        else {
            var _a = filter.dateFilter, type = _a.type, granularity = _a.granularity, from = _a.from, to = _a.to;
            dispatch(changeDateFilterSelection(type, granularity, from, to, dateFilterOptionLocalId));
        }
    }, [dispatch]);
    return { filters: filters, onAttributeFilterChanged: onAttributeFilterChanged, onDateFilterChanged: onDateFilterChanged, DefaultFilterBar: DefaultFilterBar };
};
/**
 * @alpha
 */
export function DefaultFilterBar(props) {
    var filters = props.filters, onAttributeFilterChanged = props.onAttributeFilterChanged, onDateFilterChanged = props.onDateFilterChanged;
    var _a = __read(useFiltersWithAddedPlaceholder(filters), 2), _b = _a[0], dateFilter = _b.dateFilter, attributeFiltersWithPlaceholder = _b.attributeFiltersWithPlaceholder, attributeFiltersCount = _b.attributeFiltersCount, _c = _a[1], addAttributeFilterPlaceholder = _c.addAttributeFilterPlaceholder, closeAttributeSelection = _c.closeAttributeSelection, selectAttributeFilter = _c.selectAttributeFilter;
    var customFilterName = useDashboardSelector(selectEffectiveDateFilterTitle);
    var availableGranularities = useDashboardSelector(selectEffectiveDateFilterAvailableGranularities);
    var dateFilterOptions = useDashboardSelector(selectEffectiveDateFilterOptions);
    var dateFilterMode = useDashboardSelector(selectEffectiveDateFilterMode);
    var isExport = useDashboardSelector(selectIsExport);
    var DashboardAttributeFilterComponentProvider = useDashboardComponentsContext().DashboardAttributeFilterComponentProvider;
    if (isExport) {
        return React.createElement(HiddenFilterBar, __assign({}, props));
    }
    var dateFilterComponentConfig = {
        availableGranularities: availableGranularities,
        dateFilterOptions: dateFilterOptions,
        customFilterName: customFilterName,
    };
    return (React.createElement(DefaultFilterBarContainer, null,
        React.createElement("div", { className: "dash-filters-date dash-filters-attribute" }, dateFilterMode === "hidden" ? (React.createElement(HiddenDashboardDateFilter, null)) : (React.createElement(React.Fragment, null,
            React.createElement(DashboardDateFilter, { filter: dateFilter, onFilterChanged: onDateFilterChanged, config: dateFilterComponentConfig, readonly: dateFilterMode === "readonly" }),
            React.createElement(AttributeFilterDropZoneHint, { placement: "outside", hintPosition: "next", targetIndex: 0, onAddAttributePlaceholder: addAttributeFilterPlaceholder })))),
        attributeFiltersWithPlaceholder.map(function (filterOrPlaceholder) {
            if (isFilterBarAttributeFilterPlaceholder(filterOrPlaceholder)) {
                return (React.createElement(AttributesDropdown, { key: filterOrPlaceholder.filterIndex, onClose: closeAttributeSelection, onSelect: selectAttributeFilter }));
            }
            else {
                var filter = filterOrPlaceholder.filter, filterIndex = filterOrPlaceholder.filterIndex;
                var CustomAttributeFilterComponent = DashboardAttributeFilterComponentProvider(filter);
                return (React.createElement(DraggableAttributeFilter, { key: objRefToString(filter.attributeFilter.displayForm), filter: filter, filterIndex: filterIndex, FilterComponent: CustomAttributeFilterComponent, onAttributeFilterChanged: onAttributeFilterChanged, onAttributeFilterAdded: addAttributeFilterPlaceholder }));
            }
        }),
        React.createElement(AttributeFilterDropZone, { targetIndex: attributeFiltersCount, onDrop: addAttributeFilterPlaceholder }),
        React.createElement("div", { className: "filter-bar-dropzone-container" },
            React.createElement(AttributeFilterDropZoneHint, { placement: "outside", hintPosition: "prev", acceptPlaceholder: false, targetIndex: attributeFiltersCount - 1 }))));
}
//# sourceMappingURL=DefaultFilterBar.js.map