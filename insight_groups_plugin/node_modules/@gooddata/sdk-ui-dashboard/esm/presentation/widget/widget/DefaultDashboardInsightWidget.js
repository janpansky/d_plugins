import { __assign } from "tslib";
// (C) 2020-2022 GoodData Corporation
import React, { useMemo, useCallback } from "react";
import cx from "classnames";
import { useIntl } from "react-intl";
import { insightVisualizationUrl, widgetTitle, } from "@gooddata/sdk-model";
import { useDashboardSelector, selectInsightsMap, isCustomWidget, useDashboardScheduledEmails, selectCanExportReport, } from "../../../model";
import { DashboardItem, DashboardItemHeadline, DashboardItemVisualization, getVisTypeCssClass, } from "../../presentationComponents";
import { DashboardInsight } from "../insight/DashboardInsight";
import { useInsightExport } from "../common/useInsightExport";
import { useDashboardComponentsContext } from "../../dashboardContexts";
import { useInsightMenu } from "./useInsightMenu";
import { useWidgetSelection } from "../common/useWidgetSelection";
// Sometimes this component is rendered even before insights are ready, which blows up.
// Since the behavior is nearly impossible to replicate reliably, let's be defensive here and not render
// anything until the insights "catch up".
export var DefaultDashboardInsightWidget = function (props) {
    var widget = props.widget, 
    // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
    index = props.index;
    var insights = useDashboardSelector(selectInsightsMap);
    var insight = insights.get(widget.insight);
    if (!insight) {
        // eslint-disable-next-line no-console
        console.debug("DefaultDashboardInsightWidget rendered before the insights were ready, skipping render.");
        return null;
    }
    return (React.createElement(DefaultDashboardInsightWidgetCore, __assign({}, props, { insight: insight, 
        // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
        index: index })));
};
/**
 * @internal
 */
var DefaultDashboardInsightWidgetCore = function (_a) {
    var widget = _a.widget, insight = _a.insight, screen = _a.screen, onError = _a.onError, onExportReady = _a.onExportReady, onLoadingChanged = _a.onLoadingChanged, 
    // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
    index = _a.index;
    var intl = useIntl();
    var visType = insightVisualizationUrl(insight).split(":")[1];
    var widgetRef = widget.ref;
    var _b = useInsightExport({
        widgetRef: widgetRef,
        title: widgetTitle(widget) || intl.formatMessage({ id: "export.defaultTitle" }),
        insight: insight,
    }), exportCSVEnabled = _b.exportCSVEnabled, exportXLSXEnabled = _b.exportXLSXEnabled, onExportCSV = _b.onExportCSV, onExportXLSX = _b.onExportXLSX;
    var _c = useDashboardScheduledEmails(), isScheduledEmailingVisible = _c.isScheduledEmailingVisible, enableInsightExportScheduling = _c.enableInsightExportScheduling, onScheduleEmailingOpen = _c.onScheduleEmailingOpen;
    var canExportReport = useDashboardSelector(selectCanExportReport);
    var onScheduleExport = useCallback(function () {
        onScheduleEmailingOpen(widgetRef);
    }, [onScheduleEmailingOpen, widgetRef]);
    var scheduleExportEnabled = !isCustomWidget(widget);
    var _d = useInsightMenu({
        insight: insight,
        widget: widget,
        exportCSVEnabled: exportCSVEnabled,
        exportXLSXEnabled: exportXLSXEnabled,
        scheduleExportEnabled: scheduleExportEnabled,
        onExportCSV: onExportCSV,
        onExportXLSX: onExportXLSX,
        onScheduleExport: onScheduleExport,
        isScheduleExportVisible: isScheduledEmailingVisible && canExportReport && enableInsightExportScheduling,
    }), closeMenu = _d.closeMenu, isMenuOpen = _d.isMenuOpen, menuItems = _d.menuItems, openMenu = _d.openMenu;
    var _e = useDashboardComponentsContext(), InsightMenuButtonComponentProvider = _e.InsightMenuButtonComponentProvider, InsightMenuComponentProvider = _e.InsightMenuComponentProvider, ErrorComponent = _e.ErrorComponent, LoadingComponent = _e.LoadingComponent;
    var InsightMenuButtonComponent = useMemo(function () { return InsightMenuButtonComponentProvider(insight, widget); }, [InsightMenuButtonComponentProvider, insight, widget]);
    var InsightMenuComponent = useMemo(function () { return InsightMenuComponentProvider(insight, widget); }, [InsightMenuComponentProvider, insight, widget]);
    var _f = useWidgetSelection(widget.ref), isSelectable = _f.isSelectable, isSelected = _f.isSelected, onSelected = _f.onSelected;
    return (React.createElement(DashboardItem, { className: cx("s-dash-item-" + index, "type-visualization", "gd-dashboard-view-widget", getVisTypeCssClass(widget.type, visType)), screen: screen },
        React.createElement(DashboardItemVisualization, { isSelectable: isSelectable, isSelected: isSelected, onSelected: onSelected, renderHeadline: function (clientHeight) {
                var _a;
                return !((_a = widget.configuration) === null || _a === void 0 ? void 0 : _a.hideTitle) && (React.createElement(DashboardItemHeadline, { title: widget.title, clientHeight: clientHeight }));
            }, renderBeforeVisualization: function () { return (React.createElement(InsightMenuButtonComponent, { insight: insight, widget: widget, isOpen: isMenuOpen, onClick: openMenu, items: menuItems })); }, renderAfterContent: function () {
                if (!isMenuOpen) {
                    return null;
                }
                return (React.createElement(InsightMenuComponent, { insight: insight, widget: widget, isOpen: isMenuOpen, onClose: closeMenu, items: menuItems }));
            } }, function (_a) {
            var clientHeight = _a.clientHeight, clientWidth = _a.clientWidth;
            return (React.createElement(DashboardInsight, { clientHeight: clientHeight, clientWidth: clientWidth, insight: insight, widget: widget, onExportReady: onExportReady, onLoadingChanged: onLoadingChanged, onError: onError, ErrorComponent: ErrorComponent, LoadingComponent: LoadingComponent }));
        })));
};
//# sourceMappingURL=DefaultDashboardInsightWidget.js.map