// (C) 2020-2022 GoodData Corporation
import React, { useMemo } from "react";
import cx from "classnames";
import { UnexpectedError } from "@gooddata/sdk-backend-spi";
import { isWidget, isInsightWidget, isDashboardWidget } from "@gooddata/sdk-model";
import { BackendProvider, convertError, useBackendStrict } from "@gooddata/sdk-ui";
import { withEventing } from "@gooddata/sdk-backend-base";
import { selectAlertByWidgetRef, useDashboardEventDispatch, useDashboardSelector } from "../../../model";
import { DashboardItem } from "../../presentationComponents";
import { widgetExecutionFailed, widgetExecutionStarted, widgetExecutionSucceeded, } from "../../../model/events/widget";
import { DashboardKpi } from "../kpi/DashboardKpi";
import { DefaultDashboardInsightWidget } from "./DefaultDashboardInsightWidget";
/**
 * @internal
 */
export var DefaultDashboardWidget = function (props) {
    var onError = props.onError, onFiltersChange = props.onFiltersChange, screen = props.screen, widget = props.widget, backend = props.backend, 
    // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
    index = props.index;
    var widgetRef = widget === null || widget === void 0 ? void 0 : widget.ref;
    var alertSelector = selectAlertByWidgetRef(widgetRef);
    var alert = useDashboardSelector(alertSelector);
    var dispatchEvent = useDashboardEventDispatch();
    var effectiveBackend = useBackendStrict(backend);
    var backendWithEventing = useMemo(function () {
        // use a flag to report only the first result of the execution as per the events documented API
        var hasReportedResult = false;
        var onSuccess = function (dataView, executionId) {
            if (!hasReportedResult) {
                dispatchEvent(widgetExecutionSucceeded(widgetRef, dataView, executionId));
                hasReportedResult = true;
            }
        };
        var onError = function (error, executionId) {
            if (!hasReportedResult) {
                dispatchEvent(widgetExecutionFailed(widgetRef, convertError(error), executionId));
                hasReportedResult = true;
            }
        };
        return withEventing(effectiveBackend, {
            beforeExecute: function (def, executionId) {
                hasReportedResult = false;
                dispatchEvent(widgetExecutionStarted(widgetRef, def, executionId));
            },
            successfulResultReadAll: onSuccess,
            successfulResultReadWindow: function (_offset, _limit, dataView, executionId) {
                onSuccess(dataView, executionId);
            },
            failedExecute: onError,
            failedResultReadAll: onError,
            failedResultReadWindow: function (_offset, _limit, error, executionId) {
                onError(error, executionId);
            },
        });
    }, [effectiveBackend, dispatchEvent, widgetRef]);
    if (!isDashboardWidget(widget)) {
        throw new UnexpectedError("Cannot render custom widget with DefaultWidgetRenderer! Please handle custom widget rendering in your widgetRenderer.");
    }
    if (isWidget(widget)) {
        return (React.createElement(BackendProvider, { backend: backendWithEventing }, isInsightWidget(widget) ? (React.createElement(DefaultDashboardInsightWidget, { widget: widget, screen: screen, 
            // @ts-expect-error Don't expose index prop on public interface (we need it only for css class for KD tests)
            index: index })) : (React.createElement(DashboardItem, { className: cx("type-kpi", "s-dash-item-" + index), screen: screen },
            React.createElement(DashboardKpi, { kpiWidget: widget, alert: alert, onFiltersChange: onFiltersChange, onError: onError })))));
    }
    return React.createElement("div", null, "Unknown widget");
};
//# sourceMappingURL=DefaultDashboardWidget.js.map