import { __awaiter, __generator } from "tslib";
// (C) 2022 GoodData Corporation
import { useMemo } from "react";
import { insightSetFilters, isInsight } from "@gooddata/sdk-model";
import { useBackendStrict, useCancelablePromise, useExecutionDataView, useWorkspaceStrict, } from "@gooddata/sdk-ui";
import stringify from "json-stable-stringify";
import { useWidgetFilters } from "./useWidgetFilters";
/**
 * This hook provides an easy way to read a data view for an insight from a custom widget.
 * It resolves the appropriate filters for the widget based on the filters currently set on the whole dashboard.
 *
 * @public
 */
export function useCustomWidgetInsightDataView(_a) {
    var _this = this;
    var _b;
    var widget = _a.widget, insight = _a.insight, onCancel = _a.onCancel, onError = _a.onError, onLoading = _a.onLoading, onPending = _a.onPending, onSuccess = _a.onSuccess;
    var backend = useBackendStrict();
    var workspace = useWorkspaceStrict();
    var effectiveInsightTask = useCancelablePromise({
        promise: insight
            ? function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, isInsight(insight)
                            ? insight
                            : backend
                                .workspace(workspace)
                                .insights()
                                .getInsight(insight)];
                });
            }); }
            : null,
        onCancel: onCancel,
        onPending: onPending,
        onError: onError,
        onLoading: onLoading,
    }, [backend, workspace, insight]);
    var filterQueryTask = useWidgetFilters(
    // only pass the widget in when the insight is ready to not start the filter query while the insight is loading
    effectiveInsightTask.result ? widget : undefined, effectiveInsightTask.result);
    var insightWithAddedFilters = useMemo(function () {
        return effectiveInsightTask.result
            ? insightSetFilters(effectiveInsightTask.result, filterQueryTask.result)
            : undefined;
    }, [
        effectiveInsightTask.result,
        /**
         * We use stringified value to avoid setting equal filters. This prevents cascading cache invalidation
         * and expensive re-renders down the line. The stringification is worth it as the filters are usually
         * pretty small thus saving more time than it is taking.
         */
        stringify(filterQueryTask.result),
    ]);
    var insightExecution = useMemo(function () {
        return insightWithAddedFilters
            ? backend.workspace(workspace).execution().forInsight(insightWithAddedFilters)
            : undefined;
    }, [backend, workspace, insightWithAddedFilters, widget]);
    var dataViewTask = useExecutionDataView({
        execution: insightExecution,
        onCancel: onCancel,
        onError: onError,
        onSuccess: onSuccess,
    });
    // insight non-success status has precedence, other things cannot run without an insight
    if (effectiveInsightTask.status === "error" ||
        effectiveInsightTask.status === "loading" ||
        effectiveInsightTask.status === "pending") {
        return {
            error: effectiveInsightTask.error,
            result: undefined,
            status: effectiveInsightTask.status,
        };
    }
    if (filterQueryTask.status === "pending" || dataViewTask.status === "pending") {
        return {
            error: undefined,
            result: undefined,
            status: "pending",
        };
    }
    if (filterQueryTask.status === "running" || dataViewTask.status === "loading") {
        return {
            error: undefined,
            result: undefined,
            status: "loading",
        };
    }
    if (filterQueryTask.status === "error" || dataViewTask.status === "error") {
        if (filterQueryTask.status === "error") {
            onError === null || onError === void 0 ? void 0 : onError(filterQueryTask.error);
        }
        return {
            error: ((_b = dataViewTask.error) !== null && _b !== void 0 ? _b : filterQueryTask.error),
            result: undefined,
            status: "error",
        };
    }
    return {
        error: undefined,
        result: dataViewTask.result,
        status: "success",
    };
}
//# sourceMappingURL=useCustomWidgetInsightDataView.js.map